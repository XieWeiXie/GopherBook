
编程支持各种各样的语法的规范，但不是所有用法我们都需要使用，也不是所有语法规范都是正确的，创造者一定会在某些方面作出妥协，就好比一个工具，有各种各样的按钮完成相应功能，但一个好的作品，并不是完全使用了这个工具的所有功能，相反最核心的作品最终呈现的视觉、或者表达的思想，而不是繁复复杂的功能支持。


作为使用者，我们应该坚持那些正确的用法，摒弃那些不容易让人理解的用法，我们应该有所取舍。

本节就是在这样的思想指导下，给出一些写出让人易与理解的代码的建议。

### 3.1 变量

- 显示声明 还是选择 隐式声明？
- 定义多个变量，使用多个变量同时声明的方式还是以组的形式？
- 变量的命名还应该遵循哪些规范？

#### 3.1.1 显式声明，隐式声明

既然官方支持这两种声明方式，那如何判断哪种声明方式适合哪种场景呢？


示例：
```
package main

import "fmt"

func varDeclare() {

	var number int
	var name string

	number = 100
	name = "XieWei"

	fmt.Println(number, name)

}

func main() {
	varDeclare()
}

>>
100 XieWei
```

- 建议以显式的声明为主，即显式的指明变量的数据类型，比如：`var number int`, 指明 number 的数据类型为 int.
- 隐式的声明也有适用场景，建议短作用域的变量适用隐式的声明方式

```

func varDeclareHide() {

    // 隐式的声明：i 整型
	for i := 0; i < 3; i++ {
		fmt.Println(i)
	}
}

func main(){
    
    varDeclareHide()
    
}
>>
0
1
2
```

- 建议在 for 循环操作类的这种变量，使用隐式的变量声明方式，因为变量隐式申明之后，for 条件操作可以明确知道变量的数据类型

#### 3.1.2 多个变量如何组织

多个变量可以拆分成多个变量的声明，也可以一次性的组织，那哪种方式更合理？


```

func manyVarDeclare() {

	var numberOne, numberTwo, numberThree int
	var name string
	numberOne, numberTwo, numberThree, name = 1, 2, 3, "XieWei"

	fmt.Println(numberOne, numberTwo, numberThree, name)
}

// 块的组织的方式
func manyVarDeclareBlock() {

	var (
		numberOne, numberTwo, numberThree int
		name                              string
	)
	numberOne, numberTwo, numberThree = 1, 2, 3
	name = "XieWei"

	fmt.Println(numberOne, numberTwo, numberThree, name)

}

func main(){
    
    manyVarDeclare()
	manyVarDeclareBlock()
}

>>
1 2 3 XieWei
1 2 3 XieWei
```

- 上文在实现上，最后的效果完全一致，只不过组织的方式不一致
- 建议声明 2 个以上变量，使用块的组织方式，即将变量分组的形式
- 另外变量的声明应遵守“就近原则”，即在需要使用的变量的地方声明，而不是提前声明好，用的时候再取

#### 3.1.3 变量的命名还应该坚持哪些原则

- 多使用具体的单词，比如项目是和构建某方面内容的API，那么使用的变量或者函数命名，尽可能的使用该领域的单词
- 给变量带上更多的细节: 比如带上前缀，后缀，这种前后缀一般都是对仗的关系，比如 `last, first; begin, end; max, min`; 后缀还可以加上单位，表示更多的细节

```
// 获取切片最小的值
func fetchNumberListMin(values []int) int {

	if len(values) < 1 {
		return 0
	}
	
	if len(values) == 1 {
		return values[0]
	}
	
	var numberMin int
	numberMin = values[0]

	for _, value := range values {

		if numberMin > value {
			numberMin = value
		}
	}
	
	return numberMin

}

// 获取切片最大的值
func fetchNumberListMax(values []int) int {

	if len(values) < 1 {
		return 0
	}
	
	if len(values) == 1 {
		return values[0]
	}
	
	var numberMax int
	numberMax = values[0]

	for _, value := range values {
		if numberMax < value {
			numberMax = value
		}
	}
	
	return numberMax

}


```

- 上例使用了后缀 `max, min`，给变量或者函数带上了更多的细节


另外布尔类型，建议使用下面几个常用的单词。

```
type Info struct {
	Name   string `json:"name"`
	Age    int    `json:"age"`
	Number int    `json:"number"`
}

// 判断结构体 Info 是否存在 Name 属性
func hasInfoName(value string) bool {

	var info Info
	info.Name = "XieWei"
	info.Age = 20
	info.Number = 100

	var typeInfo reflect.Type
	typeInfo = reflect.TypeOf(info)

	if _, ok := typeInfo.FieldByName(value); ok {
		return ok
	}
	return false

}

func main(){
    
    fmt.Println(hasInfoName("Name"))
}
>>
true
```

- 布尔类型表示：真假，所以如下的单词特别适合表示这种场景：

```
ok、has、can、should、found、is...
```

### 3.2 运算

在编程语言中运算分为算术运算和逻辑运算，算术运算就和我们从小到大的学的数学差不多，逻辑运算则和逻辑操作相关。


#### 3.2.1 算术运算

最简单的就是加减乘除。

```
package main

import "fmt"

var add = func(numberOne int, numberTwo int) int {
	return numberOne + numberTwo
}

var minus = func(numberOne int, numberTwo int) int {
	return numberOne - numberTwo
}

var multiply = func(number int, price float64) float64 {
	return float64(number) * price
}

var division = func(numberOne float64, numberTwo int) float64 {
	return float64(float64(numberOne) / float64(numberTwo))
}

func main() {
	fmt.Println(add(1, 2))
	fmt.Println(minus(1, 2))
	fmt.Println(multiply(1, 2))
	fmt.Println(division(1.234, 2))

}

>>
3
-1
2
0.617
```


稍微复杂的数学操作，我们可以借助内置库 `math`, 还有一点需要注意的是，Go 是强类型的编程语言，所以在操作中尤其需要注意数据类型、类型转换，稍微不注意，有可能得不到自己需要的结果。

#### 3.2.2 逻辑运算

逻辑运算通常作为配合 if...else  操作，用来判断是非操作。

    || 或： 一个条件满足，即满足
    && 与： 两个条件都满足，才满足
    != 非： 一个条件的反面



```
var judgeMarry = func(manAge int, womanAge int) bool {
	if manAge >= 22 && womanAge >= 20 {
		return true
	}
	return false
}

func main(){
    
    fmt.Println(judgeMarry(20, 20))
	fmt.Println(judgeMarry(25, 26))
	fmt.Println(judgeMarry(18, 20))
}
>>
false
true
false
```

上文表示一个根据年龄判断是否可以是法定结婚年龄的函数，判断条件是： `manAge >=22 并且 womanAge>=20`  才是法定结婚年龄。


讲到逻辑运算配合 if ...else 使用，如果是多个条件判断，如何写出一个更易于理解的 if...else?

- 常量放右边，变量放左边： `if number <= 10`
- 先判断正向逻辑的，再判断负向逻辑
- 先处理简单
- 先处理有趣的或者可疑的

上面几条规则有可能帮你梳理思路。

需求：
根据输入的 ShopType 字段是否是 RegionEntrances；

- 如果是，搜索数据库，看数据是否是有此字段，存在则获取shopUUID
- 否则 产生 shopUUID
- 如果根本不是 RegionEntrances 字段，则产生 shopUUID

```
// 反例

if createParam.Data.ShopType != RegionEntrances {
    newShop.ShopUUID = tools.GenerateUUID(16, createParam.Data.Name, company.Name)
} else {
    var tmpShop models.Shop
    if notFound := database.POSTGRES.Where("company_id = ? AND shop_type = ?", company.ID, createParam.Data.ShopType).First(&tmpShop).RecordNotFound(); notFound {
        newShop.ShopUUID = tools.GenerateUUID(16, createParam.Data.Name, company.Name)
    } else {
        newShop.ShopUUID = tmpShop.ShopUUID
    }

}

```

```
// 正例

if createParam.Data.ShopType == RegionEntrances {
    var tmpShop models.Shop
    if notFound := database.POSTGRES.Where("company_id = ? AND shop_type = ?", company.ID, createParam.Data.ShopType).First(&tmpShop).RecordNotFound(); !notFound {
        newShop.ShopUUID = tmpShop.ShopUUID
    } else {
        newShop.ShopUUID = tools.GenerateUUID(16, createParam.Data.Name, company.Name)
    }
} else {
    newShop.ShopUUID = tools.GenerateUUID(16, createParam.Data.Name, company.Name)

}

```

正例坚持了一些规则，使梳理逻辑更为顺畅。

### 3.3 数组和切片

上一章节，我们已经知道，数组和切片的定义，数组和切片几乎一致，数组和切片的区别在于数组固定长度，切片可以扩充容量。

**操作**

```
var opList = func(number [4]int) {
	fmt.Println(number[1], reflect.TypeOf(number[1]))
	fmt.Println(len(number))
	fmt.Println(number[1:], reflect.TypeOf(number[1:]))

	for index, one := range number {
		fmt.Println(index, one)
	}

	for i := 0; i < len(number); i++ {
		fmt.Println(i, number[i])
	}
}

var opSlice = func(name []string) []string {
	fmt.Println(name[1], reflect.TypeOf(name[1]))

	for index, one := range name {
		fmt.Println(index, one)
	}

	name = append(name, "XieWei")

	return name
}
func main(){
    
    var number [4]int = [...]int{1, 2, 3, 4}
	opList(number)

	var name []string = []string{"Go", "Python", "Java", "C++", "C#"}
	fmt.Println(opSlice(name))
}
>>
2 int
4
[2 3 4] []int
0 1
1 2
2 3
3 4
0 1
1 2
2 3
3 4
Python string
0 Go
1 Python
2 Java
3 C++
4 C#
[Go Python Java C++ C# XieWei]
```


可以看出，数组和切片的操作几乎一致，切片因为可以扩充容量，所以多了  `append` 方法。

虽然切片可以自动的扩充容量（长度），但底层并不是动态数组或者数组指针，而是通过指针指向底层数组。所以经常可以使用数组来创建切片，比如 `numberList[1:]`

切片是引用类型，所以初始化可以显式的赋值法，也可以使用 `make` 。



### 3.4 Map

字典是一种搜索速度非常快的数据结构，在日常使用中的频率非常的高，是一种无序键值对集合。

既然是键值对，那么核心的操作是键值的操作。

```

var opMap = func(name map[string]int) map[string]int {

	for key, value := range name {
		fmt.Println(key, value)
	}

	name["Life"] = 100

	if value, ok := name["Go"]; ok {
		fmt.Println(value)
	} else {
		fmt.Println("no exists Go")

	}
	
	delete(name, "java")

	return name
}

func main(){
    
    nameMap := make(map[string]int)
	nameMap["java"] = 200
	nameMap["php"] = 100
	nameMap["python"] = 180
	nameMap["js"] = 220

	fmt.Println(opMap(nameMap))
}
>>
java 200
php 100
python 180
js 220
no exists Go
map[python:180 js:220 Life:100 php:100]
```

- map 引用类型，使用 make 初始化
- 无序：输出顺序和定义顺序不一致
- 可以遍历 键值
- 可以判断的是否存在某个键
- 可以删除某键


### 3.5 结构体

在第二章节中，我们提到过 结构体，是不同类型的字段的集合的复合类型，同时可以为结构体对象绑定方法；通过组合的方式，结构体字段可以继承，相应的方法也可以继承。

- 结构体是不同数据类型集合的复合字段
- 结构体可以绑定相应的方法
- 结构体的字段和方法的可访问与否是根据字段和方法的首字母的大小写，大写可访问，小写私有

```
package main

import "fmt"

type Info struct {
	Name string
	_    int //  _ 表示占位符
	Age  int
}

func main() {
	var infoOne Info = Info{
		Name: "XieWei",
		Age:  20,
	}

	var infoTwo = Info{"XieWei", 20000, 20}

	var infoThree = new(Info)

	infoThree = &Info{
		Name: "XieWei",
		Age:  20,
	}

	fmt.Println("One", infoOne)
	fmt.Println("Two", infoTwo)
	fmt.Println("Three", *infoThree)
}
>>
One {XieWei 0 20}
Two {XieWei 0 20}
Three {XieWei 0 20}
```

- 可以使用占位符 `_`
- 三种方式都可以声明和赋值操作。建议使用方法1(infoOne)， 即命名方式初始化操作，理由有：可以不考虑顺序且更容易理解


```
type Info struct {
	Name string
	Age  int
}
func main() {
	var infoOne Info = Info{
		Name: "XieWei",
		Age:  20,
	}
	// unsafe.Sizeof 获取占用的空间大小
	fmt.Println(unsafe.Sizeof(infoOne), fmt.Sprintf("%x - %d - %x - %d", &infoOne.Name, unsafe.Sizeof(infoOne.Name), &infoOne.Age, unsafe.Sizeof(infoOne.Age)))

}
>>
24 c00000a080 - 16 - c00000a090 - 8

```

- 结构体初始化操作，分配一段连续的内存地址，结构体占用空间大小等于各属性占用空间大小之和（24=16+8）。



#### 3.5.1 匿名字段

结构体中只有数据类型，没有变量名称的字段，称之为匿名字段。

```
type Student struct {
	Name string
	University
}

type University struct {
	Name     string
	Location string
}

func main(){
    
    var std Student
	std.Name = "XieWei"
	std.University.Name = "ShangHai"
	std.Location = "ShangHai"
	fmt.Println(std)
}

>>
{XieWei {ShangHai ShangHai}}
```

- 匿名字段 `University`
- 具有和主结构体相同的字段 `Name`，初始化赋值的时候，需要多层级`.`  的形式，比如 `std.University.Name = "ShangHai"`，其他可以直接类型赋值
- 同理，类型绑定了相同的方法名称也和字段操作一致

```
type Student struct {
	Name string
	University
}

func (s Student) PrintName() {
	fmt.Println(s.Name)
}

type University struct {
	Name     string
	Location string
}

func (u University) PrintName() {
	fmt.Println(u.Name)
}

func main(){
    
    var std Student
	std.Name = "XieWei"
	std.University.Name = "ShangHai"
	std.Location = "ShangHai"
	fmt.Println(std)

	std.PrintName()
	std.University.PrintName()
    
}
>>
XieWei
ShangHai
```

#### 3.5.2 总结结构体

- 结构体在 Go 中是不同数据类型的集合，包含两个方面：1、字段 2、方法
- 方法和函数的区别在于，方法绑定给了对象，即结构体类型，函数即是代码块的封装
- 结构体可以不同的组合，继承相应结构体的字段和方法
- 匿名字段的使用，可以自动拥有匿名字段的字段和方法，类似于组合
- 结构体实现相应的方法可以实现多个接口
- 结构体初始化分配一段连续的内存地址

### 3.6 接口


第二章已经讲过，接口是方法的集合（注意不是函数的集合），只定义动作，而不实现，既然是方法的集合，需要绑定给对象，所以接口的具体实现需要靠结构体来实现，而且不同的结构体可以实现不同的方法。


本节可以看看内置的接口都是如何操作的。

#### 3.6.1 error 接口

```
type error interface {
	Error() string
}
```

通常我们在项目内创建 error 值，有下面两种方式：

- errors.New
- fmt.Errorf

```
var ErrExampleNew = errors.New("hello world error")
var ErrExampleFmt = fmt.Errorf("hello world %s", "error")

func main(){

    fmt.Println(reflect.TypeOf(ErrExampleNew), reflect.TypeOf(ErrExampleFmt))

}
>>
*errors.errorString *errors.errorString
```

可以继续看看底层的实现：

- errors.New 的底层实现

```
func New(text string) error {
	return &errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}

```

- fmt.Errorf 的底层实现

```
func Errorf(format string, a ...interface{}) error {
	return errors.New(Sprintf(format, a...))
}
```

可以看出实际上是结构体 `errorString`  实现了 `Error` 方法，既而实现了 `error` 接口


通过对底层 error 值的创建的源码的阅读，教给我们一个启发，即我们如何优雅的实现自己的错误类型。这对大型项目而言非常重要，如果不合理的组织代码的错误处理，致使代码中充斥着各种类型的错误和错误语句，非常不利于错误的排除。正确的做法应该统一组织。

示例：

```

type ErrorMessage struct {
	Err     error
	Code    int
	Message string
}

func (e *ErrorMessage) Error() string {
	return fmt.Sprintf("e.err = %s, e.code = %d, e.message = %s", e.Err.Error(), e.Code, e.Message)
}

var (
	ErrNotRoute   = ErrorMessage{Err: errors.New("no route"), Code: 404, Message: "check route"}
	ErrParamNotOk = ErrorMessage{Err: errors.New("param not ok"), Code: 10000, Message: "check param"}
)

```

几点建议：

- 单独组织一个 package，用来定义错误类型和相应的错误处理
- 自定义的错误类型实现 Error 方法，既而实现 error 接口
- 每个错误类型尽量带上关键字： `Err` 或者 `Error`

#### 3.6.2  Marshaler

```
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```

序列化和反序列化在编程语言中是个非常重要的话题，在 Go 中，我们如何将结构体转换为 json 数据类型？

示例：

```
type University struct {
	Name      string  `json:"name"`
	Location  string  `json:"location"`
	Number    float64 `json:"student_number,string"`
	President string  `json:"-"`
}

func main() {

	var university University
	university = University{
		Name:      "ShangHaiUniversity",
		Location:  "ShangHai",
		Number:    2000000,
		President: "XXXXX",
	}

	universityByte, _ := json.Marshal(university)
	fmt.Println(string(universityByte))
}

>>
{"name":"ShangHaiUniversity","location":"ShangHai","student_number":"2000000"}

```

- 默认情况下使用 `json.Marshal` 将 Go 数据类型转换为 json 格式
- 具体的转换还可以根据 tag 标签进行定义，比如转换的字段`Name 转换为 name`，再比如转换的类型 `Number float64 转换为 string`，在比如忽略某字段 `President  -`

如何定义自己的序列化格式？

实现 MarshalJSON 方法，既而实现 Marshaler 接口

```
type University struct {
	Name      string  `json:"name"`
	Location  string  `json:"location"`
	Number    float64 `json:"student_number,string"`
	President string  `json:"-"`
}

func (u University) MarshalJSON() ([]byte, error) {

	result := fmt.Sprintf("name: %% %s, location: %% %s , 人数: %% %f", u.Name, u.Location, u.Number)
	return json.Marshal(result)
}

func main() {

	var university University
	university = University{
		Name:      "ShangHaiUniversity",
		Location:  "ShangHai",
		Number:    2000000,
		President: "XXXXX",
	}

	universityByte, _ := json.Marshal(university)
	fmt.Println(string(universityByte))
}
>>
"name: % ShangHaiUniversity, location: % ShangHai , 人数: % 2000000.000000"
```

- 此时，序列化成用户自定义的样子
- 本质上也是实现了 Marshaler 接口

### 3.7 包管理

在 Go 内，函数或者对象及其方法的调用，靠的是库的导入。本节讲述下，Go 内如何进行库的导入。

#### 3.7.1 库（包）的导入

- 默认导入方式: 全路径导入

```
package main

import "fmt"

func main() {
	fmt.Println("Hello World")
}

```

- 只导入不使用: 只导入的方式表示只调用和实现了导入库的初始化函数（init）

```
import _ "fmt"

```

- 重命名：给库重新给个名称

```
package main

import Print "fmt"

func main() {
	Print.Println("Hello World")
}

```

- 不显示库的名称，直接调用方法

```
package main

import . "fmt"

func main() {
	Println("Hello World")
}

```

- 多个库的导入方式，按 ascii 码顺序排列，且用 `()` 组织

```
import (
	"errors"
	"fmt"
	"log"
)
```

虽然官方支持多种导入方式，都可以生效。但是为便于理解，笔者建议还是使用默认的导入方式，即全路径的导入方式


#### 3.7.2 下载包

- 使用 go 命令方式

```
go get -u -v github.com/PuerkitoBio/goquery

```

说明：

```
- u 表示更新，比如远程代码更新，本地库还是旧版的
- v 表示显示下载库的文件详细信息

```

因为 Go 是谷歌出品的，有些库托管在谷歌服务器上，所以下载库有时候会连接不上，这个时候可以推荐下面这个工具。

```
go get -u github.com/gpmgo/gopm

```

之后使用下面这个命令， 即可下载库。

```
go get -g -v github.com/PuerkitoBio/goquery
```


### 3.8 项目组织结构

项目组织讲究的是将项目组织按照功能划分，将完成相似的功能的代码块组织在一起，这样的便于理解项目，同时利于项目的拓展和解耦。

本节结合实际在项目中的组织，给出参考项目组织方式，希望对读者有所启发。

#### 3.8.1 领域驱动的方式

领域驱动讲究的是将项目整体按照领域驱动的方式进行组织。领域驱动设计主要包括下面几个部分：

- application 应用层
- infrastructure 基础设施层
- domain 领域层
- uerInterface 用户界面层


**应用层：app**

主要完成的任务是为程序提供任务处理。即调用抽象之后的应用。

**基础设施层：infra**

主要是和业务不相关的代码块的集合，比如字符串操作，数值运算，文件操作等。

**领域层：domain**

领域层是领域驱动设计的核心，首先需要根据项目抽象出领域内的相关概念，再在领域内的概念基础上完成资源的操作。

**用户界面层：ui**

负责向用户展现信息，并且会解析用户行为，即常说的展现层。

以设计一个 restful api 风格的项目为例，领域驱动设计的项目组织结构大概如下。

```
workspace
    app
    domain
    infra
    main
    scheduler
          scheduler.go
    ui
       api-server
           api_server.go
           router_function.go
       parse
           parse

```

#### 3.8.2 业务驱动的方式

日常开发过程在编写 API 的业务需求应该会挺多，特别是你选择是 web 方面的工作。下面这种风格的项目组织适合绝大多数web 层面的项目开发。

- cmd 命令行功能集合
- configs 项目的配置文件集合
- deployments 构建docker 镜像等文件集合
- docs 文档文件集合
- initializers 初始化文件集合
- logs 存储项目日志文件集合
- pkg 项目辅助功能，比如中间件，插件等
- scripts 脚本文件集合
- src 项目的核心文件，主要是核心的处理环节
- tools 项目辅助工具
- vendor 第三方库文件集合
- main.go 项目函数入口
- Makefile 项目构建命令集合

希望对大家有所启发。




### 3.9 小结


本节是对前面章节的补充，主要讲述是在掌握最小的知识集，我们应该还注意些什么。主要的包括：

- 变量

包括何种方式的变量和命名方式是最佳，最易于人理解。

- 运算

包括算术运算和逻辑运算，补充了逻辑运算下，如何编写易于理解的if...else

- 数组和切片

包括数组和切片的常用的操作

- Map 

包括键值对类型的数据类型的变量的声明，键值的遍历和判断

- 结构体

包括结构体的声明方式，匿名字段以及方法，用组合的方式实现继承

- 接口

包括常见的内置的接口的实现方式，特别讲述了 错误类型的借鉴方式

- 包管理

包括包的导入的不同方式，推荐使用默认的导入方式；另一方面包括如何获取第三方库

- 项目组织

包括两种风格的项目的组织方式，便于理解项目和对项目的拓展和解耦


