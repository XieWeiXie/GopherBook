
日常工作中，绝大多数的工作都是在处理业务，面向业务开发，随着时间的推移，会越来越熟悉当前的工作，转而进入熟练阶段，也就是所谓的舒适区。技术的迭代非常快，程序员是最需要持续学习的岗位，开发者不断的精进自己的能力，一方面来自于不断的解决工作问题的积累，一方面需要靠开发者自身主动学习，才能不断的提高技术和竞争力。

本章围绕着开发者从开源领域和社区能学习到什么，以及如何学习进行浅析。主要分析的的是开源软件 ElasticSearch。


## 0.开源

那什么是开源？开源对开发者有哪些启示？

开源是一种开放源码的行为。随着 Git 分布式版本管理的成为事实上的版本管理的标准，以及相应的 Github 代码托管平台的流行，越来越多的开发者聚焦在开源领域和社区。针对普通的开发者，对那些非常火热的技术，比如 Docker, Kubernetes，etcd 等，都有机会参与贡献代码中去，也有机会阅读相应的源代码，感受到顶尖开发者编写代码的魅力和美感。

普通开发者也有能力将自己解决实际问题的代码开源出去，在开源社区内贡献自己小小的力量。

那么普通开发者如何在开源领域内学习相应的技术，以期提高自己呢？

笔者认为有以下几点值得注意：

- 以解决你自身的问题为主
- 甄别高质量的开源软件
- 模仿学习
- 持续迭代

**以解决自身问题为主：**

据 Github 2019 年度报告（ https://octoverse.github.com/ ）显示，Github 上有超过 4000 万的开发者，热门项目被数百万其他存储库使用，数以万计的顶级开源项目。开发者如果不聚焦在自身的领域、自身的问题，那么可能会陷入茫茫的开源软件内迷失了自己。比如如果你遇到的问题是搜索相关，那么你可能要关注的是 ElasticSearch 之类搜索相关的开源项目；如果你遇到的问题是容器集群化部署，那么你可能要关注的是 Kubernetes 之类容器编排部署相关的开源项目；如果你遇到的是消息队列相关的问题，那么你可能要关注的是 Kafka、RocketMQ 等消息队列相关的开源项目。

总之，你需要聚焦在自身领域，自身问题，才有能解决你的问题。

**甄别高质量的开源软件：**

只有高质量的开源软件，你才能学习，深入学习，明白其用法、设计理念，进而借鉴学习，应用到自身的项目中，提升系统稳定性、可靠性等。

开源软件众多，对同一种类型的问题解决也存在诸多的开源软件，如何甄别呢？

- 官方推出的开源软件
- 社区活跃的开源软件
- 大厂背书的开源软件

针对各种问题，不乏有热心的开发者会开发对应的软件解决问题，如果开发者水平高，那么你当然可以选择其开源项目，否则，笔者建议优先选择官方组织的开源项目，官方以为着及时的更新功能、修复问题，官方意味着稳定，意味着能吸引更多的开发者参与进来，这样的开源软件会逐渐趋于完善。这也是开源的魅力。

同样的，开发者热衷参与进官方的开源项目内，整个社区就会更加活跃，能解决的问题就更多，方案也就更多，你遇到问题，解决的可能性就更大，毕竟你不会是第一个遇到此类问题的人。

诸多的顶级开源项目，都是大型互联网公司参与开发或者直接开源的，比如容器编排 Kubernetes 的开源，在云计算领域大放异彩。比如编程语言 Go，本身就是大厂开源的，设计理念先进，性能优秀，迭代速度非常快，内置的库，常常是开发者深入学习编程的语言的首选。

**模仿学习和迭代学习**

顶级开源项目，对普通开发者来说，其实比较远，能比较熟练的使用，懂得部分原理就不错，这些顶级项目，普通开发者完全掌握，非常耗时和困难。所以还是聚焦在自身领域和问题点出发，也许开源项目的部分内容就解决了你的疑惑。

仅仅只是读懂或者会用远远不够，最好的实践是：模仿学习，看能不能开发一个项目，解决某类问题。如果能模仿着学习，真正的解决问题，对精进自身能力、提升竞争力非常有帮助。



## 1. 搜索引擎的基本使用


ElasticSearch （ https://www.elastic.co/ ）是一个基于 Lucene 的搜索服务器，提供了一个分布式多用户的能力的全文搜索引擎，基于 RESTful Web 接口，是一种流行的企业级搜索引擎。典型的 ElasticSearch 使用场景有：电商商品搜索、日志搜索等，各大互联网公司都选择其作为搜索引擎，比如 Github 中代码搜索，就是基于 ElasticSearch 实现的。

基本的 ElasticSearch 使用非常简便，下文描述 ElasticSearch (es) 的简单使用。


**下载安装：**

> 推荐读者拥抱容器思想，即优先使用服务的容器版本

elasticsearch (https://hub.docker.com/_/elasticsearch) 镜像地址，使用 docker-compose 启动服务。

> 本地需提前安装 docker, docker-compose

**docker-compose 配置文件：**

配置集群名称为: es_clusername, 节点名称分别为 es_01, es_02, es_03

```
version: '3'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.5.0
    container_name: es_01
    environment:
      - "cluster.name=es-clustername"
      - "bootstrap.memory_lock=true"
      - "node.name=es_01"
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - "discovery.seed_hosts=es_01,es_02,es_03"
      - "cluster.initial_master_nodes=es_01,es_02,es_03"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - esdata1:/usr/share/elasticsearch/data
    ports:
      - 9200:9200
    networks:
      - esnet
  elasticsearch2:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.5.0
    container_name: es_02
    environment:
      - "cluster.name=es-clustername"
      - "bootstrap.memory_lock=true"
      - "node.name=es_02"
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - "discovery.seed_hosts=es_01,es_02,es_03"
      - "cluster.initial_master_nodes=es_01,es_02,es_03"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - esdata2:/usr/share/elasticsearch/data
    networks:
      - esnet
  elasticsearch3:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.5.0
    container_name: es_03
    environment:
      - "cluster.name=es-clustername"
      - "bootstrap.memory_lock=true"
      - "node.name=es_03"
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - "discovery.seed_hosts=es_01,es_02,es_03"
      - "cluster.initial_master_nodes=es_01,es_02,es_03"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - esdata3:/usr/share/elasticsearch/data
    networks:
      - esnet
volumes:
  esdata1:
    driver: local
  esdata2:
    driver: local
  esdata3:
    driver: local

networks:
  esnet:
    driver: bridge
```

启动服务：`docker-compose -f docker-compose.yml up -d` 

这样就在本地启动一个 es 集群。

```
docker ps --format "{{.ID}}: {{.Names}} : {{.Ports}}"  | grep es

>>
f064b0cc429d: es_03 : 9200/tcp, 9300/tcp
a2743d6c7b99: es_02 : 9200/tcp, 9300/tcp
455eaf252d54: es_01 : 0.0.0.0:9200->9200/tcp, 9300/tcp
```

默认开放端口 9200。

**查看是否安装成功：**

```
curl http://127.0.0.1:9200

>>

{
  "name" : "es_01",
  "cluster_name" : "es-clustername",
  "cluster_uuid" : "SgkM5bSoR3iTZsc5bDp8ow",
  "version" : {
    "number" : "7.5.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "e9ccaed468e2fac2275a3761849cbee64b39519f",
    "build_date" : "2019-11-26T01:06:52.518245Z",
    "build_snapshot" : false,
    "lucene_version" : "8.3.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```

可以查看到当前 es 的版本以及集群信息等。


如果你需要可视化，社区也提供了诸多的相应的插件，和监控系统。可以看出，整体的安装非常的简便，对外暴露出各种 API。开发者可以根据自己的需求，使用相应的 API。比如查看集群的信息 （cluster API）, 比如查看节点的信息 （node API)，比如操作索引的信息 （index API), 比如完成搜索信息 （search API）等。es 的基本使用主要围绕着这套 API 进行，为完成核心的功能：搜索，软件提供了极其丰富的 RESTful API。

## 2. 客户端 go-elasticserch 的使用

上文提到 ElasticSearch 提供了非常多的 RESTful API 操作搜索引擎，那么客户端需要做的事主要是：封装 RESTful API。面多数以百计的 RESTful API 接口，你难道不好奇，官方是如何组织，设计客户端的吗？作为普通开发者能从中学习到什么设计模式吗？比如如何组织项目，比如如何划分工作，比如如何应对版本升级带来的不确定性。

带着这个问题，我们想从中学习到：**如何开发优雅的客户端工具，如何优雅的封装 RESTful API**。

想了解其设计思想，首先要学习其基本操作，如何学习其最基本的操作，最好的方式，当然是从其官方文档中进行学习。

go-elasticsearch: https://github.com/elastic/go-elasticsearch

**下载安装**

为避免不必要的冲突问题，我们最好选择和服务想对应的客户端版本。

```
curl http://127.0.0.1:9200

>>

{
  "name" : "es_01",
  "cluster_name" : "es-clustername",
  "cluster_uuid" : "SgkM5bSoR3iTZsc5bDp8ow",
  "version" : {
    "number" : "7.5.0",
    ...
  },
  "tagline" : "You Know, for Search"
}
```

es 版本是 7.5.0，那么下载符合版本的客户端。

```
go get github.com/elastic/go-elasticsearch/v7
```

**基本使用**

官方提供了两者方式操作其 RESTful ，进而完成操作 es 的目的。

简便起见，我们只操作这个 `cat API` 中的 `health` 即：集群健康检查接口。

```
curl http://127.0.0.1:9200/_cat/health

>>
1576828943 08:02:23 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%
```

`green` 表示集群健康，没有什么问题。

转化成 go 代码的示例如下：

```
package main

import (
	"context"
	"fmt"
	"github.com/elastic/go-elasticsearch/v7"
	"github.com/elastic/go-elasticsearch/v7/esapi"
)

type EsQueryByClientAction struct {
	client *elasticsearch.Client
}

type EsQueryByRequestAction struct {
	cat esapi.CatHealthRequest
}

var DefaultClient *elasticsearch.Client

func init() {
	DefaultClient, _ = elasticsearch.NewDefaultClient()
}

// 使用 client 调用 cat health 的形式
func Example1() {
	var es EsQueryByClientAction
	es.client, _ = elasticsearch.NewDefaultClient()
	res, _ := es.client.Cat.Health(es.client.Cat.Health.WithHuman())
	fmt.Println(res.String())
	// [200 OK] 1576825983 07:13:03 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%
}

// 使用 catHealthRequest 的形式
func Example2() {
	var esRequest EsQueryByRequestAction
	esRequest.cat = esapi.CatHealthRequest{}
	res, _ := esRequest.cat.Do(context.TODO(), DefaultClient)
	fmt.Println(res.String())
	// [200 OK] 1576825983 07:13:03 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%

}
func main() {
	Example1()
	Example2()
}

>>
[200 OK] 1576825983 07:13:03 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%

[200 OK] 1576825984 07:13:04 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%

```

可以看出提供了两种方式获取到数据: `Example1` 是先构造 `client` , 再调用 `client` 的方法进行操作。`Example2` 是直接构造 `CatHealthRequest` ，再直接调用 `CatHealthRequest` 的 `Do` 方法。


想要了解为什么这么使用都可以得出结果，必须从其官方开源代码中阅读，寻找答案。

## 3. 项目组织形式


使用 git 获取源代码，进行研究。
```
git clone git@github.com:elastic/go-elasticsearch.git
```

项目组织的形式，笔者认为这两点非常重要：清晰、可扩展。回顾下，我们之前说过 ElasticSearch 的使用主要围绕的是 RESTful API 的形式，进而操作 ElasticSearch , 官方提供了数以百计的 RESTful API 那么如何对这些 RESTful API 分门别类的进行组织呢？

官方开源代码将整个项目组织主要划分为三层：

- esapi  所有 API 集合层
- estransport 真实的发起 HTTP 请求层
- elasticsearch.go 上游稳定暴露 API 层

```
// 查看目录结构
>> tree -L 1 go-elasticsearch

├── esapi
├── estransport
├── esutil
├── elasticsearch.go
└── internal
...

```

相似的内容，官方保持了极其统一的风格，举个例子，查看下 esapi 层。

```
├── api._.go
├── api.bulk.go
├── api.cat.aliases.go
├── api.cat.health.go
...
├── api.clear_scroll.go
├── api.cluster.allocation_explain.go
├── api.cluster.get_settings.go
...
├── api.index.go
├── api.indices.analyze.go
├── api.indices.clear_cache.go
├── api.indices.clone.go
├── api.indices.close.go
...
```

具体查看具体的某个 API 内容： `cat api.cat.health.go`

```
func newCatHealthFunc(t Transport) CatHealth

type CatHealth func(o ...func(*CatHealthRequest)) (*Response, error)

type CatHealthRequest struct
func (r CatHealthRequest) Do(ctx context.Context, transport Transport) (*Response, error) 

func (f CatHealth) WithFormat(v string) func(*CatHealthRequest) 
func (f CatHealth) WithH(v ...string) func(*CatHealthRequest)
...

```

其中 CatHealth 是个函数类型，接收不定参数 func(*CatHealthRequest)，其中 CatHealthRequest 是个结构体，定义了 Do 方法。Example2 示例中的代码就是运行的这个结构体的方法。

查看其他的 API，不管是从函数、结构体命名、文件组织、入参等都保持了高度的统一风格。事实上你看懂了其中一个文件，其他文件如出一辙，保持风格统一的另一个好处是：对开发者而言，能够快速的定位问题所在，思维也没有过多负担。

风格统一是官方源代码的优点之一。

## 4. 面向接口编程

Go 中实现面向对象的思想，主要靠的是结构体来实现。面向对象包含三大特性：封装、继承、多态。不过 Go 中没有“继承”的概念，转而推荐使用组合的形式，实现继承的特性。面向对象中的大量使用继承会出现层级过深的问题，而组合的形式能够很好的避免，这也是 Go 中极力推崇的面向对象思维。编程中提升代码质量，提升代码通用性的一个主要的设计原则是面向接口（interface）编程。

那么什么是接口？简单的说是一堆方法的集合，描述的是接口具备的能力，而不管其如何实现，具体的实现，依靠的是相应自定义的结构体实现其描述的方法即可，是一种比较抽象的描述。

看上去比较晦涩，使用编程语言实现下，示例如下：

```
package main

import (
	"fmt"
	"log"
)

// 定义接口：关键字 interface，是方法的集合
type Gopher interface {
	Go(string) string
}

// 定义具体用于实现的结构体
type JobGo struct {
}

// 结构体绑定 Go 方法：参数和返回值和接口中定义的完全一致
func (J JobGo) Go(v string) string {
	return fmt.Sprintf("实现了 Gopher Interface")
}

func ExampleWithGopher(v Gopher, value string) {
	log.Println(v.Go(value))
}


// 定义接口：是方法的集合
type Pythoneer interface {
	Python(string) string
}

// 定义具体用于实现接口的结构体
type JobPython struct {
}

// 结构体绑定 Pyhton 方法：参数，返回值和接口中定义的完全一致
func (J JobPython) Python(v string) string {
	return fmt.Sprintf("实现了 Pythoneer Interface")
}

func ExampleWithPythoneer(v Pythoneer, value string) {
	log.Println(v.Python(value))
}

func main() {
	var g JobGo
	ExampleWithGopher(g, "JobGo")

	var p JobPython
	ExampleWithPythoneer(p, "JobPython")


}

>>
2019/12/20 18:38:40 实现了 Gopher Interface
2019/12/20 18:38:40 实现了 Pythoneer Interface

```


接口：是一堆协议的，即方法的集合，描述的是这个接口具备什么样的能力。而具体的实现由对应的结构体来实现，只需要结构体绑定的方法的参数和返回值和接口中定义的完全一致，事实上同一个结构体可以实现多个接口。

```
package main

import (
	"fmt"
	"log"
)

type Gopher interface {
	Go(string) string
}
type Pythoneer interface {
	Python(string) string
}

type JobGo struct {
}

func (J JobGo) Go(v string) string {
	return fmt.Sprintf("实现了 Gopher Interface")
}

func (J JobGo) Python(v string) string {
	return fmt.Sprintf("同样实现了 Pythoneer Interface")
}

func ExampleWithGopher(v Gopher, value string) {
	log.Println(v.Go(value))
}

func ExampleWithPythoneer(v Pythoneer, value string) {
	log.Println(v.Python(value))
}


func main() {
	var g JobGo
	ExampleWithGopher(g, "JobGo")
	ExampleWithPythoneer(g, "JobGo")

}
>>
2019/12/20 18:45:43 实现了 Gopher Interface
2019/12/20 18:45:43 同样实现了 Pythoneer Interface

```

那么什么是组合？简单的说，将对应的接口或者结构体作为另一个接口或者结构体的属性。描述有点晦涩，看示例：

```
package main

import (
	"fmt"
	"log"
)

type Gopher interface {
	Go(string) string
}
type Pythoneer interface {
	Python(string) string
}

type JobGo struct {
}

func (J JobGo) Go(v string) string {
	return fmt.Sprintf("实现了 Gopher Interface")
}

func (J JobGo) Python(v string) string {
	return fmt.Sprintf("同样实现了 Pythoneer Interface")
}

type JobPython struct {
}

func (J JobPython) Python(v string) string {
	return fmt.Sprintf("实现了 Pythoneer Interface")
}

type AwesomeDeveloper struct {
	JobGo
	JobPython
}

func (A AwesomeDeveloper) Go(v string) string {
	return fmt.Sprintf("实现了面向对象的多态特性")
}
func (A AwesomeDeveloper) Python(v string) string {
	return fmt.Sprintf("实现了面向对象的多态特性")
}

func ExampleWithGopher(v Gopher, value string) {
	log.Println(v.Go(value))
}

func ExampleWithPythoneer(v Pythoneer, value string) {
	log.Println(v.Python(value))
}

func main() {
	var awesome AwesomeDeveloper
	ExampleWithGopher(awesome, "AwesomeDeveloper")
	ExampleWithPythoneer(awesome, "AwesomeDeveloper")
}
>>
2019/12/20 18:51:06 实现了面向对象的多态特性
2019/12/20 18:51:06 实现了面向对象的多态特性
```

JobGo 和 JobPython 两个结构体作为 AwesomeDeveloper 结构体的匿名成员，自动具备 Go 和 Python 方法，同时 AwesomeDeveloper 自己具备了 Go 和 Python 方法，那么“继承”的方法就被覆盖。这也是为什么结果输出为 AwesomeDeveloper 本身方法的输出结果。


为什么描述这些？面向接口编程有什么好处？

越抽象的设计，使用面向接口的编程思想越能提高代码的灵活性，应对多变的需求，抽象是提高代码扩展性、可维护的重要手段。

一部分读者有可能会有疑问：是先写 Interface 描述能力，还是写具体的结构体，再抽取出 Interface 的方法？

当然先描述 Interface 的方法，再使用具体的结构体去实现。Interface 本身是用来抽象组织代码的，而不是从具体的代码中抽取出来再描述，后者本末倒置。

又有部分读者会有疑问：是否需要为每个具体实现的结构体定义相应的 Interface ?

还是回到 Interface 本身的能力上来，Interface 是用来抽象描述能力，如果实现的结构体不会经常变动，而且只有一只实现方式，那么老老实实使用具体的结构体实现即可，如果有多种可能实现方式，那么优先定义 Interface， 举个例子，你来编写一个抓取多个平台数据的软件，比如网站甲，网站乙等，多个网站数据的具体解析获取数据方法不一样，但能力几乎一致：比如 获取网页源代码、解析数据、清洗、持久化存储。像这类问题，那么当然优先定义 Interface 描述其能力。

```
type Parser interface {
	Fetch(url string) *http.Response
	Clean(response *http.Response) *http.Response
	IntoDB(client interface{}) bool
}
```

读者需要具体问题具体分析，而不是一股脑的搬弄设计原则。

go-elasticsearch 官方开源库，多处使用了组合和面试接口的编程思想，正是这种设计原则的实践，使其能够应对繁复的 RESTful API。我们可以从源码层面，带大家一览其使用面向接口和组合的思想。



**esapi 层**

esapi 层完成的核心工作是对接口的操作，代码组织、命名、高度统一。项目组织：

```
>> tree -L 1 esapi

esapi
├── api._.go
├── api.bulk.go
├── api.cat.aliases.go
├── api.cat.allocation.go
├── api.cat.count.go
├── api.cat.fielddata.go
├── api.cat.health.go
...
├── doc.go
├── esapi.go
├── esapi.request.go
├── esapi.response.go
...
```

代码组织：

```
>> cat api.cat.health.go

func newCatHealthFunc(t Transport) CatHealth{}
type CatHealth func(o ...func(*CatHealthRequest)) (*Response, error)

type CatHealthRequest struct{}
func (r CatHealthRequest) Do(ctx context.Context, transport Transport) (*Response, error) 

func (f CatHealth) WithContext(v context.Context) func(*CatHealthRequest)
func (f CatHealth) WithFormat(v string) func(*CatHealthRequest)
func (f CatHealth) WithH(v ...string) func(*CatHealthRequest)
...

```

读者多查看几个文件，可以发现，其关于 API 代码组织和命名，完全保持一致的风格。给读者的启发是：编写代码中相似的功能，需要具备相似的代码组织，再编程领域内，称之为风格统一。


继续深入研究，发现这些内容其实都是面向接口编程，组织 Request 和 Response，Elasticsearch 对外暴露的是 RESTful 风格的 API，访问 API ，无外乎会涉及到这些内容：

- 如何处理 URL，即网络请求，包括请求参数，路径参数等的处理
- 如何处理响应信息，包括获取到的数据的展示、状态码等的处理
- 如何处理异常信息，包括异常数据的展示等


这些 API 都存在一个 Do 方法，接受两个参数：`context.Context 和 Transport`。

```
>> cat esapi.request.go

type Request interface {
	Do(ctx context.Context, transport Transport) (*Response, error)
}

>> cat esapi.go

type Transport interface {
	Perform(*http.Request) (*http.Response, error)
}
```

其中 Request 描述了其存在 Do 方法，可以获取到 API 请求的响应信息，Transport 则描述了真实的网络请求的动作。事实上，将 Transport Interface 作为方法的参数，只使用了其能发起网络请求的能力。

```
func (r CatHealthRequest) Do(ctx context.Context, transport Transport) (*Response, error) {
	var (
		method string
		path   strings.Builder
		params map[string]string
	)

	method = "GET"

	path.Grow(len("/_cat/health"))
	path.WriteString("/_cat/health")

	params = make(map[string]string)

	if r.Format != "" {
		params["format"] = r.Format
	}

	if len(r.H) > 0 {
		params["h"] = strings.Join(r.H, ",")
	}

	if r.Help != nil {
		params["help"] = strconv.FormatBool(*r.Help)
	}

	if len(r.S) > 0 {
		params["s"] = strings.Join(r.S, ",")
	}

	if r.Time != "" {
		params["time"] = r.Time
	}

	if r.Ts != nil {
		params["ts"] = strconv.FormatBool(*r.Ts)
	}

	if r.V != nil {
		params["v"] = strconv.FormatBool(*r.V)
	}

	if r.Pretty {
		params["pretty"] = "true"
	}

	if r.Human {
		params["human"] = "true"
	}

    ...

	req, err := newRequest(method, path.String(), nil)
	if err != nil {
		return nil, err
	}

    ...

	res, err := transport.Perform(req)
	if err != nil {
		return nil, err
	}

	response := Response{
		StatusCode: res.StatusCode,
		Body:       res.Body,
		Header:     res.Header,
	}

	return &response, nil
}
```

这个 CatHealthRequest 的 Do 方法，参数和响应和 Request Interface 一致，说明 CatHealthRequest 实现了 Request Interface 方法。事实上 CatHealthRequest 也只是借用了 Transport 能够发起网络请求获取响应的能力（Perform 方法），其他的工作都是在组织 URL，或者请求参数。此处为面向接口编程思想之一。


![esapi.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6ofjcvz3j20qd0glab4.jpg)


最后将所有的实现了 Request Interface 的结构体进行组合。


```
>> cat api._.go

type API struct {
	Cat        *Cat
	Cluster    *Cluster
	Indices    *Indices
	Ingest     *Ingest
	Nodes      *Nodes
	Remote     *Remote
    ...
}

func New(t Transport) *API {
	return &API{
        ...
		Cat: &Cat{
			Aliases:      newCatAliasesFunc(t),
			Allocation:   newCatAllocationFunc(t),
			Count:        newCatCountFunc(t),
			Fielddata:    newCatFielddataFunc(t),
			Health:       newCatHealthFunc(t),
			Help:         newCatHelpFunc(t)
			...
			}
		}	

```

将所有结构体进行了组合 API 对象具备了所有实现 Request Interface 的结构体的方法和公开属性。

![esapi-api.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6okondgtj20p90iit9w.jpg)


esapi 层：主要完成对API 的操作，包括请求参数的组织，请求方法的设置，使用了 Transport 的发起网络请求获取响应的能力。最后使用**组合**的思想，把所有 RESTful 接口组合起来。


**estransport 层**

estransport 层主要用来：发起网络请求的真实实现。即实现 Transport Interface。当然还包括一些重试、日志、客户端设置等操作。为什么分层？面向接口编程思想，具备可扩展性、可维护性，这样能够逻辑清晰、分明的划分项目组织，方便后续的迭代。Elasticsearch 是在不断的迭代升级的，相应的 go-elasticsearch 客户端也需要不断的迭代升级，所以不能简单的考虑只是实现而已。

```
>> cat estransport.go

type Interface interface {
	Perform(*http.Request) (*http.Response, error)
}

type Client struct {
	sync.Mutex

	urls     []*url.URL
	username string
	password string
	apikey   string

    ...

	transport http.RoundTripper
	logger    Logger
    ...
}

func (c *Client) Perform(req *http.Request) (*http.Response, error) {
	var (
		res *http.Response
		err error
	)

    ...

	for i := 1; i <= c.maxRetries; i++ {
		var (
			conn        *Connection
			shouldRetry bool
		)

		// Get connection from the pool
		c.Lock()
		conn, err = c.pool.Next()
		c.Unlock()
		if err != nil {
			if c.logger != nil {
				c.logRoundTrip(req, nil, err, time.Time{}, time.Duration(0))
			}
			return nil, fmt.Errorf("cannot get connection: %s", err)
		}

		// Update request
		c.setReqURL(conn.URL, req)
		c.setReqAuth(conn.URL, req)

		if !c.disableRetry && i > 1 && req.Body != nil && req.Body != http.NoBody {
			body, err := req.GetBody()
			if err != nil {
				return nil, fmt.Errorf("cannot get request body: %s", err)
			}
			req.Body = body
		}

		// Set up time measures and execute the request
		start := time.Now().UTC()
		res, err = c.transport.RoundTrip(req)
        ...
	return res, err
}
```

查看源码可以发现，真实的发起网络请求的实现部分是： `c.transport.RoundTrip(req)`



![estransport.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6p4m9pzhj20q60gpdgp.jpg)


**elasticsearch 层**

这一层完成的是对外的最终暴露的方式。使用到了组合的编程思想。

```
>> cat elasticsearch.go

type Client struct {
	*esapi.API // Embeds the API methods
	Transport  estransport.Interface
}

func (c *Client) Perform(req *http.Request) (*http.Response, error) {
	return c.Transport.Perform(req)
}

```

![elasticsearch-client.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6p875iawj20oi0fnmy6.jpg)

可以看到使用组合的思想，把 API 和 Transport 两者结合起来。再回过头来看看，我们给出的 go-elasticsearch 示例：

```
// 使用 client 调用 cat health 的形式
func Example1() {
	var es EsQueryByClientAction
	es.client, _ = elasticsearch.NewDefaultClient()
	res, _ := es.client.Cat.Health(es.client.Cat.Health.WithHuman())
	fmt.Println(res.String())
	// [200 OK] 1576825983 07:13:03 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%
}

// 使用 catHealthRequest 的形式
func Example2() {
	var esRequest EsQueryByRequestAction
	esRequest.cat = esapi.CatHealthRequest{}
	res, _ := esRequest.cat.Do(context.TODO(), DefaultClient)
	fmt.Println(res.String())
	// [200 OK] 1576825983 07:13:03 es-clustername green 3 3 24 11 0 0 0 0 - 100.0%

}
```

Example1 直接使用  elasticsearch 中 client 调用其函数的形式。

Example2 直接使用 Request 的 Do 的方法。


读者可以仔细阅读下官方源代码，体会这种分层、面向接口、组合的编程思想，将复杂的问题简化，且具有较好的扩展性。这种面向接口、组合的编程思想，使得上游代码非常稳定，几乎都不需要改动。如果 elasticsearch RESTful API 变动，改动 esapi 层即可。


## 5. 自己实现，学为己用

学习了面向接口编程、组合的思想，那么如何将所学更深入理解呢？最好的方式是自己动手实现，将整体思想应用到自己的项目中。

初学者最好的学习方式是模仿，那么如何模仿呢？

- 分析需求
- 将项目分层
- 面向接口、组合编程


**需求分析**

这边准备实现一个 搜索（search）库，搜索的对象是：微博、知乎，对其搜索结果进行聚合。

微博搜索：获取找人、文章、视频、图片、话题

![Weibo.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6qa9sg2vj213x0m1di0.jpg)

知乎搜索：获取话题

![zhihu.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6qajidxxj213y0m3ter.jpg)


明确了目标，那么我们应该分析发起的真实请求和响应，是什么结构的，这一步其实利用的就是爬虫的思想，对网页进行分析，分析出网络请求、响应等。


本环节以**微博找人**为例，分析需求：

![weibo-yangmi.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6qlpkgk5j213y0m6dm4.jpg)


网络请求：

```
https://s.weibo.com/user?q=%E6%9D%A8%E5%B9%82&Refer=index

请求参数： q=杨幂
请求参数：Refer=index
```

响应信息：

```
<div class="info">
        <div>
            <a href="//weibo.com/yangmiblog" class="name" target="_blank" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_name"><em class="s-color-red">杨幂</em></a>
            <a href="//verified.weibo.com/verify" target="_blank" title="微博个人认证"><i class="icon-vip icon-vip-g"></i></a>
                        <a href="javascript:void(0);" class="s-btn-c" uid="1195242865" action-type="login" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_attend"><i class="wbicon s-color-a">+</i>关注</a>
                    </div>
        <p>
                        <i class="icon-sex icon-sex-female"></i>
                        北京
            <a href="//weibo.com/yangmiblog" target="_blank" class="wb_url" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_profile">个人主页</a>
        </p>
        <p>演员，代表作《宫》《仙剑奇侠传三》《我是证人》等</p>        <p>
            <span>关注<a href="//weibo.com/1195242865/follow" target="_blank" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_friends">614</a></span>
            <span>粉丝<a href="//weibo.com/1195242865/fans" target="_blank" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_fans">1亿</a></span>
            <span class="s-nobr">微博<a href="//weibo.com/1195242865/profile" target="_blank" suda-data="key=tblog_search_weibo&amp;value=seqid:157708977416592071669|type:3|t:0|pos:1-0|q:%E6%9D%A8%E5%B9%82|ext:mpos:1,click:user_wbcount">4041</a></span>
        </p>
        <p>简介：这里有一只狐狸，幸福，感恩，知足，爱~＞＜</p>
        <p>标签：<a href="/user?tag=%E5%8C%97%E4%BA%AC%E4%BA%BA&amp;Refer=Suser_tag">北京人</a><a href="/user?tag=B%E5%9E%8B%E8%A1%80&amp;Refer=Suser_tag">B型血</a><a href="/user?tag=%E5%A4%84%E5%A5%B3%E5%BA%A7&amp;Refer=Suser_tag">处女座</a><a href="/user?tag=%E7%B4%AB%E6%9B%A6&amp;Refer=Suser_tag">紫曦</a><a href="/user?tag=%E4%B8%80%E5%8F%AA%E7%8B%90%E7%8B%B8&amp;Refer=Suser_tag">一只狐狸</a><a href="/user?tag=80%E5%90%8E&amp;Refer=Suser_tag">80后</a><a href="/user?tag=%E5%B9%B3%E5%87%A1%E5%B0%8F%E6%BC%94%E5%91%98&amp;Refer=Suser_tag">平凡小演员</a></p>
        
        <p>职业信息：<a href="/user?work=%E5%98%89%E8%A1%8C%E4%BC%A0%E5%AA%92+%E6%9D%A8%E5%B9%82%E5%B7%A5%E4%BD%9C%E5%AE%A4&amp;Refer=Suser_work">嘉行传媒 杨幂工作室</a></p>
    </div>
```

响应信息在 `<div class="info"></div>` 标签内。根据自身需求选择需要获取响应哪些信息，比如地点、认证信息、关注、粉丝、微博、 简介、标签、职业信息等。这些信息，不是所有字段都存在，某些用户会缺省某些值，读者需要多分析几个请求，查看下，哪些可能会缺省。代码中需要做兼容处理。


**项目组织**

借鉴 go-elasticsearch 的项目组织思想，将项目划分为三个层级:

- seapi 层: 完成的是对各搜索结果的组织
- setransport 层: 完成的是对真实的发起网络请求获取响应层
- search 层：上游层，完成对外开放接口层


同样借鉴 go-elasticsearch 的项目命名方式，将 seapi 层的代码组织成统一的风格：

```
>> tree -L 1 esapi
├── api._..go
├── api.interface.go
├── api.response.go
├── api.string.go
├── api.url.go
├── api.wechat.account.go
├── api.wechat.article.go
├── api.wechat.go
├── api.weibo.go
├── api.weibo.passage.go
├── api.weibo.passage_test.go
├── api.weibo.picture.go
├── api.weibo.picture_test.go
├── api.weibo.synthetically.go
├── api.weibo.topic.go
├── api.weibo.topic_test.go
├── api.weibo.user.go
├── api.weibo.user_test.go
├── api.weibo.video.go
├── api.weibo.video_test.go
├── api.zhihu.go
├── api.zhihu.topic.go
├── api.zhihu.topic_test.go
└── doc.go

```

**代码开发**

> seapi 层

1. 定义接口

```
// api.interface.go

type SearchApi interface {
	Do(ctx context.Context, transport Transport) (*Response, error)
}

type Transport interface {
	Perform(*http.Request) (*http.Response, error)
}
```

2. 开发具体的模块，以**微博找人**为例

```
// api.weibo.user.go

// api 组合会使用到初始化动作
func newWeiBoUser(t Transport) WeiBoUser {
	return func(name string, o ...func(*WeiBoUserRequest)) (response *Response, err error) {
		var r = &WeiBoUserRequest{
			Query: name,
			host:  defaultWBHost,
		}
		for _, f := range o {
			f(r)
		}
		return r.Do(context.TODO(), t)
	}
}


type WeiBoUser func(query string, o ...func(*WeiBoUserRequest)) (*Response, error)

type WeiBoUserRequest struct {
	Query  string
	host   string
	format string
}

func (W *WeiBoUserRequest) Do(ctx context.Context, transport Transport) (*Response, error) {
	var (
		method string
		path   strings.Builder
	)
	method = http.MethodGet
	path.WriteString("user")

	W.formatUrl(path.String())
	log.Println("user url", W.format)
	u, e := url.Parse(W.format)
	if e != nil {
		log.Println(e)
		return nil, e
	}
	// 设置请求参数
	query := u.Query()
	query.Set(defaultQueryKey, W.Query)
	query.Set(defaultReferKey, defaultReferUser)
	u.RawQuery = query.Encode()
	req, e := http.NewRequest(method, u.String(), nil)
	if e != nil {
		log.Println(e)
		return nil, e
	}
	// 定义请求头部信息
	req.Host = defaultWeiBoHost
	req.Header.Add("User-Agent", defaultWeiBoUserAgent)
	
	// 调用接口的能力
	response, e := transport.Perform(req)
	if e != nil {
		log.Println(e)
		return nil, e
	}
	results := W.parse(response)
	if len(results) == 0 {
		log.Println("No Result")
		return nil, errors.New("no result")
	}
	// 重新组织响应
	newResponse := newResponse(results, response)
	return newResponse, nil

}
```

其中 Do 方法主要完成：组织 URL， 方便构造 http.Request，比如请求参数的组织，比如头部信息的定义等。

当然，其中使用到了一些辅助方法，比如 W.format, W.parse。这些方法不可导出，只可再内部使用。

```

// 组织 url 
func (W *WeiBoUserRequest) formatUrl(path string) {
	W.host = defaultWBHost
	W.format = fmt.Sprintf("%s/%s", W.host, path)
}

// 对 `<div class="info"></div>` 数据进行处理
// 主要使用 css 选择器对标签进行处理，获取到数据
func (W *WeiBoUserRequest) parse(response *http.Response) []WeiBoUserResponse {
	doc, e := goquery.NewDocumentFromReader(response.Body)
	if e != nil {
		log.Println("goquery new document fail", e.Error())
		return nil
	}
	var results []WeiBoUserResponse
	doc.Find(".info").Each(func(i int, selection *goquery.Selection) {
		var result WeiBoUserResponse
		href, _ := selection.Find("div").First().Find("a").First().Attr("href")
		result.Blog = fmt.Sprintf("https:%s", strings.TrimSpace(href))
		result.Name = strings.TrimSpace(selection.Find("div").First().Find("a").First().Text())
		local := strings.TrimSpace(selection.Find("p").Eq(0).Text())
		replacer := strings.NewReplacer("\n", "", "个人主页", "", " ", "")
		result.Local = replacer.Replace(local)
		result.Description = strings.TrimSpace(selection.Find("p:contains(简介)").Text())
		if selection.Find("p").Find("span").Size() == 3 {
			numbers := selection.Find("p")
			result.Following = numbers.Find("span").Eq(0).Text()
			result.Follower = numbers.Find("span").Eq(1).Text()
			result.PublishNumber = numbers.Find("span").Eq(2).Text()

		}
		if selection.Find("p").Eq(1).Find("span").Size() == 0 {
			result.Content = strings.TrimSpace(selection.Find("p").Eq(1).Text())
		}
		tags := selection.Find("p:contains(标签)")
		tags.Find("a").Each(func(i int, selection *goquery.Selection) {
			result.Tags = append(result.Tags, strings.TrimSpace(selection.Text()))
		})
		result.Jobs = selection.Find("p:contains(职业信息)").Find("a").Text()
		//log.Println(fmt.Sprintf("%#v", result))
		results = append(results, result)
	})
	return results
}

type WeiBoUserResponse struct {
	Blog          string
	Name          string
	Local         string
	Description   string
	Content       string
	Follower      string   // 粉丝
	Following     string   // 关注
	PublishNumber string   // 微博数目
	Tags          []string // 标签
	Jobs          string   // 职业信息
}

type WeiBoUserResponses []WeiBoUserResponse

```

其他模块几乎参照同样的思路，同样的命名规则，同样的代码组织进行操作。


> setransport 层

seapi 层只是调用了 Transport 的 Perform 能力，并没有真实的完成网络请求动作。setransport 层就是用来实现 Transport Interface 。

```
// setransport/transport.go

type CacheTransport struct {
	mux  sync.Mutex
	Data map[string]io.ReadCloser
	Ori  http.RoundTripper
}

func newCacheTransport() *CacheTransport {
	return &CacheTransport{
		Data: make(map[string]io.ReadCloser),
		Ori:  http.DefaultTransport,
	}
}

func (C *CacheTransport) set(r *http.Request, res *http.Response) {
	// 获取网络请求数据
	// key: 代表 url
	// val: 代表 网络请求响应
	C.mux.Lock()
	defer C.mux.Unlock()
	body := ioutil.NopCloser(res.Body)
	C.Data[r.URL.String()] = body
}
func (C *CacheTransport) get(r *http.Request) (io.ReadCloser, error) {
	// 获取网络请求数据
	C.mux.Lock()
	defer C.mux.Unlock()
	if val, ok := C.Data[r.URL.String()]; ok {
		return val, nil
	}
	return nil, errors.New("key not found")
}

func (C *CacheTransport) RoundTrip(r *http.Request) (*http.Response, error) {
	if val, err := C.get(r); err == nil {
		return &http.Response{
			StatusCode: http.StatusOK,
			Header:     r.Header,
			Body:       val,
			Request:    r,
		}, nil
	}

	resp, err := C.Ori.RoundTrip(r)
	if err != nil {
		return nil, err
	}
	C.set(r, resp)
	return resp, nil
}
```

实现了一个带缓存的真实的发起 HTTP 请求的模块，主要使用到的是：`http.RoundTripper`, 主要思路是：想获取缓存，如果存在，直接返回，否则，发起网络请求。


```
// setransport/connect.go
type Client struct {
	Query     string `json:"query"`
	transport *CacheTransport
}

func NewClient(query string) *Client {
	return &Client{
		Query:     query,
		transport: newCacheTransport(),
	}
}

func (C *Client) newRequest() *http.Request {
	return nil
}

func (C *Client) Perform(r *http.Request) (*http.Response, error) {
	// 真实的数据处理，实现了 Transport 接口
	// 更底层的网络请求由 transport 来实现，先读取缓存，否则发起请求
	return C.transport.RoundTrip(r)
}

```

定义客户端，将带缓存的 CacheTransport 作为 Client 的属性，主要使用到的组合的实现，其次 Client 具有 Perform 方法，实现了（seapi 层） Transport 接口。


> search 层

对外暴露稳定的上游层，主要组合 seapi 层的 API 和 seapi 层 Transport 接口。

```
// search.go

type ClientConfig struct {
	Query string `json:"query"`
}

func NewClientConfig(query string) *ClientConfig {
	return &ClientConfig{
		Query: query,
	}
}

// 组合
type Client struct {
	*seapi.API
	Transport seapi.Transport
}

func NewClient(cfg ClientConfig) *Client {

    // 实例化 Client 的 Transport 时，调用了 setransport 的 NewClient
	transport := setransport.NewClient(cfg.Query)
	return &Client{
		Transport: transport,
		API:       seapi.New(transport),
	}
}
func (C Client) Perform(request *http.Request) (*http.Response, error) {
	return C.Transport.Perform(request)
}

```


**测试验证**

```
// example/main.go

func Demo3WeiBoUser(query string) {
	req := seapi.WeiBoUserRequest{
		Query: query,
	}
	client := setransport.NewClient(req.Query)
	response, _ := req.Do(context.TODO(), client)
	log.Println(response.String())
}
func Demo4WeiBoUser(query string) {
	cfg := search.NewClientConfig(query)
	client := search.NewClient(*cfg)
	response, _ := client.WeiBo.User(cfg.Query)
	log.Println(response.String())
}

func main() {
    Demo3WeiBoUser("杨幂")
    Demo4WeiBoUser("杨幂")
    
}

>>
2019/12/23 16:59:00 user url https://s.weibo.com/user
2019/12/23 16:59:01 [200 OK] [{"Blog":"https://weibo.com/yangmiblog","Name":"杨幂","Local":"北京","Description" ...

2019/12/23 16:59:01 user url https://s.weibo.com/user
2019/12/23 16:59:01 [200 OK] [{"Blog":"https://weibo.com/yangmiblog","Name":"杨幂","Local":"北京","Description"...
```

同样使用两种方式实现了对微博找人数据的聚合。

读者可以根据同样的思路实现其他模块的开发，具体实施过程中其实涉及到很多细节，但在开发之前，不应该想过多的细节，而应该从整体进行思考。

参考源码：https://github.com/wuxiaoxiaoshen/search

另外一个基于同样的思路实现的“卡通图表库”：https://github.com/wuxiaoxiaoshen/cartooncharts


## 6. 总结

本章的主要内容是面向接口开发，阅读 go-elasticsearch 官方的客户端，研究其面向接口和组合的编程思想，再进一步借鉴在自己的项目中，达到为己所用的目的。

作为开发者，想要持续的进步，不可避免的需要学习，学习先进的开发思想，不断的再项目中化为己用。

读者需要认真体会开源的魅力，介于自己能力水平的不同，在开源中接收到的知识也不同，但仍然需要持续不断的研究开源，整涨自身的见识和技能水平。




