
数据可视化是数据科学领域一个非常重要的环节，通过可视化对数据的处理，使用者不但能够比较快速的观察到数据的趋势，一目了然的把数据呈现出来，使用者更为方便的作出决策。

数据可视化的前提是数据，通过一些技术手段，比如后续的网络爬虫环节，能够获取到数据，直接获取到的数据不一定能够直接使用，还需要经过数据清洗和处理，比如一些空缺值的处理、归一化处理等。

前端页面展示经常会涉及到图表库的操作，一般来说这些页面展示的动作，是由前端工程师来处理，会使用到一些开源的图表库组件，一般都是 js 操作图表库，开发者能够快速的构建其美观且实用图表，将数据转化为易于理解的图表。

本章会介绍下常见的开源图表库以及相应的说明，实践环节会基于 chart.js 说明，如何结合 Golang，开发一款图表库：go-chart。

## 1. 常见开源图表库

图表库是前端页面非常常见的组件，尤其是在统计分析领域，将繁杂的数据直接转化为易于理解的图表，常见的开源图表库多是基于 JavaScript 实现的，兼容 PC 、移动设备、多数浏览器，可高度个性定制化实现数据可视化图表。

市面上有诸多的开源图表库，比如：百度开源的 ECharts、阿里开源的 BizCharts、Chart.js、HighCharts、G2 、D3、Google 出品的 Google Charts等，这些开源的库在兼容性、拓展性、支持图表的种类、交互等层面各有优缺点，具体的选择要结合具体的情况，比如开发者选择的技术栈、需要支持的图表种类等各方面考虑。


### 1.1 ECharts 

Echarts 是百度出品的非常好用的基于 JavaScript 实现的可视化库，支持丰富多样的可视化图表类型，是众多开发者可视化工具的首选。比如支持：折线图、柱状图、散点图、折线图、饼图、地图、热力图等。在可视化领域应用非常广泛，对开发者也非常友好，使用起来非常的简便。

整体上具有以下优势：

- 支持丰富的可视化图表类型
- 体积小
- 兼容性：移动端、Web端自适应效果

一般如何使用 Echarts 定制化图表，首先需要明确你的目的是什么，目的决定你需要选择的图表类型，比如你想观察数据的分散程度，那么就应该选择散点图，比如你想观察数据的占比，那么选择饼图是个更好的选择。


**1. 新建 HTML 文档**

- 新建 HTML 文档，导入 Echarts 库，可以选择本地的 JS 文件，即将 Echarts 源代码下载至本地导入，也可以选择网络分发网络上引入。

**本地文件导入的方式：**
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- 引入 ECharts 文件 -->
    <script src="echarts.min.js"></script>
</head>
</html>
```

**cdn 引入的方式**

> cdn 网络平台很多，一般官网上都能找到具体的地址，只需将本地地址换成网络地址即可

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- 引入 ECharts 文件 -->
    <script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts-en.common.min.js"></script>
</head>
</html>
```


**2. 准备一个 DOM 容器**

> 设置图表的大小、主题等


```
<body>
    <!-- 为 ECharts 准备一个具备大小（宽高）的 DOM -->
    <div id="main" style="width: 600px;height:400px;"></div>
    <script></script>
</body>
```

**3. 加载数据**

```
<script type="text/javascript">
    var dom = document.getElementById("container");
    var myChart = echarts.init(dom);
    var app = {};
    option = null;
    option = {
        xAxis: {},
        yAxis: {},
        series: [{
            symbolSize: 20,
            data: [
                [10.0, 8.04],
                [8.0, 6.95],
                [13.0, 7.58],
                [9.0, 8.81],
                [11.0, 8.33],
                [14.0, 9.96],
                [6.0, 7.24],
                [4.0, 4.26],
                [12.0, 10.84],
                [7.0, 4.82],
                [5.0, 5.68]
            ],
            type: 'scatter'
        }]
    };
    ;
    if (option && typeof option === "object") {
        myChart.setOption(option, true);
    }
</script>
```

即将数据按照指定的格式加载在 script 内。像这种特定的格式，整体上格式差不多，包含三个部分：图表类型（type）、数据（data）、设置（option），不同的图表类型设置的参数又存在差异。正确使用图表类型的方式是：多阅读 API 和官方的示例。

**4. 浏览器打开，渲染之后得到结果**

![](http://ww1.sinaimg.cn/large/741fdb86gy1g69p5hg081j213z0ktt9r.jpg)

上述数据得到如上图所示的散点图。


**5. 总结**

要处理各种图表类型，最重要的是明确图表类型的配置项，当然这些配置项只能从官方渠道中进行数据解读，配合丰富的示例学习 ECharts 的使用。

官网：https://www.echartsjs.com/index.html


### 1.2 BizCharts

BizCharts 致力于解决商业场景下的数据可视化解决方案，具有丰富的示例类型，主打电商业务图表可视化，沉淀电商业务线的可视化规范，基于 React 编写。


如何使用 BizCharts 进行图表绘制？BizCharts 是基于 React 编写的，所以会使用到 React 操作 DOM 树。

**1. 新建 HTML 文档**

加载 React 和 BizCharts 网络分发地址，这个其实和 Go 一样的，需要使用到库的函数，需要先导入，才能使用到功能。

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hello World</title>
    <!-- 引入React -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <!-- 引入Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 引入BizChart -->
    <script src="https://gw.alipayobjects.com/os/lib/bizcharts/3.5.4/umd/BizCharts.js"> </script>
</head>
<body>
<div id="root"></div>
<script></script>
</body>
</html>
```

主要引入 React， Bable， BizChart ，使用的都是对应的网络分发地址。

**2. 加载数据**

- 加载数据，使用 React 操作 DOM 树

```
<script type="text/babel">
    const { Chart, Geom, Axis, Tooltip, Legend, Coord } = window.BizCharts;
    // 数据源
    const data = [
        { genre: 'Sports', sold: 275, income: 2300 },
        { genre: 'Strategy', sold: 115, income: 667 },
        { genre: 'Action', sold: 120, income: 982 },
        { genre: 'Shooter', sold: 350, income: 5271 },
        { genre: 'Other', sold: 150, income: 3710 }
    ];

    // 定义度量
    const cols = {
        sold: { alias: '销售量' },
        genre: { alias: '游戏种类' }
    };
    // React 操作 DOM 树
    ReactDOM.render(
        <Chart width={1200} height={500} data={data} scale={cols}>
            <Axis name="genre" title/>
            <Axis name="sold" title/>
            <Legend position="top" dy={-20} />
            <Tooltip />
            <Geom type="interval" position="genre*sold" color="genre" />
        </Chart>,
        document.getElementById('root')
    );
</script>

```

**3. 浏览器，渲染之后得到结果**

![](http://ww1.sinaimg.cn/large/741fdb86gy1g6aod4igglj210o0fajsf.jpg)

**4. 总结**

整体上 BizChart 的使用方式也是一致的，主要流程如下：

- 导入依赖：React、BizChart
- 加载数据

当然需要数据各种图表类型的使用，比如参数设置等，参考官方文档。

官网：https://bizcharts.net/index

### 1.3 chart.js

chart.js 是一个图表控件集合，使用 html5 的 canvas 进行绘制，支持所有现代浏览器，不依赖任何外部工具库，非常轻量，后续也会针对 chart.js 开发一个图表库：go-chart。

如何使用 chart.js 绘制图表？

**1. 新建 HTML 文档**

主要的思路和上文的Echarts和BizChart 一致，即导入chart.js 文件。

```
<html>
<head>
    <meta charset="UTF-8">
    <title>Charts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.js"></script>
</head>
<body>
<div id="chart-wrapper">
    <canvas id="myChart" style="display: block; height: 235px;width: 470px" ></canvas>
</div>
<script>

</script>
</body>
</html>
```

- 导入依赖，本地文件方式，即下载 chart.js 源码至本地
- cdn 方式，即网络分发地址导入，推荐这种方式，需要网络访问


**2. 加载数据**

根据不同的数据图表类型，加载数据。

```
<script>
    let ctx = document.getElementById("myChart").getContext("2d");
    let myChart =new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'Scatter Dataset',
                backgroundColor: "rgb(255,0,174)",
                borderColor:"rgb(255,0,174)",
                borderWidth:5,
                pointRadius: [3,40,15,10,20,12,8,20], // 点的半径
                data: [
                    {x: -10, y: 0}, // 散点坐标
                    {x: -3, y: 2},
                    {x: -4, y: 5},
                    {x: 0, y: 9},
                    {x: 10, y: 5},
                    {x: 4, y: 5},
                    {x: 5, y: 3},
                    {x: 8, y: 5},
                ]
            }]
        },
        options: {
            scales: {
                xAxes: [{
                    type: 'linear',
                    position: 'bottom'
                }]
            }
        }
    });
</script>
```

**3. 浏览器打开，渲染之后展示图表**

![](http://ww1.sinaimg.cn/large/741fdb86gy1g6apgs04nvj213i0jq3zu.jpg)


### 1.4 HighCharts

HighCharts 是一款兼容 IE6+、完美支持移动端、图表类型丰富、方便快捷的 HTML5 交互性图表库。支持的种类非常多，是诸多的厂商选择的图表库。整体上 HighCharts 的使用方式和之前的差不多。

如何使用 HighCharts 绘制图表？

**1. 新建 HTML 文档，导入依赖**

```
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8"><link rel="icon" href="https://jscdn.com.cn/highcharts/images/favicon.ico">
    <script src="https://code.highcharts.com.cn/highcharts/highcharts.js"></script>
    <script src="https://code.highcharts.com.cn/highcharts/modules/exporting.js"></script>
    <script src="https://img.hcharts.cn/highcharts-plugins/highcharts-zh_CN.js"></script>
</head>
<body>
<div id="container" style="min-width:400px;height:400px"></div>
<script></script>
</body>
</html>
```

导入依赖：highcharts.js，exporting.js，highcharts-zh_CN.js 分别解决图表、导入、中文显示问题。

**2. 加载数据**

```
<script>
    Highcharts.chart('container', {
        chart: {
            type: 'pie'
        },
        title: {
            text: '2018年1月浏览器市场份额'
        },
        series: [{
            name: 'Brands',
            colorByPoint: true,
            data: [{name: 'Chrome', y: 61.41, sliced: true, selected: true},
                {name: 'Internet Explorer', y: 11.84},
                {name: 'Firefox', y: 10.85},
                {name: 'Edge', y: 4.67},
                {name: 'Safari', y: 4.18},
                {name: 'Sogou Explorer', y: 1.64},
                {name: 'Opera', y: 1.6},
                {name: 'QQ', y: 1.2},
                {name: 'Other', y: 2.61}]
        }]
    });
</script>
```

数据在 script 标签内，主要分三类：图表类型、标题（图表轴、图例等）、数据。

**3. 浏览器打开，渲染之后显示**

![](http://ww1.sinaimg.cn/large/741fdb86gy1g6aq2huib5j20xc0m8tas.jpg)


加载数据之后，得到一个饼图，数据的占比和数据内的实际数据相关，还支持各种类型的图表导出。


### 1.5 总结


当然还存在很多类型的 js 图表，从上文的四个图表的示例，能发现什么共性？操作步骤几乎一致。

- 新建 HTML 文件，导入 js文件
- 在 script 标签内加载数据
- 浏览器渲染，显示图表

如果需要使用 Go 结合各类的 js 库进行图表库的开发，我们需要解决的问题是？

- 熟悉 js 库的 API，知道什么类型的图表有哪些配置
- 加载数据，进行渲染


go 提供了两个标准库 text/template 和 html/template 用来处理模版，一定程度上就能解决加载数据的问题。


## 2. 模版引擎的使用


模版引擎分为两个主要的部分：1. 静态数据，即不会更改的内容 2. 动态数据，即随着运行状态可以变更的内容。

模版引擎的用途一般是用于前端的页面开发，整体上的划分为三个步骤：

- 创建模版对象
- 加载模版字符串
- 执行渲染模版

模版引擎的基本用法流程如下：

- 创建模版对象，模版内容可以是文本，也可以是文件

```
func main() {
    pwd, _ := os.Getwd()
	t, err := template.ParseFiles(pwd + "/GopherBook/Chapter5chart/template/index.html")
	if err != nil {
		log.Println(err)
		return
	}
    
}
```

模版文件的内容如下：

```
// index.html
<body>
<div class= "{{.Class}}"></div>
<h1> {{.Title }}</h1>
<p>{{.Content }}</p>
</body>
```

模版文件内的变量使用 `{{}}` 表示，当然还支持比如：判断、变量、管道等方法。

- 加载动态数据

根据模版文件内的动态数据，定义相应的结构体。

```
type Detail struct {
	Class   string
	Title   string
	Content string
}

```

- 执行模版渲染


```
package main

import (
	"html/template"
	"log"
	"os"
)

type Detail struct {
	Class   string
	Title   string
	Content string
}

func main() {
	pwd, _ := os.Getwd()
	t, err := template.ParseFiles(pwd + "/GopherBook/Chapter5chart/template/index.html")
	if err != nil {
		log.Println(err)
		return
	}
	var detail Detail
	detail = Detail{
		Class:   "test-class",
		Title:   "test-title",
		Content: "test-content",
	}
	err = t.Execute(os.Stdout, &detail)
	if err != nil {
		log.Println(err)
		return
	}

}
>>
// 结果
<body>
<div class= "test-class"></div>
<h1> test-title</h1>
<p>test-content</p>
</body>
```

将动态数据加载入模版文件，给我们的启发是，构建图表环节需要将动态数据加载在 script 标签内，这个时候的操作完全可以使用模版引擎达到目的。

在使用模版引擎的时候，一般是加载模版文件的形式，即 template.ParseFiles 方法，这个时候文件的路径不好处理，相对路径换个目录执行，又可能会变，使用绝对路径有不方便拓展。

推荐使用：packr 能够比较优雅的处理模版引擎内的文件。

下载：
```
go get -u github.com/gobuffalo/packr

```

基本使用：还是操作上文的基本使用，通用的方式，可以优雅的处理文件路径的问题。

```
package main

import (
	"html/template"
	"log"
	"os"

	"github.com/gobuffalo/packr"
)

type Detail struct {
	Class   string
	Title   string
	Content string
}

var detail Detail

func init() {
	detail = Detail{
		Class:   "test-class",
		Title:   "test-title",
		Content: "test-content",
	}
}

func withPackr() {
    // 相对目录
	box := packr.NewBox(".")
	// 获取相同目录下的 index.html 文件
	index, err := box.FindString("index.html")
	if err != nil {
		log.Println(err)
		return
	}
	t, _ := template.New("").Parse(index)
	err = t.Execute(os.Stdout, &detail)
	if err != nil {
		log.Println(err)
		return
	}
}
func main(){
    withPackr()
}

>>
<body>
<div class= "test-class"></div>
<h1> test-title</h1>
<p>test-content</p>
</body>
```

以后项目中遇到的静态文件读取等问题，都推荐使用 packr 来处理，整体实现方式比较优雅。


模版引擎解决的问题是静动态数据分离的形式，加载动态数据。为什么要学习这个？回顾下之前四种 js 图表的使用方式：

- 新建静态 HTML 文档，导入依赖
- 加载动态数据
- 浏览器渲染

可以看出三个步骤完全吻合模版引擎的使用方式，借用模版引擎的方式，可以使用 go 的模版引擎配合 js 图表库一起使用，构建图表库，这是整体的核心思想。


## 3. 使用模版引擎构建图表

使用 go 构建图表，核心的思想是：使用模版引擎加载动态数据。各类库的语法有差异，但构建图表的核心有三部分：
1. 图表类型：比如饼图、折线图、柱状体、散点图、面积图等 
2. 数据：不同的数据图表，数据的格式不同，比如散点图是(x,y) 型，折线图是(x)型
3. 配置项，这些配置项有些是全局的，有些是图表的特有的，常见的配置项有：坐标轴、标题、数据提示框、图例等。

想要理解这些图表，首先第一点，需要明确图表的基础元素。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g6ayb0ogfjj20go0as3yo.jpg)

- 标题：Title
- 副标题：SubTitle
- 坐标轴：x-axis, y-axis
- 图例：Legend 图例，用不同形状、颜色、文字等 标示不同数据列
- 数据列：Series 数据列，图表上一个或多个数据系列，比如图表中的一条曲线，一个柱形
- 数据点提示框: Tooltip 
- 数据标签：Labels

明确这些概念之后，你细读各种 js  图表库的文档，你会发现就是这些概念，以及相应的配置，当然各类 js 图表库的支持功能程度不同，在具体实现上稍有差异，比如有些库支持酷炫的动画之类的。



对不同的 js 图表库的模版文件不同，最重要的是导入的 js 库不同，我们都使用 js 库的网络地址，而不使用源代码的形式。

分别对下面三种 js 图表库设置模版引擎，动态数据只需要定义相应的结构体，使用 template 执行渲染即可。


分别实现最小的系统，实现上述图表的功能，最小系统指的是能工作起来，但并没有综合考量拓展性，完整性等，只暂时保障最小系统能运行起来。


**1. Echarts 模版文件**

![](http://ww1.sinaimg.cn/large/741fdb86gy1g6c2mpm1q5j20py0hygqm.jpg)


动态数据包含：Theme 字段、Options 字段，毫无疑问最后的代码处理需要有一个结构包含这两个字段。其中 Theme 用来设置主题，内置包含：light 和 dark 两种主题类型。


通过官方的示例，研究下 Echarts 构建图表的设置都包含哪些字段？

柱状图图表数据设置示例：

```
var option = {
    title: {
        text: 'ECharts 入门示例'
    },
    tooltip: {},
    legend: {
        data:['销量']
    },
    xAxis: {
        data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
    },
    yAxis: {},
    series: [{
        name: '销量',
        type: 'bar',
        data: [5, 20, 36, 10, 10, 20]
    }]
};
```

包含字段包括：title、tooltip、legend、xAxis、yAxis、series等字段，这些字段有些是必须的，有些是非必须，不设置就不显示或者使用默认的方式。

散点图图表数据设置示例：

```
var option = {
        xAxis: {},
        yAxis: {},
        series: [{
            symbolSize: 20,
            data: [
                [10.0, 8.04],
                [8.0, 6.95],
                [13.0, 7.58],
                [9.0, 8.81],
                [11.0, 8.33],
                [14.0, 9.96],
                [6.0, 7.24],
                [4.0, 4.26],
                [12.0, 10.84],
                [7.0, 4.82],
                [5.0, 5.68]
            ],
            type: 'scatter'
        }]
    };
```

包含字段 xAxis、yAxis、series 等字段。

上述是两种不同类型的图表：柱状图、散点图，使用 series 中关键字type 区分，大概知道图表的不同类型是 type 关键字确定。series 是所有数据的集合，字段必须。

那么下一步的操作是构建结构体，使其满足上述的动态数据的字段，这样使用模版引擎的渲染，能将动态数据加载进去，这样就能完成目的。

**2. 方法集合**

定义 Interface 即方法的集合，所有的图表类型都实现这个接口。

```
// base.go

type EChartInterface interface {
	Plot(w http.ResponseWriter, r *http.Request)
	Save(string) bool
	Name() string
	Type() string
}

```

- Plot: 在线展示图表
- Save: 本地存储图表
- Name: 图表的类型
- Type: 图表的类型


**3. 常用的结构体字段**

将常用的结构体字段抽取出来，任意图表类型需要使用，使用 go 的组合，将字段继承过去。图表类型都需要的字段包括：type(图表类型)、title(名称)、series(数据)、xAxis、yAxis等。

```
// base.go

// 图表类型
type BaseType struct {
	Type string `json:"type"`
}

// 标题
type BaseTitle struct {
	Title TitleOpts `json:"title"`
}

// 数据集合
type BaseData struct {
	Series Series `json:"series"`
}

// 选项：x 轴，y 轴等
type BaseOptions struct {
	XAxis   AxisOpts    `json:"xAxis,omitempty"`
	YAxis   AxisOpts    `json:"yAxis,omitempty"`
	ToolTip ToolTipOpts `json:"tooltip,omitempty"`
	Legend  LegendOpts  `json:"legend,omitempty"`
}

// 背景
type BackgroundOpts struct {
	Data string `json:"backgroundColor"`
}


```

单独抽取出这些字段的目的是方便复用，如果某种类型的图表存在特殊字段，单独设置即可。其中需要注意的是结构体的Tag(标签)的名称需要Echart 支持的名称一致，比如 xAxis 不能写做 xaxis 。


**4. 具体的结构体和方法**

各结构体需要支持设置相应的字段的值，包括一些枚举类型的值，比如位置：上下左右，一些默认的值等。

```
// options.go

// 标题的一些属性：包括位置、子标题等
type TitleOpts struct {
	Text      string `json:"text,omitempty"`
	TextAlign string `json:"textAlign,omitempty"`
	Top       string `json:"top,omitempty"`  //'top', 'middle', 'bottom'
	Left      string `json:"left,omitempty"` //'left', 'center', 'right'
	Right     string `json:"right,omitempty"`
	Bottom    string `json:"bottom,omitempty"`
}

const (
	AUTO = iota
	LEFT
	RIGHT
	CENTER
)

var DefaultTextAlign map[int]string

// 设置具体的枚举类型的选项
func init() {
	DefaultTextAlign = make(map[int]string)
	DefaultTextAlign[AUTO] = strings.ToLower("auto")
	DefaultTextAlign[LEFT] = strings.ToLower("left")
	DefaultTextAlign[RIGHT] = strings.ToLower("right")
	DefaultTextAlign[CENTER] = strings.ToLower("center")
}

const (
	BOTTOM = iota
	TOP
	MIDDLE
)

var DefaultTop map[int]string

// 设置枚举类型的选项
func init() {
	DefaultTop = make(map[int]string)
	DefaultTop[BOTTOM] = strings.ToLower("bottom")
	DefaultTop[TOP] = strings.ToLower("top")
	DefaultTop[MIDDLE] = strings.ToLower("middle")
}

var DefaultLeft map[int]string

// 设置枚举类型的选项
func init() {
	DefaultLeft = make(map[int]string)
	DefaultLeft[LEFT] = "left"
	DefaultLeft[RIGHT] = "right"
	DefaultLeft[CENTER] = "center"
}

// 标题位置的设置
func (T *TitleOpts) SetTextAlign(index int) {
	T.TextAlign = DefaultTextAlign[index]
}

// 标题的其他选项设置
func (T *TitleOpts) SetPositions(top int, left int) {
	T.Top = DefaultTop[top]
	T.Left = DefaultLeft[left]
}

// 坐标轴结构体
type AxisOpts struct {
	Data interface{} `json:"data"`
}

type ToolTipOpts struct {
	Data interface{} `json:"data"`
}

type LegendOpts struct {
	Data interface{} `json:"data"`
}

// 数据
type Series struct {
	Data []OneSeries `json:"series"`
}

// 某系列数据的字段
type OneSeries struct {
	SymbolSize int         `json:"symbolSize,omitempty"`
	Name       string      `json:"name"`
	Type       string      `json:"type"`
	Data       interface{} `json:"data"`
}

// 将某系列数据加载入整体数据中
func (S *Series) Add(data ...OneSeries) {
	S.Data = append(S.Data, data...)
}

```


简单的说，这步的目的是为设置的结构体设置对应的方法，包括某些枚举值的设置，默认选项的设置，以及支持用户自设置的值。

**5. 模版文件**

模版文件是存储的静态的数据，置放在目录 /template/plot.html 文件内，将其单独出来，方便类型图表类型的使用。

```
// template.go

func PlotText() string {
	box := packr.NewBox("./template") // 当前目录的 template 文件夹
	plot, err := box.FindString("plot.html") // template 文件夹的 plot.html 文件
	if err != nil {
		log.Println(err)
		return "-1"
	}
	return plot
}


```

**6. 图表类型和背景**

所有的图表类型在 Echarts 图表上反应在 series 中的 type 字段，其实只是一个字符串。方便拓展，任意类型的图表类型都大写，置放在该文件内管理。

```
// type.go

var SCATTER = strings.ToLower("scatter")


```

Echarts 支持默认的主题: light, dark，也支持自定义主题，统一在 theme.go 文件内处理。

```
// theme.go
var DefaultTheme = ""
var LightTheme = strings.ToLower("light")
var DarkTheme = strings.ToLower("dark")

```

**7. 实现散点图表**

基于上述结构体和方法集合的定义，如何实现散点图？答案无非是合理利用上述的：结构体、模版、方法等。

上文讲过，任何图表类型都需要实现 EChartInterface 接口，即定义的结构体必须要有：Plot、Save、Name、Type 四种方法。

**scatter.go**

```
type Scatter struct {
	BaseType // 类型
	BaseTitle // 标题
	BaseOptions // 选项
	BaseData // 数据
	BackgroundOpts // 主题
	json  interface{}
	theme string
}
```

Scatter 结构体利用组合的方式，组合的方式自动的具备相应的字段和方法。

将动态数据加载入模版内，关键的是所定义的图表类型的结构和字段能被Echarts识别，所以定义了一个字段 json，具体的实现如下：

```
func (S *Scatter) toJSON() {
	var V map[string]interface{}
	V = make(map[string]interface{})
	V["title"] = S.Title
	V["series"] = S.Series.Data
	V["xAxis"] = S.XAxis
	V["yAxis"] = S.YAxis
	V["legend"] = S.Legend
	V["tooltip"] = S.ToolTip
	S.json = V
}

```

方法一：设置主题

```
func (S *Scatter) SetTheme(name string) {
	S.theme = name
}
```

方法二：展示图表

```
func (S Scatter) Plot(w http.ResponseWriter, r *http.Request) {
	S.toJSON()
	var theme map[string]interface{}
	theme = make(map[string]interface{})
	theme["Theme"] = S.theme
	theme["Options"] = S.json
	toHandler(w, r, theme)
}
```

为方便复用，将图表绘制和本地存储图表的核心处理逻辑定义在 assistance.go 帮助文件内。

```
func toHandler(w http.ResponseWriter, r *http.Request, data interface{}) {
	t, err := template.New("").Parse(PlotText())
	if err != nil {
		log.Println(err)
		return
	}
	err = t.Execute(w, data)
	if err != nil {
		log.Println(err)
		return
	}

}

func toSave(v interface{}, name string) bool {
	t, err := template.New("").Parse(PlotText())
	if err != nil {
		log.Println(err)
		return false
	}
	file, err := os.Open(name)
	if err != nil {
		log.Println(err)
		return false
	}
	err = t.Execute(file, v)
	if err != nil {
		log.Println(err)
		return false
	}
	return true
}

```

方法三：本地存储图表

```
func (S Scatter) Save(name string) bool {
	S.toJSON()
	if name == "" {
		name = SCATTER
	}
	return toSave(S.json, name)
}
```

方法四：图表名称和类型

```
func (S Scatter) Name() string {
	return SCATTER
}
func (S Scatter) Type() string {
	return S.Name()
}
```

初始化：即实例化一个 Scatter 对象，设置一些默认值等。

```
func NewScatter(title string) *Scatter {
	t := BaseTitle{
		Title: TitleOpts{
			Text: title,
		},
	}
	return &Scatter{
		BaseTitle: t,
		BaseType: BaseType{
			Type: SCATTER,
		},
	}
}
```

接受一个字体字符串参数，设置为散点图的标题，设置图表类型为 SCATTER。


**8. 验证**

使用TDD(测试驱动开发)的思想验证是否正确：

```
func TestScatter(test *testing.T) {
	s := NewScatter("Hello World Scatter")
	s.Series.Add(
		OneSeries{
			SymbolSize: 20,
			Name:       "Brand",
			Type:       s.Type(),
			Data: []interface{}{
				[]float32{10.0, 8.04},
				[]float32{8.0, 6.95},
				[]float32{13.0, 7.58},
				[]float32{9.0, 8.81},
				[]float32{11.0, 8.33},
				[]float32{14.0, 9.96},
				[]float32{6.0, 7.24},
				[]float32{4.0, 4.26},
				[]float32{12.0, 10.84},
				[]float32{7.0, 4.82},
				[]float32{5.0, 5.68},
			},
		},
	)
	s.SetTheme(LightTheme)

	s.BaseTitle.Title.SetPositions(BOTTOM, CENTER)
	http.HandleFunc("/", s.Plot)
	log.Fatal(http.ListenAndServe(":9998", nil))
}

```

- 实例化 Scatter 对象
- 设置具体的数据
- 设置主题
- 设置标题位置
- 在线展示

本地访问：localhost:9998 即可查看图表。

![SCATTER.png](https://ws1.sinaimg.cn/large/741fdb86gy1g7720obd96j213x0m3ab7.jpg)



上文基于 Echarts 逐步的讲解了如何构建图表，整体的核心思想是什么？

- 明确 Echarts 如何构建的图表
- 引申至使用模版引擎加载动态数据的方式构建图表
- 抽取公共的结构体，方便组合复用
- 各图表类型对象实现定义的Interface


当然其实还要很多的细节没有涉及到，但整体的思想是如此，如果你想基于 Echarts 构建更为丰富的图表类型，你可以查看 https://github.com/go-echarts/go-echarts, 采用了类似的思维，实现的功能更为完善。


## 4. 基于 chart.js 构建图表库 go-chart

参照之前类似的思想，本环节将基于 chart.js 构建一个完整的图表库 go-chart，支持：折线图、柱状图、饼图、雷达图、散点图、气泡图等。

完整代码地址：https://github.com/goecharts/go-chart


### 4.1 项目组织

项目的目的是组织一个图表库，有别于其他 web 项目，无需按功能划分不同文件组织。

```
├── assistance.go
├── bar.go
├── base.go
├── bubble.go
├── chart.go
├── color.go
├── const.go
├── data.go
├── doughnut.go
├── line.go
├── options.go
├── pie.go
├── plot.html
├── polarArea.go
├── radar.go
├── scatter.go
├── template.go
├── type.go

```

主要划分为如下几类：

- 模版文件处理：包括静态文件、模版文件处理

```
- plot.html
- template.go
- assistance.go

```

- 基础数据：包括抽象的公共字段和结构体

```
- base.go
- options.go
- type.go
- color.go
- const.go
- data.go
```

- 图表类型

```
- bar.go
- bubble.go
- chart.go
- doughnut.go
- line.go
- pie.go
- polarArea.go
- radar.go
- scatter.go

```


### 4.2 模版文件

**plot.html**

```
<html>
<head>
    <meta charset="UTF-8">
    <title>Charts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.js"></script>
</head>
<body>
<div id="chart-wrapper">
    <canvas id="myChart" style="display: block; height: 235px;width: 470px" ></canvas>
</div>
<script>
    let ctx = document.getElementById("myChart").getContext("2d");
    let myChart = new Chart(ctx, {{ . }});
</script>
</body>
</html>
```

解析模版文件，方便后续在线绘制图表时复用。

**template.go**

```
func PlotText() string {
	box := packr.NewBox(".")
	text, err := box.FindString("plot.html")
	if err != nil {
		log.Println(err)
		return ""
	}
	return text
}
```

利用模版文件，在线绘制或者导出至本地的帮助文件。
**assistance.go**

```
// 存本地的逻辑
func toLocal(name string, v interface{}) bool {
	if name == "" {
		return false
	}
	name = fmt.Sprintf("%s.html", name)
	file, err := os.Create(name)
	if err != nil {
		log.Println(err)
		return false
	}
	tpl := template.Must(template.New("").Parse(PlotText()))
	err = tpl.Execute(file, v)
	if err != nil {
		log.Println(err)
		return false
	}
	return true
}

// 在线展示的逻辑
func toHandle(w http.ResponseWriter, req *http.Request, v interface{}) {
	tpl := template.Must(template.New("").Parse(PlotText()))
	err := tpl.Execute(w, v)
	if err != nil {
		log.Println(err)
		return
	}
}

```





### 4.3 基础数据

基础数据完成的是对一些公共字段的抽取，方便后续的复用。致于为什么抽取这些字段，主要从 chart.js 文档中发现的一些共性，这对读者的要求的是，最好先通读chart.js 的文档和官方的示例，希望能给大家一些启发。

- chart.js 官网：https://www.chartjs.org/


**base.go**

```
type Charts interface {
	Plot(writer http.ResponseWriter, request *http.Request)
	Save(string) bool
	Name() string
}

type Base struct {
	Type    string `json:"type,omitempty"`
	Data    `json:"data"`
	Options `json:"options"`
}
```

定义一个Interface, 每个图表类型的示例都需实现这些方法。定义图表类型的基础模型，之所以这样定义，主要操作的是 chart.js 本身的结构。

```
<canvas id="myChart" width="400" height="400"></canvas>
<script>
var ctx = document.getElementById('myChart').getContext('2d');
var myChart = new Chart(ctx, {
    type: ...,
    data: {
        ...
    },
    options: {
        ...
        }
    }
});
</script>
```

**data.go**

数据的集合，这个文件的目的是操作所有的图表的数据，包括一些标题、颜色、字体、宽度、数据等。

```
type Data map[string]interface{}

// 设置标签
func (D Data) SetLabels(labels Labels) {
	D["labels"] = labels
}

type Labels []interface{}

// 设置数据集
func (D Data) SetDataSet(dataSets []interface{}) {
	D["datasets"] = dataSets
}

// 数据的默认设置
func (D Data) SetDataSetDefault(dataSets []DataSet) {
	data := []interface{}{}
	for _, i := range dataSets {
		data = append(data, i)
	}
	D.SetDataSet(data)
}

// 单个类型的数据
type OneDataSet map[string]interface{}

// 单个类型的数据设置默认值
func (O OneDataSet) SetDefault(data DataSet) {
	O["label"] = data.Label
	O["backgroundColor"] = data.BackgroundColor
	O["borderColor"] = data.BorderColor
	O["data"] = data.Data
	O["fill"] = data.Fill
}

func (O OneDataSet) SetProperty(key string, v interface{}) {
	O[key] = v
}

// 数据集
type DataSet struct {
	Type                 string        `json:"type,omitempty"`
	Label                string        `json:"label,omitempty"`
	BackgroundColor      interface{}   `json:"backgroundColor,omitempty"`
	BorderColor          interface{}   `json:"borderColor,omitempty"`
	Data                 []interface{} `json:"data"`
	Fill                 interface{}   `json:"fill,omitempty"`
	BorderDash           []int         `json:"borderDash,omitempty"`
	PointBackgroundColor interface{}   `json:"pointBackgroundColor,omitempty"`
	BorderWidth          interface{}   `json:"borderWidth,omitempty"`
}

func defaultData() Data {
	var data Data
	data = make(map[string]interface{})
	return data
}

// 点坐标
type Points struct {
	X interface{} `json:"x"`
	Y interface{} `json:"y"`
}

// 气泡图的点坐标
type BubblePoints struct {
	X interface{} `json:"x"`
	Y interface{} `json:"y"`
	R interface{} `json:"r"`
}
```

**options.go**

选项决定的是整体图表具备的辅助功能，比如坐标点是否是从零值开始，坐标轴的标签的位置等。这块内容比较复杂，一方面你需要看 chart.js 有哪些选项，一些图表支持这些选项，一些图表支持那些选项，如何做到最大程度的复用，这个其实依赖于读者自己本身对 chart.js 的熟悉度和你是否想让设计的图表最大化的支持 chart.js 所有的选项功能，其中需要做些权衡。

```
type Options map[string]interface{}

```

图表的选项定义为 map 结构，所有的可选项都是 map 的一个键值。

- 设置相对位置：
```
func (O Options) SetResponsive(v bool) {
	O["responsive"] = v
}
```
- 设置标题信息

```
func (O Options) SetTitle(title string) {
	O["title"] = Title{
		Display: true,
		Text:    title,
	}
}

type Title struct {
	Display  bool   `json:"display,omitempty"`
	Text     string `json:"text,omitempty"`
	Position string `json:"position,omitempty"`
}
```

- 设置图表选项

```
func (O Options) SetToolTips(tips ToolTips) {
	O["tooltips"] = tips
}

type ToolTips struct {
	Mode      string `json:"mode,omitempty"`
	Intersect bool   `json:"intersect,omitempty"`
}
```

- 设置悬浮项
```
func (O Options) SetHover(hover Hover) {
	O["hover"] = hover
}

type Hover struct {
	Mode      string `json:"mode,omitempty"`
	Intersect bool   `json:"intersect,omitempty"`
}
```

- 设置坐标轴

```
func (O Options) SetSales(scales Scales) {
	O["scales"] = scales
}

type Scales struct {
	X []Axes `json:"xAxes,omitempty"`
	Y []Axes `json:"yAxes,omitempty"`
}

type Axes struct {
	Display    bool       `json:"display,omitempty"`
	ScaleLabel ScaleLabel `json:"scaleLabel,omitempty"`
	Ticks      Ticks      `json:"ticks,omitempty"`
	Position   string     `json:"position,omitempty"`
}

// 坐标轴的选项
type AxesOptions map[string]interface{}

func (A AxesOptions) AddAxesOption(key string, val interface{}) {
	A[key] = val
}

// 默认的坐标中选项
func (O Options) defaultAxes(x string, y string, xZero bool, yZero bool) {
	X := []Axes{
		{
			Display: true,
			ScaleLabel: ScaleLabel{
				Display:     true,
				LabelString: x,
			},
			Ticks: Ticks{
				BeginAtZero: xZero,
			},
			Position: LEFT,
		},
	}
	Y := []Axes{
		{
			Display: true,
			ScaleLabel: ScaleLabel{
				Display:     true,
				LabelString: y,
			},
			Ticks: Ticks{
				BeginAtZero: yZero,
			},
			Position: BOTTOM,
		},
	}
	O["scales"] = Scales{
		X: X,
		Y: Y,
	}
}

func defaultOptions(title string) Options {
	var options Options
	options = make(map[string]interface{})
	options.SetTitle(title)
	options.SetResponsive(true)

	options.defaultAxes("", "", false, false)
	return options
}
```

### 4.4 图表类型


完成了模版文件和基础数据类型的定义，基本上就完成了所有的前置任务。接下来的任务是针对各个具体的图表类型实现 Charts 接口。

```
type Charts interface {
	Plot(writer http.ResponseWriter, request *http.Request)
	Save(string) bool
	Name() string
}
```

具体的操作步骤几乎一致，以 line 和 bar 两种图表类型为例说明具体的实现。


**line.go**

```
// 定义结构体
type Line struct {
	Base
}

// 实现 Plot 方法
func (L Line) Plot(w http.ResponseWriter, r *http.Request) {
	toHandle(w, r, L.Base)
}

// Plot 方法的别名
func (L Line) Render(w http.ResponseWriter, r *http.Request) {
	L.Plot(w, r)
}

// 实现 Save 方法
func (L Line) Save(name string) bool {
	if name == "" {
		name = "line"
	}
	return toLocal(name, L.Base)
}

// 实现 Name 方法
func (L Line) Name() string {
	return L.Base.Type
}


func (L Line) String() string {
	return LineType
}

// 实例化：
func NewLine(title string) *Line {

	return &Line{
		Base: Base{
			Type:    LineType,
			Data:    defaultData(),
			Options: defaultOptions(title),
		},
	}
}
```


编写完成 line 图表类型，如何具体的使用？

```
func exampleLine() *charts.Line {
	line := charts.NewLine("Chart.js Line Chart")
	line.Data.SetLabels([]interface{}{"Jan", "Feb", "Mar", "April", "May", "June", "July"})

	dataset := []charts.DataSet{
		{
			Label:           "My First DataSet",
			Data:            []interface{}{11, 2, 30, 14, 5, 23, 7},
			BackgroundColor: charts.Purple(),
			BorderColor:     charts.Purple(),
			Fill:            charts.FILLFALSE,
		},
		{
			Label:           "My Second DataSet",
			Data:            []interface{}{12, 22, 10, 14, 5, 13, 6},
			BackgroundColor: charts.BlueAlpha(0.4),
			BorderColor:     charts.Blue(),
			Fill:            "origin",
			BorderDash:      []int{5, 5},
		},
	}
	line.SetDataSetDefault(dataset)
	return line
}
```

- 实例化 NewLine，传入标题参数
- 设置数据标签
- 设置数据


![LINE.png](https://ws1.sinaimg.cn/large/741fdb86gy1g77itasxvaj213v0kxdi7.jpg)

**bar.go**

柱状图的具体实现也差不多，具体流程一致，即实现接口的方法。

```
// 组合基础数据结构
type Bar struct {
	Base
}

// 实现 Plot 方法
func (B Bar) Plot(w http.ResponseWriter, req *http.Request) {
	toHandle(w, req, B.Base)
}

// Plot 方法起别名
func (B Bar) Render(w http.ResponseWriter, req *http.Request) {
	B.Plot(w, req)
}

// 实现 Save 方法
func (B Bar) Save(name string) bool {
	if name == "" {
		name = "bar"
	}
	return toLocal(name, B.Base)
}

// 实现 Name 方法
func (B Bar) Name() string {
	return B.Type
}

func (B Bar) String() string {
	return BarType
}

// 实例化
func NewBar(title string) *Bar {
	return &Bar{
		Base: Base{
			Type:    BarType,
			Data:    defaultData(),
			Options: defaultOptions(title),
		},
	}
}

```

具体如何使用？看个示例：

```
func exampleBar() charts.Bar {
	bar := charts.NewBar("Chart.js Bar Chart")
	bar.SetLabels([]interface{}{"Jan", "Feb", "Mar", "Apr", "May", "June", "July"})
	dataset := []charts.DataSet{
		{
			Label:           "DataSet 1",
			BackgroundColor: charts.Red(),
			BorderColor:     charts.RedAlpha(0.7),
			Data:            []interface{}{-15, 51, 36, 24, -17, -64, 80},
		},
		{
			Label:           "DataSet 2",
			BorderColor:     charts.BlueAlpha(0.7),
			BackgroundColor: charts.BlueAlpha(0.7),
			Data:            []interface{}{25, -25, 35, 62, 35, -26, -24},
		},
	}
	bar.SetDataSetDefault(dataset)
	bar.SetLegend(charts.TOP, false)
	bar.SetXYAxes([]string{"Month"}, []string{"V"})
	return *bar
}
```

- 实例化 NewBar, 传入标题参数
- 设置标签
- 设置数据
- 设置x,y 轴名称


![BAR.png](https://ws1.sinaimg.cn/large/741fdb86gy1g77itj3bf4j213s0kogmi.jpg)


更多示例参考源代码（https://github.com/goecharts/go-chart）。


实现这个图表库，具体我们做了些什么，要懂哪些内容？

- 熟练使用 js 原生的图表库，明确具体的模版、绘制图表包含哪些内容
- 模版引擎的使用：静态的数据不变，动态的数据执行过程加载进去
- 抽象出可以复用的字段或者结构体
- 合理对项目进行组织：基础数据、模版文件、图表类型

整体的思路是这样，具体的实现过程中，每个开发者的思维不同，具体的实现有所不同。读者把握住实现的思路，做到举一反三。

## 5. 总结


本章主要围绕着：如何使用 go 和开源的 js 图表库构建图表库，例举了常用的开源的 js 图表库，先围绕着原生的 js 库如何实现图表绘制，再结合模版引擎的使用，将编程语言和 js 图表库结合起来，读者如果想要实现 go 版本的其他类型的 js 图表库，第一：需要通读图表库文档，这样明确其结构，知道其支持哪些功能，哪些功能的实现是靠哪个字段实现的，一方面来源于文档，一方面来源于官方的示例，这样能比较快的把握图表库支持的核心功能 第二：合理的组织项目，抽象出具体的可以复用的结构体和字段，包括：基础数据、图表类型、设置项等。





