

在编写代码的过程中，如果项目整体越来越复杂，那么我们如何来维护代码的整体质量呢。在软件领域有个重要的思想：TDD(Test-Driven development: 测试驱动开发)，强调的思维是：优先编写测试，再对代码进行设计和重构的过程。

软件测试是指在指定的条件下，操作程序，验证发现程序的错误。


对于后端工程师来说，我们需要掌握的一个重要的测试方面的技能便是：单元测试。这对我们及时验证自己编码的正确性非常有帮助，后续的项目中，经常会使用到单元测试。

本章将围绕着单元测试为主题，讲述在实际项目中会遇到的问题，以及相应的解决办法。

大纲：

- 单元测试
- 内置库 testing 的使用
- 表格驱动法测试
- 第三方库的使用
- 性能测试


## 6.1 单元测试

单元测试指的是对软件的最小单位来进行正确性的检验工作。最小单元就是单个程序、函数、过程等，在面向对象的编程语言中，就是函数或者结构体绑定的方法。


这里我们统一称之为“函数”。

通过单元测试的步骤如下：

- 指定输入
- 调用函数得出输出
- 判断输出和预期输出之间的关系


一些复杂点的单元测试，还可能需要准备前提条件，比如需要建立数据库的连接等，执行结束后，需要关闭数据库的连接等，这些在单元测试里称之为“SetUp、TearDown”。

## 6.2 基本的使用

Golang 提供了较为丰富的测试方法。主要使用到的内置库是：`testing`。


### 常见用法

下面我们提供一个非常简单的函数，说明测试的基本使用方法：

```
// hello.go
func Hello() string {
	return "Hello World" 
}
```

编写测试验证上述函数的输出是否和预期值相等。

```
// hello_test.go
func TestHello(t *testing.T) {
	result := Hello()
	want := "Hello World"
	if result == want {
		t.Logf("Hello() = %v, want %v", result, want)
	} else {
		t.Errorf("Hello() = %v, want %v", result, want)
	}
}

```

结合上文简单的示例，说明测试需要注意些什么？

- 测试的文件可以和被测的文件同目录，且命名为 `_test.go`，比如：`hello_test.go`
- 单元测试以 `Test_` 开头，名称最好和被测的函数一致，比如： `TestHello`
- 接受的参数为 `(t *testing.T)`
- 判断使用 `t.Errorf` 等方法



上文的基本步骤：

- 给定输入：上述函数 `Hello()` 不需要带输入，所以忽略
- 调用被测函数 `result := Hello()`
- 检验预期和输出值关系 `if result == want`


内置的 `testing` 库还提供了更为丰富的API, 比如格式化打印日志:`t.Log、t.Logf`, 跳过测试: `t.Skip、t.SkipNow、t.Skipped` 等。



更为一般的场景我们使用`t.Run` 方法来进行测试，该方法接受两个参数`func (t *T) Run(name string, f func(t *T))`：`name` 可以用来说明被测对象是什么，`func` 具体的处理函数。


比如：

```
func testHello(expected string) func(t *testing.T) {
	return func(t *testing.T) {
		if expected == "Hello World" {
			t.Logf("Hello() = %v, want = %v", expected, "Hello World")
		} else {
			t.Errorf("Hello() = %v, want = %v", expected, "Hello World")
		}
	}

}

func TestHello2(t *testing.T) {
	t.Run("test for hello with run", testHello(Hello()))
}

```

这样做的好处是，将具体的判断逻辑抽取处理，可以更为方便的测试多种场景，比如你改变输入，得到不同的输出。


那么如何运行单元测试？

- 如果你使用的是集成开发环境（IDE，比如Goland），一般都支持单个测试的运行
- 如果你使用终端，直接到项目所在的目录 `go test -v`


`go test` 还支持按指定单元测试函数名称或者通配符运行。

- `-run` 指定单元测试函数名称
- `-v` 查看具体详情
- `-cpu` 指定 cpu 数目，并发执行
- `-cover` 统计单个文件覆盖率
- `-coverprofile=cover.out` 将统计覆盖率以文件的形式输出
- 后接路径

一般我们直接在项目中这样操作,表示项目中所有的测试文件。

```
go test -v ./...
```

另外想查看具体的测试代码覆盖情况：

```
go tool cover -html=cover.out -o coverage.html

```

浏览器打开`coverage.html` 文件即可查看具体的代码覆盖情况。



这样编写测试是我们常见的场景，其实 Golang 还支持样本测试。


### 样本测试

样本测试并不是常见的测试手段，但是经常能在 GoDoc 文档中看到 Example 中看到示例，通常这些就是基于样本测试自动生成的。

样本测试通过比较内部的 `Output` 注释和输出来判断是否一致。

```
func ExampleHello() {
	fmt.Println(Hello())
	// Output:
	// Hello World
}

```

- 以 `Example_` 开头，最好和被测的函数的名称一致， 比如 `ExampleHello()`
- 必须有注释：`Output`

这样如果你的项目是开源库的话，通过 GoDocs 服务能查看到 `ExampleHello` 这个示例。


### SetUp/TearDown

Go 内置的库并没有明确的使用 `SetUp/TearDown` 机制，但仍然支持这样形式的初始化和清理动作， 即 `TestMain`

```
func TestMain(m *testing.M) {
	fmt.Println("Before ====================")
	code := m.Run()
	fmt.Println("End ====================")
	os.Exit(code)
}

```

- 函数名称只能为 `TestMain`
- 参数只能为 `(m *testing.M)`

这个函数会比其他函数优先执行，在其他单元测试通过后，还会继续调用。可以用来完成那些需要进行初始化和清理动作的测试。


代码示例：https://github.com/wuxiaoxiaoshen/go-how-to-write-test/tree/master/part_one

## 6.3 表格驱动法测试

上文的处理方式存在着不够优雅的情况，即将数据和处理逻辑耦合在一起，有没有更为清晰的处理方式？

表格驱动就是更为优雅的处理方式。

表格驱动测试的基本思想是，将具体的测试数据和处理逻辑单独拎出来，分别处理，这样可以准备有些代表性的数据集，不断的遍历数据集，判断处理逻辑的输出和预期值的关系。


表格驱动测试常用到匿名结构体，一般的形式如下：

```
tests := []struct {
	name string
	want string
}{
	{
		name: "test for hello",
		want: "Hello World",
	},
}

```

上文 `tests` 是一个匿名的切片结构体，包含的属性是 `name` 和 `want`。`name`: 可以理解为被测对象的介绍，`want` 具体的预期值。上文的属性可以根据具体的使用场景灵活变化。

下面具体以示例来说明：

```
func Add(v1 int, v2 int) int {
	return v1 + v2
}

```

一个很简单的两数相加的函数，现在想测试这个函数到底符不符合要求。表格驱动法会这么做：

```
func TestAdd(t *testing.T) {
	type args struct {
		v1 int
		v2 int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "Add",
			args: args{1, 2},
			want: 3,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Add(tt.args.v1, tt.args.v2); got != tt.want {
				t.Errorf("Add() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

- `tests` 是个匿名切片结构体，包含的属性是: `name、args、want`
- 不断遍历准备的数据集，调用被测函数，检验输出和预期值关系


我们可以看到，表格驱动的测试，更符合我们之前讲的单元测试的步骤：1. 指定输入 2. 调用被测函数，得到输出 3. 判断输出和预期值的关系

同时将数据集和被测函数“分离”, 这样的逻辑更为清晰，准备的数据集也可以更为代表性，比如经常考虑边界值（最大、最小、零值、负值...)，这样能及早的发现程序中的潜在的问题。


代码示例：https://github.com/wuxiaoxiaoshen/go-how-to-write-test/tree/master/part_two

## 6.4 goconvey


基于上文，我们知道测试如何编写，以及相应的注意事项。但是内置的 `testing` 库存在另外一个缺点，即不能对输出和预期进行丰富的断言判断，比如想判断输出中是否包含某个字符、输出中是否不为空等多样式的断言。


为了弥补内置库的缺陷，诞生了优秀的第三方库：goconvey(https://github.com/smartystreets/goconvey)


这个库的特点是：

- 完全兼容内置库 `testing` 
- 将运行测试的繁琐命令，提供命令行工具简化
- 支持更为丰富的断言，用于判断输出和预期值
- 提供更为直观的 web 界面
- 支持嵌套，特别适合函数或者方法多分支判断的情况



### 下载安装

```
go get github.com/smartystreets/goconvey
```

### 如何使用

```
import (
	"testing"

	. "github.com/smartystreets/goconvey/convey"
)


func TestAdd_Two(t *testing.T) {
	Convey("test add", t, func() {
		Convey("0 + 0", func() {
			So(Add(0, 0), ShouldEqual, 0)
		})
		Convey("-1 + 0", func() {
			So(Add(-1, 0), ShouldEqual, -1)
		})
	})
}
```


- 以`.` 的导入库的方式，简化调用
- 单元测试函数命名和注意事项和内置库 testing 一致（比如以 Test_ 开头，入参：*testing.T）
- 第一层 `Convey` 提供三个参数：`test add` 说明测试的名称，`t` , `func`
- 嵌套的 `Convey` 层提供两个参数: `0 + 0` 说明测试的名称，`func`
- 使用 `So` 来判断预期值和输出


断言支持的类型非常丰富：

比如相等关系：

```
	ShouldEqual          = assertions.ShouldEqual
	ShouldNotEqual       = assertions.ShouldNotEqual
	ShouldAlmostEqual    = assertions.ShouldAlmostEqual
	ShouldNotAlmostEqual = assertions.ShouldNotAlmostEqual

```

比如布尔类型：

```
	ShouldBeNil          = assertions.ShouldBeNil
	ShouldNotBeNil       = assertions.ShouldNotBeNil
	ShouldBeTrue         = assertions.ShouldBeTrue
	ShouldBeFalse        = assertions.ShouldBeFalse
	ShouldBeZeroValue    = assertions.ShouldBeZeroValue
```

比如数值类型：

```

	ShouldBeGreaterThan          = assertions.ShouldBeGreaterThan
	ShouldBeGreaterThanOrEqualTo = assertions.ShouldBeGreaterThanOrEqualTo
	ShouldBeLessThan             = assertions.ShouldBeLessThan
	ShouldBeLessThanOrEqualTo    = assertions.ShouldBeLessThanOrEqualTo
	ShouldBeBetween              = assertions.ShouldBeBetween
	ShouldNotBeBetween           = assertions.ShouldNotBeBetween
	ShouldBeBetweenOrEqual       = assertions.ShouldBeBetweenOrEqual
	ShouldNotBeBetweenOrEqual    = assertions.ShouldNotBeBetweenOrEqual
```

还支持字符串类型：

```

	ShouldContain       = assertions.ShouldContain
	ShouldNotContain    = assertions.ShouldNotContain
	ShouldContainKey    = assertions.ShouldContainKey
	ShouldNotContainKey = assertions.ShouldNotContainKey
	ShouldBeIn          = assertions.ShouldBeIn
	...
```

读者可以根据使用场景灵活的选择。

### 命令行

> 安装库即自动安装该命令行工具，如果失效，看下是否 GOBIN 加入 PATH 环境变量

在项目目录下执行： `goconvey` 即会自动启动`web` 服务。默认访问 `http://127.0.0.1:8080/` 即可在 `web` 界面上查看到具体的信息

包括：

- 整体覆盖率
- 单个测试文件的运行情况
- 重修运行
- 单个测试文件的覆盖或者未覆盖情况


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1lyt6cjoij213w0n4wqy.jpg)


建议：`goconvey` 配合原生`testing` 库使用，提高开发效率。


代码示例：https://github.com/wuxiaoxiaoshen/go-how-to-write-test/tree/master/part_two

## 6.5 解决依赖问题


基于上文，我们已经知道单元测试如何编写，以及相应的工具和指标都清楚了，但是上文的示例过于简单。事实上现实的项目中存在比示例更为复杂的场景。

比如：

- 函数之间相互依赖的关系
- 函数调用需要依赖网络访问的情况
- 函数调用需要依赖数据库的情况


本节的内容，便是如何解决这些复杂的依赖关系。让我们单元测试做的更为纯粹些，只聚焦于被测的函数。



### 函数依赖关系

函数依赖关系是指：一个函数的运行成功与否，依赖于其他函数的输出，这种情况，具体需要看情况处理，有些逻辑不是很复杂的，直接调用即可，有些逻辑复杂的，我们最好的情况是使用 `Mock` 操作，即模拟动作：即模拟依赖函数的输出。


比如示例：

```

func GetPageResponse(url string) (int, []byte, error) {
	request, _ := http.NewRequest("GET", url, nil)
	client := http.DefaultClient
	response, err := client.Do(request) //
	if err != nil {
		return response.StatusCode, nil, fmt.Errorf("client.Do fail")
	}
	defer response.Body.Close()
	result, err := ioutil.ReadAll(response.Body)
	return response.StatusCode, result, err
}
```

上文的函数依赖于真实的网络请求，否则会导致失败。

这个时候我们可以模拟网络请求。

```
import (

	"net/http"
	"reflect"
	"testing"

	. "bou.ke/monkey"

	. "github.com/smartystreets/goconvey/convey"
)

func TestGetPageResponse(t *testing.T) {
	var client *http.Client
	guard := PatchInstanceMethod(reflect.TypeOf(client), "Do", func(*http.Client, *http.Request) (*http.Response, error) {
		var response http.Response
		response.StatusCode = 400

		return &response, fmt.Errorf("%s", "http fail")
	})
	defer guard.Unpatch()
	tests := [2]struct {
		name  string
		url   string
		want1 int
		want2 []byte
		want3 error
	}{
		{
			name:  "not ok",
			url:   "http://www.baidu.com",
			want1: 400,
			want2: []byte{},
			want3: fmt.Errorf("%s", "http fail"),
		},
		{
			name:  "not ok",
			url:   "http://www.hao123.com",
			want1: 400,
			want2: []byte{},
			want3: fmt.Errorf("%s", "http fail"),
		},
	}
	Convey(tests[0].name, t, func() {
		code, _, err := GetPageResponse(tests[0].url)
		So(code, ShouldEqual, tests[0].want1)
		So(err, ShouldNotBeNil)
	})
	Convey(tests[1].name, t, func() {
		code, _, err := GetPageResponse(tests[1].url)
		So(code, ShouldEqual, tests[1].want1)
		So(err, ShouldNotBeNil)

	})
}
```

上文使用 `Mock` 的对 `client.Do` 方法进行了打桩处理，使其输出状态码为 400。导致被测函数一定会出错。

上文使用到了另一个第三方库：monkey(https://github.com/bouk/monkey)


```
// 下载
go get github.com/bouk/monkey
```

通常使用其中的两种方法即可：

- 对结构体的方法打桩：`monkey.PatchInstanceMethod`
- 对函数打桩: `monkey.Patch`


使用中需要注意几点：

- 明确你是对哪个对象打桩处理，是函数还是方法
- 打桩的函数参数和输出须完全一致。


举例：

```
func GetPageResponse(url string) (int, []byte, error) {
	request, _ := http.NewRequest("GET", url, nil)
	client := http.DefaultClient
	response, err := client.Do(request) //
	if err != nil {
		return response.StatusCode, nil, fmt.Errorf("client.Do fail")
	}
	defer response.Body.Close()
	result, err := ioutil.ReadAll(response.Body)
	return response.StatusCode, result, err
}

func GetTrendingTwo(url string) Results {
	_, values, _ := GetPageResponse(url) //
	var results = make([]Result, 0)
	stringReader := strings.NewReader(string(values))
	doc, _ := goquery.NewDocumentFromReader(stringReader)
	doc.Find("div.explore-content ol.repo-list li").Each(func(i int, selection *goquery.Selection) {
		var oneProject Result
		oneProject.Name, _ = selection.Find("div h3 a").Attr("href")
		oneProject.URL = fmt.Sprintf("https://github.com%s", oneProject.Name)
		results = append(results, oneProject)
	})
	return results
}

```

上文示例中 `GetTrendingTwo` 的测试依赖于 `GetPageResponse` 的调用。你当然可以对函数进行重构，使其不依赖于 `GetPageResponse`，这里示例使其构成依赖。（`GetTrendingTwo`实现的是解析网页源代码的功能）

那么如何打桩处理？

- 明确 `GetPageResponse` 是个函数
- 确保打桩函数和 `GetPageResponse` 的参数和返回值一致

具体如下：


```
import (
	"fmt"
	"net/http"
	"reflect"
	"testing"

	. "bou.ke/monkey"

	. "github.com/smartystreets/goconvey/convey"
)
func TestGetTrendingTwo(t *testing.T) {

	guard := Patch(GetPageResponse, func(_ string) (int, []byte, error) {
		return 200, []byte(PageString), nil
	})
	defer guard.Unpatch()

	tests := []struct {
		name string
		url  string
	}{
		{
			name: "get trending",
		},
	}
	Convey(tests[0].name, t, func() {
		results := GetTrendingTwo(tests[0].url)
		So(results, ShouldNotBeNil)
		So(len(results), ShouldEqual, 1)
		So(results[0].URL, ShouldContainSubstring, "github.com")
	})
}

```

我们对 `GetPageResponse` 函数打桩，使其返回一串符合后面函数解析的状态码、字符串、错误信息，即`(200，[]byte(PageString), nil)`。这样被测的函数就能顺利的往下执行。达到测试的目的。


代码示例：https://github.com/wuxiaoxiaoshen/go-how-to-write-test/tree/master/part_three

### 数据库依赖


函数依赖的问题可以按照 `Mock` 的方式进行处理，真实的业务场景中还需要频繁使用到数据库，比如接口的调用资源，真实的情况是将数据库储存的内容搜索出来。


那么这种场景如何解决呢？下面是其中的两种方法：

- 使用个真实的测试数据库，将一些模拟的数据存在测试数据库中，真实的调用即可
- 对数据库打桩，模拟数据库的真实动作


```
// 下载相应的库
// 数据库打桩
go get github.com/DATA-DOG/go-sqlmock 
// gorm 操作数据库
go get github.com/jinzhu/gorm
// gin web 服务
go get github.com/gin-gonic/gin 
```

这里着重对数据库打桩进行介绍。

因为示例中使用到的 `gin` 的用法，这边稍带下讲下如何使用 `net/http/httptest` 进行接口的测试。

```
func setupRouter() *gin.Engine {
	r := gin.Default()
	r.GET("/ping", func(c *gin.Context) {
		c.String(200, "pong")
	})
	return r
}

```

相应的测试函数：

```
import (
	"net/http"
	"net/http/httptest"
	"testing"
}

func TestPingRoute(t *testing.T) {
	router := setupRouter()

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/ping", nil)
	router.ServeHTTP(w, req)
	fmt.Println(w.Body.String()) // pong
}
```


上文的接口测试并没有使用到数据库的交互，所以直接调用，判断输出即可。


下面我们尽量模拟真实的数据库交互。


**1** 建立数据库连接

```
var POSTGRES *gorm.DB

func DBInit() *gorm.DB {
	host := "127.0.0.1"
	port := "5432"
	user := "postgres"
	password := ""
	dbName := "gin_example"
	sslMode := "disable"

	connectString := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		host, port, user, password, dbName, sslMode)
	conn, err := gorm.Open("postgres", connectString)
	if err != nil {
		panic("failed to connect database" + err.Error())
	}

	conn.LogMode(true)

	conn.DB().SetMaxIdleConns(3)

	POSTGRES = conn
	return POSTGRES

}

```

**2** 定义数据模型

- Item 即为表，相应的字段为表的列
- NewItems 可以用来表示数据库中的两条记录
```
type Item struct {
	gorm.Model
	Name string `gorm:"type:varchar" json:"name"`
}

type Items []Item

func NewItems() Items {
	return []Item{
		{
			Model: gorm.Model{
				ID:        1,
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			},
			Name: "XieWei",
		},
		{
			Model: gorm.Model{
				ID:        2,
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			},
			Name: "WuXiaoShen",
		},
	}
}

```

**3** 路由注册

```

func Register(r *gin.RouterGroup) {
	r.GET("/name/:id", GetNameHandler)
}

func GetNameHandler(c *gin.Context) {
	id := c.Param("id")
	var record Item
	if dbError := POSTGRES.Where("id = ?", id).First(&record).Error; dbError != nil {
		c.JSON(http.StatusBadRequest, dbError.Error())
		return
	}
	c.JSON(http.StatusOK, record)
}
```


这个示例真实的场景是：启动服务后，访问接口 `localhost:port/name/{id}` 即会真实的去数据搜索到 `id` 为指定值的一条记录。

那么如何对存在数据库交互的函数 `GetNameHandler` 进行测试？


**1** 连接模拟，使用 `TestMain`

```
var (
	sqlMock sqlmock.Sqlmock
)

func TestMain(m *testing.M) {
	db, mock, err := sqlmock.New()
	if err != nil {
		log.Fatalf("can't create sqlmock: %s", err)
	}
	POSTGRES, err = gorm.Open("sqlite3", db)
	if err != nil {
		log.Fatalf("can't open gorm connection: %s", err)
	}
	POSTGRES.LogMode(true)
	sqlMock = mock
	code := m.Run()
	os.Exit(code)

}

```

即将数据库的连接进行了模拟。

**2** 模拟数据

```
func FixRule(value string) string {
	return fmt.Sprintf("[" + value + "]")
}

// 表返回字段以及返回结果
func GetRowsForItem(item Item) *sqlmock.Rows {
	fields := []string{"id", "created_at", "updated_at", "deleted_at", "name"}
	rows := sqlmock.NewRows(fields)
	rows.AddRow(item.ID, item.CreatedAt, item.UpdatedAt, item.DeletedAt, item.Name)
	return rows
}
```

模拟了真实的数据库中的记录。

**3** 接口测试

```
func TestGetNameHandler(t *testing.T) {
	tests := [3]struct {
		name string
		id   string
	}{
		{
			name: "get one record by id = 1",
			id:   "1",
		},
	}
	g := gin.Default()
	v1 := g.Group("/v1")
	Register(v1)

	recordSQL := `SELECT * FROM items WHERE items.deleted_at IS NULL AND (id = $1) ORDER BY "items"."id" LIMIT 1`

	Convey(tests[0].name, t, func() {
	
		w := httptest.NewRecorder()
	
		sqlMock.ExpectQuery(FixRule(recordSQL)).WithArgs(tests[0].id).WillReturnRows(GetRowsForItem(NewItems()[0]))
	
		request, _ := http.NewRequest("GET", fmt.Sprintf("/v1/name/%s", tests[0].id), nil)
		g.ServeHTTP(w, request)
	
		So(w.Body.String(), ShouldContainSubstring, "XieWei")
	
		var result Item
		json.Unmarshal(w.Body.Bytes(), &result)
		So(result.ID, ShouldEqual, 1)
		So(result.Name, ShouldEqual, "XieWei")
	})
}

```

- 同样使用 `httptest` 进行接口测试
- 再调用接口之前先模拟数据库的动作，`GetNameHandler` 是在搜索数据
- 执行模拟数据库动作 `sqlMock.ExpectQuery` 和相应的返回值
- 调用接口
- 对得到的数据进行验证

执行结果(日志查看)：

```
=== RUN   TestGetNameHandler
[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.

[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /v1/name/:id              --> github.com/wuxiaoxiaoshen/go-how-to-wirte-test/part_four.GetNameHandler (3 handlers)

  get one record by id = 1
(/Users/xiewei/go/src/github.com/wuxiaoxiaoshen/go-how-to-wirte-test/part_four/gin_example.go:16)
[2019-03-31 15:47:53]  [1.87ms]  SELECT * FROM "items"  WHERE "items"."deleted_at" IS NULL AND ((id = '1')) ORDER BY "items"."id" ASC LIMIT 1
[1 rows affected or returned ]
[GIN] 2019/03/31 - 15:47:53 | 200 |    2.318819ms |                 | GET      /v1/name/1
✔✔✔


3 total assertions

--- PASS: TestGetNameHandler (0.00s)
PASS

```

可以看到执行了 `SQL` 语句，得到一条记录，同时判断下输出和预期是否符合要求。


上文使用到了 sqlMock(https://github.com/DATA-DOG/go-sqlmock)。可以完成对数据的增删改查，同样支持事务和回滚。能够方便的模拟数据库的动作。


上文数据库的打桩处理是具体是如何操作的，我们再进行总结下：

- 根据定义数据库模型，即表，准备相应的测试数据，即用来模拟搜索到的表中的记录
- 使用内置的 `httptest` 对接口测试
- 编写具体的 `SQL` 执行语句
- 调用接口，查看返回值和具体的预期值处理


代码示例：https://github.com/wuxiaoxiaoshen/go-how-to-write-test/tree/master/part_four

## 6.6 性能测试

上文所有的章节都是完成对代码的测试，检验代码的正确程度，一般的也会根据测试得出一些指标，比如覆盖率，在真实的生产环境中，一般都有要求，比如代码覆盖率需要达到90%，才将新增代码合入代码主分支。

这些覆盖率可以使用到一些优秀的工具来完成，比如 codecov(https://codecov.io/), 配合 travisCI(http://travis-ci.org/)使用。可以对代码的覆盖率等情况有更为直观的查看。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g1m1p0zxg7j213x0n0ad5.jpg)


单元测试只能验证代码是否正确，在复杂的工程下其实很有效，你无法确定你开发的功能是否会影响到别的功能，这个时候测试一定程度上能够有效验证出来。

那如何检验代码的性能？



这里需要使用到基准测试：

举例两个字符串拼接函数：


```
func One() string {
	var s string
	s += "hello python + \n"
	s += "hello golang + \n"
	return s
}

func Two() string {
	return fmt.Sprintf("%s+\n%s +\n", "hello python", "hello golang")
}

```

基准测试：

```
func BenchmarkOne(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		One()
	}
}

func BenchmarkTwo(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Two()
	}
}

```

执行：

```
go test -v -bench=. -benchmem
```

结果显示：

```

goos: darwin
goarch: amd64
pkg: github.com/wuxiaoxiaoshen/go-how-to-wirte-test/part_six
BenchmarkOne-4   	20000000	        69.6 ns/op	      32 B/op	       1 allocs/op
BenchmarkTwo-4   	10000000	       162 ns/op	      32 B/op	       1 allocs/op
PASS
ok  	github.com/wuxiaoxiaoshen/go-how-to-wirte-test/part_six	3.264s
```

- 实现相同的功能，函数 `One` 性能优于 `Two` 
- 查看的指标：名称、执行次数、每次循环执行时间、分配字节、内存交换
- 重点衡量：每次执行时间、内存交换、分配字节


有这些指标就可以引导我们去思考，什么样的函数性能更好，当然真实的场景我们并不会对每一个函数进行性能测试，而是有目的的对关键处理函数进行性能测试，不断的进行优化，达到性能优化的目的。




## 总结

本章主要讲述了在 Golang 里面如何编写测试，主要包括内置库的测试的编写，为了解决测试数据和业务代码的耦合，建议使用基于表格驱动的测试方法。

另外掌握一些优秀的开源第三方库，可以使我们事半功倍，我们推荐使用 `goconvey` ，支持嵌套、丰富的断言方法、同时提供替代原生的繁琐的命令行运行测试的方法，web 界面查看运行测试的结果和覆盖率等指标。

对于复杂的函数的测试，如何解决依赖的问题，我们提供了`Mock` 的方法，包括对函数的 `Mock` 操作、对结构体方法的 `Mock`操作、数据库的 `Mock` 操作。每一种模拟操作都是为了解决外部依赖问题，比如外部网络请求，外部数据库依赖等动作。这样就能覆盖绝大多数业务开发的场景。

单元测试是用来对编写过的代码的正确性验证，测试通过，不一定说明代码完全正确，可能还存在潜在的问题。测试对于项目越来越复杂的情况，一定程度上可以避免新功能影响原有功能的问题。对于代码的优化，我们可以从逻辑层面、结构层面对代码进行重构。另外对于我们关键的地方可以进行性能测试，使用更有优秀的算法或者数据结构达到性能优化的目的。

