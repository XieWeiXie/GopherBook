
通过全书的学习，读者应该能够从各种项目示例中感受到 Go 具体可以使用在哪些场景中，比如命令行、爬虫、Web 开发、GraphQL 开发、图表库等。

本章尝试总结下适用于开发者的 Go 学习路径，希望对大家有启发。


## 0. 内置库


毫无意味，内置库是使用最为频繁的库，里面的诸多编程思想、实现，都值得读者反复研究、认真琢磨。无数的优秀第三方库都是基于内置库的基础之上完成的。

当然针对内置库，读者只需要明确基本的用法，在使用过程中能快速的知道其方法即可，对自己要求高的，可以认真研读其实现思想，包括项目组织、函数命名等。

读者如何访问官方文档呢？

其一, 可以访问这个地址：https://golang.org/pkg/ ; 其二，可以使用 godoc 命令本地访问。

> 在 golang 1.13 版本中：godoc 命令被移除了，读者需要自行安装

```
go get golang.org/x/tools/cmd/godoc

>> godoc --http=:8080

访问：http://localhost:8080
```

**文档都是如何组织的?**

读者肯定会有疑问，这个官方文档是如何呈现出这些页面的展现的内容？

答案：注释。官方对这种文档的组织有要求，比如 Package 层级的注释，比如函数层级的注释，比如示例的注释等，都会映射在呈现的文档中。这也提醒读者一点，编写代码最好带有统一的注释风格，一方面是可读性，一方面是维护性。

以官方内置库： bytes 为例，陈述下如何对库进行文档组织。

![bytes.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6v846wfcj213x0ldtbf.jpg)


1. Package 层级

主要描述这个库是做什么的，用途是什么，注释中以 Package 开头，即对应 Overview 显示的部分。

```
// bytes/bytes.go

// Package bytes implements functions for the manipulation of byte slices.
// It is analogous to the facilities of the strings package.
package bytes


```

2. 函数、结构体方法层级

主要描述的各函数的作用、结构体的用途、以及结构体的方法的用途，即 Index 显示的，且只显示可导出的函数、结构体和方法（首字母大写）。在函数、结构体或者方法的上面编写注释，最后会转换成文档。

![contain.png](http://ww1.sinaimg.cn/large/741fdb86gy1ga6vcilz9ij213y0gfq4v.jpg)

```
// bytes/bytes.go

// Contains reports whether subslice is within b.
func Contains(b, subslice []byte) bool {
	return Index(b, subslice) != -1
}

```

示例（Example）是如何显示的呢？

```
// bytes/example_test.go

func ExampleContains() {
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("foo")))
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("bar")))
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("")))
	fmt.Println(bytes.Contains([]byte(""), []byte("")))
	// Output:
	// true
	// false
	// true
	// true
}

```

单元测试章节曾描述过，如何进行样本测试，即以 `Example_` 开头的函数，且其结果以注释的形式描述。最后在文档内都会显示成示例（Example）。


**如何阅读内置库?**

笔者建议定期归纳总结内置库的使用方法，《编写可读艺术的代码》一书中也建议，周期性对库对周期性总结，所谓温故而知新。

- 学习其代码组织方式

相似功能的内容，进行相似的代码组织方式、命名、组织结构。比如：crypto 包，包含一系列的加密包。

```
>> ls crypto
aes
cipher
...
rsa
sha1
sha256
sha512
...

```

- 学习其面向接口、面向对象的编程思想

内置库使用接口最常见的库是： io 库，阅读源码可以发现内置了一系列的 Interface 定义，也有一系列 Interface 接口的组合，描述其能力。

```
type Reader interface {
	Read(p []byte) (n int, err error)
}
type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type Seeker interface {
	Seek(offset int64, whence int) (int64, error)
}
...
```

可以发现其命名规范也存在类似的特点，以 `_er` 结尾，描述其能力。

- 多用思维导图总结其常用功能

比如本书的第四章大量的使用思维导图组织内置库的常用功能，这样使读者做到心中有数，真实开发场景下，能快速的迭代开发。


阅读内置库，其实也是个非常繁重的工程，读者最好还是聚焦在自身的问题场景出发，针对性的研究其用法，比如你是 Web 开发，经常性的用到 net/http 库，这个时候你就可以阅读其源码，针对性的解决自身的问题。

## 1. 版本管理

在官方没有推出正式的版本管理工具之前，社区存在许许多多的版本管理工具，比如 govendor, dep, glide等，这些版本管理工具都从不同的侧重点管理项目中需要使用到的第三方库，没有一个统一的规范。

阅读此书的读者：Go 版本已经推出 1.13.4 正式版本，新版本推荐使用 Go Module 进行版本管理，也是官方推荐的，几乎所有的热门开源项目都转用 Go Module 进行版本管理。

那么如何使用 Go Module 进行版本管理？

> 以托管在 Github 上的项目为例

**初始化**

```
cd chapter14/project && go mod init github.com/wuxiaoxiaoshen/chapter14/project
```

初始化指定了 Package 的导入路径，意味着包内使用对应的结构体或者函数，需要导入的路径是 `github.com/wuxiaoxiaoshen/chapter14/project`。

```
// main.go
import (
	"fmt"
	"github.com/wuxiaoxiaoshen/chapter14/project/internal"
)

func main() {
	v := internal.NewVersion("v0.14")
	fmt.Println(v.GetValue())
}
```

内部 internal 定义了一个结构体 Version, 和相应的方法 GetValue， 内部导入需要显式的指定导入路径。


项目内自动创建一个名为`go.mod`文件。

```
module github.com/wuxiaoxiaoshen/chapter14/project

go 1.13

```



**下载**

需要使用到的第三方库，在项目内使用 `go get ***` 对应的包

```
go get github.com/spf13/cobra
```

自动会编辑 go.mod, go.sum 文件，保持依赖关系和对应的版本。

```
module github.com/wuxiaoxiaoshen/chapter14/project

go 1.13

require github.com/spf13/cobra v0.0.5

```

没错，Go Module 的原理就是依赖这两个文件进行版本管理。

那如果克隆别人的开源的代码，如何下载相应的依赖库？

```
go mod download
```

真实的库安装在 `$GOPATH/pkg/mod` 目录下。

**移除不需要的模块**

```
go mod tidy
```

这个命令指的是项目中引入了不需要的库，可以使用这个命令进行移除操作。


Go Module 的亮点不仅仅在于提供简单的版本管理，还提供以下功能。

- 使用 Replace 替换包
- 语义化版本管理
- 解决依赖库冲突问题
- 自动查找包依赖


通常来说，使用 `go mod init`, `go mod tidy` ，`go mod download` 这几个命令就能覆盖绝大多数应用场景。读者项目内将 `go.mod, go.sum` 进行代码版本管理，这样别人使用也能使用命令获取到依赖库。推荐读者使用这种方式。


## 2. 测试驱动开发

读者需要充分使用测试驱动开发的原理，尽管绝对的测试驱动步骤比较严谨，但作为开发者，还是需要借鉴这种思路，辅助自己编写正确的代码。如果不是技能过硬，对任何不确定的内容，都需要编写相应的测试，这是严谨要求自身编写正确代码的第一步。

如果你仔细阅读本书提供的相应的源代码，会经常可见单元测试，及时的验证编写的代码的正确性。

```
// internal_test.go
package internal

import (
	"fmt"
	"testing"
)

func TestVersion(t *testing.T) {
	v := NewVersion("v0.15")
	fmt.Println(v.GetValue())
}
```


甚至社区内有开发者借鉴测试驱动的思想学习编程：https://github.com/quii/learn-go-with-tests

简单的说，单元测试的意义：

维护代码的正确性，尤其是项目越来越复杂，翻开任何一个开源项目，都能看到测试。希望读者重视这种思想。


## 3. 命令行

任何编程语言都可以编写命令行工具，那么编写命令行工具的重点是什么？是实现吗？笔者认为，实现不重要，重要的是如何组织命令、子命令、参数、结构化显示结果等。这些才是最终用户能持续使用命令行工具的关键。

关于这些命令、子命令、参数的组织，没有什么好的思路，无外乎，前期讨论需求的，开发者需要明确需求到底是什么？借用一些思维导图工具，对预期的结果进行结构化的组织，最终的结果是显示 Json、表格、还是存文本，都需要斟酌着考量。

笔者建议，阅读一些优秀的命令行工具，借鉴其组织方式，比如 Docker, Kubectl 这类对开发非常友好的命令行工具。这近一步需要读者具备阅读源代码的能力。

对于命令行界面的开发，笔者只推荐这两个库：

- cobra: https://github.com/spf13/cobra
- urfave/cli:https://github.com/urfave/cli

## 4. Web 开发

开源社区存在许许多多的 Web 框架，这些框架确实在某种层面上精简了开发者的代码，封装的非常优雅。对于业务开发，选择任何一款流行的 Web 框架，比如 gin, echo, iris，问题都不会太大，可以开始实现业务需求。

但 Web 开发的核心并不是熟练的使用这些 Web 框架，而是**理解需求**。

**理解需求**为什么这么重要？代码的实现，便是需求的实现；理解需求不到位，代码写的再多，也是浪费。读者需要花更多的时间用于前期思考，比如如何进行项目组织，能最大化的提高系统的可扩展性，比如如何使用设计模式在项目内，比如如何命名与组织，提高代码的可读性，这些都是要点。具体到业务开发，如何处理请求、如何认证、如何响应信息，正确的信息如何返回，发生错误如何返回？这也是笔者为什么花大篇幅介绍 Web 开发的方方面面。

项目开发仅仅只是整个项目周期中的一环，项目稳定的运行，还包含诸多的环节，比如如何部署，多组件之间如何交互，比如如何对项目进行监控，可视化，如何应对故障等。


Web 开发是 Go 应用一个领域，框架能够提高开发开发的速度，但归根结底，读者还是需要掌握一套自己组织的 Web 开发的整体思路，这样才不会陷入只是调用 Web API 进行开发的开发者。


Web 开发框架推荐使用：

- Iris: https://github.com/kataras/iris
- gin: https://github.com/gin-gonic/gin
- echo: https://github.com/labstack/echo



## 5. SQL 与 ORM 

使用持久化存储在项目中非常常见。比如关系型数据库：MySQL， PostgresSQL ，非关系型数据库：MongoDB, Redis 等。

ORM 的技术的出现，是精简开发者在项目内频繁的使用 SQL 语句，因为 SQL 语句的可读性不高，代码内充斥 SQL 语句，影响维护和阅读。推荐读者使用 ORM 技术。ORM 封装了场景的 SQL 语句，比如查询、删除、增加、更新等。那么读者认为如何才能使用好 ORM 呢？

读者需要体会到：编程语言只是实现过程，编程整体是个系统工程，编程实现只是其中小小的一环。

要使用好 ORM, 核心其实还是掌握关系型数据库的原理、优化、索引等。受自身项目所限，基本上读者使用基本的 SQL 功能就能完成任务，如果数据量大了，势必会遇到查询缓慢的问题，如果服务失联，势必会遇到数据丢失的问题。而这些才是关系型数据库使用的核心，读者需要懂 索引的原理、索引的优化，才能设计更加健壮的模型，完成任务的同时，使系统具备持续迭代的能力。

建议读者，熟练掌握编程语言的同时，多研究基础原理，这些原理的掌握，才是读者应对繁复变化的核心竞争力。

ORM 库推荐使用：

- GORM: https://github.com/jinzhu/gorm
- XORM: https://github.com/go-xorm/xorm


## 6. 系统工程


编程是个系统功能，包含诸多的内容。本环节尝试给读者熟练整体的开发流程。希望对大家有启发。


**需求讨论：**

这一步的环节，是让开发者明确该实现什么，该做些什么，真实的互联网公司，需求讨论的环节，往往是产品经理的角色。产品经理对接用户或者销售，收集用户需求。读者这一环节，尽可能都要参与进去，明确需求，而不是侧重在实现。明确需求可以培养读者的沟通能力，对产品的把控能力，以及对开发难度、时间的预估能力。

如果读者没有真实的需求，自己在实现项目的过程中，前期的准备工作也尽量按照这样的思路进行，比如给项目定个实现的结果、给项目预估个实现的周期等，培养自己的能力。

**迭代开发/测试**

开发者根据需求，项目开发。项目开发完全是由开发者决定，对用户不可见，开发者接收到的反馈就会比较少。读者需要合理的组织自己的项目结构，如果没有思路，就借鉴别人优秀的项目的组织结构。开发过程中也需要及时的编写单元测试，验证自身代码的正确性，没有用户的反馈，一方面需要依靠开发者自身编写代码的逻辑正确性，但不可能面面俱到，而测试是维护代码正确性的一个非常重要的方法。

针对真实的产品，产品上线前，往往有测试人员的功能测试，这一步也非常重要，是进一步验证产品逻辑正确性的一步。鼓励读者们编写程序开源出来，接收更多的用户的使用，及时迭代修复功能。

开发过程中通常也是需要交互其他组件：比如持久化存储 MySQL，比如缓存 Redis，比如搜索 Elasticserch，比如消息队列 Kafka等。

开发不是一个独立的环节，一套完善的系统需要应用许多的技术。这些技术的选型都有对应的使用场景，随着技术的精进，面对不同的问题，开发者需要持续学习其他技术，完善整个系统。

**代码版本管理**

开发持续迭代，代码需要及时版本管理，无一例外，推荐使用 git 进行代码管理，那么代码是否托管在 Github 上呢？这个因读者喜好选择，你可以选择市面上其他同类的产品：gitlab, bitbucket 等，开源的产品当然优先选择 Github，有些企业对代码比较重视，内部会搭建类似的托管平台。

代码版本管理一个比较重要的环节的是分支管理、工作流程。

一般的工作流程是维护两个分支：master 和 dev 分支，master 是稳定的线上分支，dev 是开发分支，开发者协同开发，不断的从自己的分支上合入代码入 dev 分支，用于测试分支上线测试验证，待迭代结束，把开发者维护的分支合入主分支。

另外一个重点是 commit message 的编写，开发者最好约束一个规范，而不是随意的无意义的信息提交。

比如：

```
- feature:  功能代码
- fix: 修复代码
- release: 预发布代码
```

简单的说，规范很重要，具体怎么规范没有明确的要求，协同开发者们协商一致即可。

规范的好处是：统一。开发者按照一致的规范开发，后期维护、排查问题等极大的便利。

**持续集成 CI**

开源产品，持续集成选择 Github Action 足够了，读者可能会有疑问，持续集成内需要做些什么操作？

针对 Go 项目，一般来说持续集成，触发的动作有：代码规范（go vet）、代码规整化（go fmt）、单元测试（go test）、镜像编译（docker build）等环节。事实上，具体的步骤完全可以由开发者自己决定，这边列举的是笔者认为相对重要的环节。

这些环节的作用是保障新合入的代码正确可用。

如果自己本身没有什么思路，可以参考一些开源的思路：

- Awesome-actions: https://github.com/sdras/awesome-actions

**持续部署 CD**

读者需要积极拥抱容器思维，将自己编写的服务容器化，即使用 Docker 构建镜像，好处是维护开发环境的一致性，跨平台部署，非常方便。阅读开源项目，也经常会看到项目内托管的 Dockerfile 文件，这些文件的作用便是构建镜像的具体执行命令。

- Docker: https://www.docker.com/

**多组件部署**

应用或者服务容器化之后，如何部署？单节点部署其实很简单，在服务器上启动对应的容器即可，如果多组件，也可以使用 docker-compose 编排组件，进行部署，如果多节点部署组组件服务，这种情况下，比较流行的做法是 Kubernetes，幸运的是 docker, Kubernetes， etcd 等这些组件都是使用 Docker 编写的，在容器、编排领域经常需要 Go 开发工程师，所以云计算也是 Go 的一个非常重要的应用领域。k8s 是多组件、多节点部署的流行方案，读者遇到这种场景，可以选择这种方式编排部署容器，鉴于篇幅所限，本书不涉及 k8s 领域的知识。

**监控运维**

Prometheus也是一个近年比较火的开源监控框架，Prometheus灵活性，模块间比较解耦，比如告警模块、代理模块等等都可以选择性配置。服务端和客户端都是开箱即用，不需要进行安装。

Prometheus的界面看起来非常简单，所以我们还需要 Grafana 这个非常强大也是最常用的监控展示框架。

两种配合使用对运维监控，效果非常好。建议读者遇到监控运维场景，可以选择这种方案。

- Prometheus: https://prometheus.io/
- Grafana: https://grafana.com/



编程是个系统工程，涉及许许多多的环节，技术也不是孤立的，一个完备的系统，需要许多技术的结合。希望读者能从这些简单的路径描述中明确开发的整体过程。
