
日常开发中，我们会使用各种各样的客户端工具，比如容器技术 Docker 有客户端工具，使我们能够很友好的操作镜像、操作容器，再比如 Golang 也存在命令行工具，比如如何编译，运行程序等。再比如使用 kubectl 操作 kubernetes 集群资源。

服务器端多需要使用到 Linux 系统，整个 Linux 生态也更推荐在终端使用命令的形式。

在整个的实现业务需求的过程中，我们有必要从零开始实现一款命令行工作，这样我们对各类的命令行工具底层到底是在实现和操作些什么就能够更加的清晰、明了。

那么这些命令行是如何使用编程语言实现的呢？

本章我们就来讲述如何构造一款命令行工具。主要介绍了两大类，一类是使用 Golang 内置的库实现、另一类是使用优秀的第三方工具实现。从两者的比较过程中希望对你有所启发。



## 1. 优秀的命令行工具有哪些特点

我们需要实现一款命令行工具，那么首先我们应该需要熟悉一些优秀的命令行工具，了解他们有哪些特点，这样可以做到心中有数。



### 1.1 Docker

Docker 是一个开源的应用容器引擎，让开发者可以将开发的应用以及相关的依赖移植到容器内，在任意服务器上部署，可以将应用启动，大大减少了依赖，精简了开发流程，绝大数的互联网公司都拥抱容器技术，Docker 本身也是使用Go 开发的，成为Go 编程领域内一个明星级产品。

当然这里我们并不讲述容器技术，单纯从命令行界面，查看下优秀产品的命令行界面有哪些特点。

> 前提需要安装 docker

```
>> docker

Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default "/Users/xiewei/.docker")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default "/Users/xiewei/.docker/ca.pem")
      --tlscert string     Path to TLS certificate file (default "/Users/xiewei/.docker/cert.pem")
      --tlskey string      Path to TLS key file (default "/Users/xiewei/.docker/key.pem")
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  checkpoint  Manage checkpoints
  config      Manage Docker configs
  container   Manage containers
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  ...

```


终端输入 docker 命令, 可以得到docker 命令详情，包括：用法、可选参数、命令、命令说明等


执行命令，看看效果：

```
>> docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
golang                       latest              7e9ac7032e33        3 weeks ago         776MB
postgres                     latest              45e33d1af449        4 weeks ago         228MB
sonarqube                    latest              301e57279977        5 weeks ago         803MB
nginx                        latest              c82521676580        2 months ago        109MB
elasticsearch                latest              37ad37f1c8a7        2 months ago        486MB
redis                        latest              f06a5773f01e        2 months ago        83.4MB
alpine                       3.6                 da579b235e92        2 months ago        4.03MB
daocloud.io/library/golang   1.9-alpine3.6       ed119d8f7db5        12 months ago       270MB
java                         latest              d23bdf5b1b1b        20 months ago       643MB

```

终端输入 docker images, 可以查看到表格显示的响应。


```
>> docker version
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.3
 Git commit:        e68fc7a
 Built:             Tue Aug 21 17:21:31 2018
 OS/Arch:           darwin/amd64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.3
  Git commit:       e68fc7a
  Built:            Tue Aug 21 17:29:02 2018
  OS/Arch:          linux/amd64
  Experimental:     true

```

容器区分客户端和服务端，docker version 可以查看到客户端和服务端的信息。



上文的演示，基本上可以看出，命令行存在哪些功能？

- 命令回显：不管是 json 格式或者是表格显示
- 帮助提示：只有命令行支持的命令才会触发动作，现实中可能把命令输错的情况，这个时候应该引导用户编写正确的命令
- 子命令、可选参数：命令还支持参数和子命令，不同的动作，不同的效果


### 1.2 Go

Golang 本身也支持命令行工具，比如我们经常使用的编译、支持、下载第三方库等。

我们可以再看看 go 本身的命令行工具有哪些特点？

```
>> go 
Go is a tool for managing Go source code.

Usage:

	go <command> [arguments]

The commands are:

	bug         start a bug report
	build       compile packages and dependencies
	clean       remove object files and cached files
	doc         show documentation for package or symbol
	env         print Go environment information
	fix         update packages to use new APIs
	fmt         gofmt (reformat) package sources
	generate    generate Go files by processing source
	get         download and install packages and dependencies
	install     compile and install packages and dependencies
	list        list packages or modules
	mod         module maintenance
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.

Additional help topics:

	buildmode   build modes
	c           calling between Go and C
	cache       build and test caching
	...

```

```
>> go env
GO111MODULE=""
GOARCH="amd64"
GOBIN="/Users/xiewei/go/bin"
GOCACHE="/Users/xiewei/Library/Caches/go-build"
GOENV="/Users/xiewei/Library/Application Support/go/env"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
GOHOSTOS="darwin"
GONOPROXY=""
GONOSUMDB=""
GOOS="darwin"
GOPATH="/Users/xiewei/go"
GOPRIVATE=""
GOPROXY="https://mirrors.aliyun.com/goproxy/"
GOROOT="/usr/local/go"
GOSUMDB="off"
GOTMPDIR=""
GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"
GCCGO="gccgo"
AR="ar"
CC="clang"
CXX="clang++"
CGO_ENABLED="1"
GOMOD="/Users/xiewei/go/xiewei/go-anything/go.mod"
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"

```


```
>> go version
go version go1.13.4 darwin/amd64
```


对比两款命令行工具，我们可以看出一些共性。

- 都提供命令集合(终端输入 docker、go)
- 都有帮助提示
- 都有良好的回显提示
- ...


至此，可以给我一些启发，我们自己设计一款命令行工具，也应该需要支持这些特性，向优秀的产品的学习。


## 2. 命令行工具需要处理哪些内容


在第一节，从视觉上感受优秀命令行的一些特点：比如命令的组织、可选参数的组织、表格或者 json 显示等。这节探究下命令行工具到底什么情况下适用，以及需要处理哪些问题？

- 命令组织
- 参数读取
- 函数处理
- 其他：帮助提示


命令行工具本质上是接收参数(命令)，触发动作(函数处理)，如果需要处理动作之后返回结果，则再处理一步，将结果以 json 或者 表格的形式显示。


为说明方便，本节以 go 命令行，说明相关的概念。

- 应用：Application, 可以理解为命令行作用，比如docker, go 
- 命令：代表命令行的动作，比如 (docker)images 代表的操作镜像相关的动作、比如 (go) env 代表的操作 go 相关的环境变量
- 参数：比如 go build main.go 对 build 命令来说，参数就是 main.go , 当然参数可以多个，但构建优雅的命令行工具，简易参数不宜太多
- 标志位：代表命令动作的一些修饰，比如 go build -o gitcli main.go, `o` 表示标志位


了解了这些概念之后，构建命令行工具操作的基本内容就是这些概念。


## 3. Go 实现命令行的几种方式

上两节说明了优秀的命令行工具的一些基本特点、构建命令行工具的一些概念、以及需要处理的问题。

那转换到编程上，如何实现呢？本节将从四个方法上进行设计命令行工具，内置的 os、flag 和第三方 cobra、cli。整体是偏实践型，所以四个例子各有侧重，重点从方法论角度阐述。

- os： go 内置的提供操作系统的函数接口
- flag： go 内置的提供了一系列解析命令行参数的功能接口
- cobra：优秀的第三方命令行构建工具
- cli：优秀的第三方命令行构建工具



### 3.1 内置 os

内置的os库提供了操作系统的函数接口，比较常见的用法是文件 (os.Mkdir) 或者路径 (os.Getwd) 操作、或者读取环境变量 (os.GetEnv) 等操作。其实也可以用来保管命令行参数 (os.Args)。

用内置的os 库来进行命令行的工具的打造本质上就是读取命令行参数，进行函数封装操作。

值得一提的是 os.Args 是一个列表，且第一个参数 (索引为0) 是文件名，所以用户的输入参数，应该从索引为 1 的下标开始。

实例：为演示一个os.Args 读取命令行参数的用法，这边新建一个结构体userInfoOs 代表一个用户的信息，再结构化显示出来。



1. 新建一个结构体userInfoOs代表用户信息

```
type userInfoOs struct {
	File    string `json:"file"`
	Name    string `json:"name"`
	Email   string `json:"email"`
	Company string `json:"company"`
}

```

2. 读取命令行参数 json 序列化显示出来

```
func PrintCmdOs() {
	args := os.Args
	if len(args) != 4 {
		fmt.Println("you need add name,email,company field")
		return
	}
	var oneUserInfoOs userInfoOs
	oneUserInfoOs.File = os.Args[0]
	oneUserInfoOs.Name = os.Args[1]
	oneUserInfoOs.Email = os.Args[2]
	oneUserInfoOs.Company = os.Args[3]

	// json
	jsonByte, _ := json.MarshalIndent(oneUserInfoOs, " ", " ")
	fmt.Println(string(jsonByte))
}
```

3. main.go 函数

```
package main
func main(){
    PrintCmdOs()
}

```
4. 编译 `go build -o oscli main.go`
5. 终端输入参数: `./oscli xiewei xiewei@shu.edu.cn shangHai`

结构化显示：

```
{
  "file": "./oscli",
  "name": "xiewei",
  "email": "xiewei@shu.edu.cn",
  "company": "shangHai"
 }

```


上文一个简单的实例，将用户信息以 json 的形式显示在终端上，核心的处理是对命令行参数的读取之后，进行的函数操作(读取用户参数，赋值给定义的结构体，最后 json 序列化处理)

上文的实例存在什么问题？

>  用户参数变动顺序，就得不到想要的结果

```
# 示例

./oscli xiewei@shu.edu.cn shangHai xiewei
{
  "file": "./oscli",
  "name": "xiewei@shu.edu.cn",
  "email": "shangHai",
  "company": "xiewei"
 }

```

变动用户参数的顺序，几乎所有的结果都被打乱，得不到想要的结果，这就要求，使用这个命令行工具的人要熟悉参数的顺序，看上去不够友好，os 读取用户参数命令构建命令行工具只使用简单的应用场景，构建复杂的场景并不合适。


另外，想要构建一个帮助提示命令，可以使用 go 内置库的模版引擎 text/template 或者 html/template

上文使用模版引擎，可以这么做：

```
type userInfoOs struct {
	File    string `json:"file"`
	Name    string `json:"name"`
	Email   string `json:"email"`
	Company string `json:"company"`
}

// template
func (u *userInfoOs) Template() {
	t := template.New("New Template for book")
	t, _ = t.Parse(`
An example of os cli.

Show User Information by template:
	FileName: {{.File}}
	Name: {{.Name}}
	Email: {{.Email}}
	Company: {{.Company}}

Use "user help <topic>" for more information about that topic.
`)
	t.Execute(os.Stdout, u)
}

func PrintCmdOs() {
	args := os.Args
	if len(args) != 4 {
		fmt.Println("you need add name,email,company field")
		return
	}
	var oneUserInfoOs userInfoOs
	oneUserInfoOs.File = os.Args[0]
	oneUserInfoOs.Name = os.Args[1]
	oneUserInfoOs.Email = os.Args[2]
	oneUserInfoOs.Company = os.Args[3]

	// template
	//oneUserInfoOs.Template()
}

func main(){
    PrintCmdOs()
    
}

```

重新编译，终端输入命令：`./oscli xiewei xiewei@shu.edu.cn shangHai`

```
An example of os cli.

Show User Information by template:
	FileName: ./oscli
	Name: xiewei
	Email: xiewei@shu.edu.cn
	Company: shangHai

Use "user help <topic>" for more information about that topic.

```

模版引擎的原理是，构建静态数据和一些变量组成的模版，使用过程中渲染数据。这样可以复用静态代码。

- {{}}  表示的是渲染时需要替换的字段
- {{.}} 表示当前对象，{{.FieldName}} 表示当前对象的FieldName 字段
- 另外模版引擎还支持遍历、循环、条件判断、模版函数等功能


html/template 文档(https://godoc.org/html/template)


本节简单的演示了如何使用内置 os 构建简易的命令行工具。


### 3.2 内置 flag

除内置的 os 模块之外，go 内置的处理的命令行参数的库有 flag，且功能比 os 更强大。


内置的flag 主要有下面两种用法：

1. 预先定义变量

```
var species = flag.String("species", "gopher", "the species we are studying")

```

```
// 函数签名
func String(name string, value string, usage string) *string {
	return CommandLine.String(name, value, usage)
}
```

参数说明：

- name: "species"
- default value: "gopher"
- usage: "the species we are studying"


2. 无预先定义变量


```

const (
    defaultGopher = "pocket"
    usage         = "the variety of gopher"
)

flag.StringVar(&gopherType, "gopher_type", defaultGopher, usage)

```

```
// 函数签名
func StringVar(p *string, name string, value string, usage string) {
	CommandLine.Var(newStringValue(value, p), name, usage)
}
```


- point: "&gopherType"
- name: "gopher_type"
- default value: defaultGopher
- usage: usage


两者的区别在于入参，使用接收指针参数。

接着上节 os 读取参数的那节的实例，仍然定义一个存储用户的信息的结构体 userInfoFlag

1. 定义结构体 userInfoFlag

```
type userInfoFlag struct {
	Name    string `json:"name"`
	Url     string `json:"url"`
	Email   string `json:"email"`
	Company string `json:"company"`
}

```


2. 声明参数，flag 读取参数,及默认参数值的设置

```
var (
	name    string
	url     string
	email   string
	company string
)

func PrintCommandFlag() {

	flag.StringVar(&name, "n", "xieWei", "show user name")
	flag.StringVar(&url, "u", "https://www.baidu.com", "show user url")
	flag.StringVar(&email, "e", "wuxiaoshen@shu.edu.cn", "show user email")
	flag.StringVar(&company, "c", "ReadSense", "show user company")

	flag.Parse()

	var oneUser userInfoFlag
	oneUser.Name = name
	oneUser.Url = url
	oneUser.Email = email
	oneUser.Company = company
	jsonByte, _ := json.MarshalIndent(oneUser, " ", " ")
	fmt.Println(string(jsonByte))
}

```

3. main.go 函数调用

```
package main

func main(){
    PrintCommandFlag()
}

```

4. 编译: `go build -o flagcli main.go`
5. 执行：`./flagcli`

命令行无参数读取，则显示默认参数值。

```
{
  "name": "xieWei",
  "url": "https://www.baidu.com",
  "email": "wuxiaoshen@shu.edu.cn",
  "company": "ReadSense"
 }

```

`./flagcli -n XieWei -c ShangHai`

```
{
  "name": "XieWei",
  "url": "https://www.baidu.com",
  "email": "wuxiaoshen@shu.edu.cn",
  "company": "ShangHai"
 }

```

可以看到，flag 整体比 os 在读取命令行更友好，比如默认参数值的设置，比如无需顺序写入参数等。



下面我们使用 Github 公开的 API，制作一个查询任意用户的基本信息的命令行工具。

```
https://api.github.com/users/%s
```

目标：命令行输入任意用户名，查询是否匹配，匹配则返回用户信息，否则返回错误处理信息。

整个API 返回json 格式的响应。

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvkg5wc2rgj213w0k4dm0.jpg)

1. 定义响应的结构体

```
type GithubAccountInfo struct {
	Login             string `json:"login"`
	ID                int    `json:"id"`
	NodeId            string `json:"node_id"`
	AvatarUrl         string `json:"avatar_url"`
	GravatarId        string `json:"gravatar_id"`
	Url               string `json:"url"`
	HtmlUrl           string `json:"html_url"`
	FollowerURL       string `json:"follower_url"`
	FollowingURL      string `json:"following_url"`
	GistsURL          string `json:"gists_url"`
	StarredURL        string `json:"starred_url"`
	SubscriptionsURL  string `json:"subscriptions_url"`
	OrganizationsURL  string `json:"organizations_url"`
	ReposURL          string `json:"repos_url"`
	EventsURL         string `json:"events_url"`
	ReceivedEventsURL string `json:"received_events_url"`
	Type              string `json:"type"`
	SiteAdmin         bool   `json:"site_admin"`
	Name              string `json:"name"`
	Company           string `json:"company"`
	Blog              string `json:"blog"`
	Location          string `json:"location"`
	Email             string `json:"email"`
	Hireable          bool   `json:"hireable"`
	Bio               string `json:"bio"`
	PublicRepos       int    `json:"public_repos"`
	PublicGists       int    `json:"public_gists"`
	Followers         int    `json:"followers"`
	Following         int    `json:"following"`
	CreatedAt         string `json:"created_at"`
	UpdatedAt         string `json:"updated_at"`
}

```

2. 调用API 接口，处理响应

```
func GithubUserStorager(name string) GithubAccountInfo {

	url := fmt.Sprintf("https://api.github.com/users/%s", name)

    // 发起网络请求
	request, _ := http.NewRequest("GET", url, nil)
	request.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36")
	client := http.DefaultClient
	response, err := client.Do(request)
	if err != nil {
		fmt.Println(err)
		return GithubAccountInfo{}
	}
	
	defer response.Body.Close()
	
	// 解析数据
	result, err := ioutil.ReadAll(response.Body)
	fmt.Println(string([]byte(result)))
	var account GithubAccountInfo
	err = json.Unmarshal([]byte(result), &account)
	if err != nil {
		fmt.Println(err)
		return GithubAccountInfo{}
	}
	return account

}


```

3. 提供个命令查看所有响应的字段(使用 go 的反射机制，查看结构体的字段)

```
func GithubUserFields() {
	var fields []string
	account := GithubAccountInfo{}
	// 收集结构体所有字段
	s := reflect.TypeOf(&account).Elem()
	for i := 0; i < s.NumField(); i++ {
		fields = append(fields, s.Field(i).Name)
	}
	fieldsJson, _ := json.MarshalIndent(fields, " ", "")
	fmt.Println(string(fieldsJson))
}

```

4.  封装命令

```
func FlagHelper() {
	var Account string
	flag.StringVar(&Account, "a", "wuxiaoxiaoshen", "show github account user info fields")
	flag.Parse()
	// 如果 Account 输入是 field 返回结构体所有字段，否则返回用户信息
	if Account == "field" {
		cmdFlag.GithubUserFields()
		return
	} else {
		cmdFlag.GithubUserStorager(Account)
		return
	}
}

func main() {
   FlagHelper()

}

```
5. 编译 `go build -o gitcli main.go`
6. 执行命令 `./gitcli -a=field`

```json
// 查看支持的字段
[
 "Login",
 "ID",
 "NodeId",
 "AvatarUrl",
 "GravatarId",
 "Url",
 "HtmlUrl",
 "FollowerURL",
 "FollowingURL",
 "GistsURL",
 "StarredURL",
 "SubscriptionsURL",
 "OrganizationsURL",
 "ReposURL",
 "EventsURL",
 "ReceivedEventsURL",
 "Type",
 "SiteAdmin",
 "Name",
 "Company",
 "Blog",
 "Location",
 "Email",
 "Hireable",
 "Bio",
 "PublicRepos",
 "PublicGists",
 "Followers",
 "Following",
 "CreatedAt",
 "UpdatedAt"
 ]
```
7. 执行命令 `./gitcli -a=vczh`

```
{
  "login": "vczh",
  "id": 773569,
  "node_id": "MDQ6VXNlcjc3MzU2OQ==",
  "avatar_url": "https://avatars3.githubusercontent.com/u/773569?v=4",
  "gravatar_id": "",
  "url": "https://api.github.com/users/vczh",
  "html_url": "https://github.com/vczh",
  "followers_url": "https://api.github.com/users/vczh/followers",
  "following_url": "https://api.github.com/users/vczh/following{/other_user}",
  "gists_url": "https://api.github.com/users/vczh/gists{/gist_id}",
  "starred_url": "https://api.github.com/users/vczh/starred{/owner}{/repo}",
  "subscriptions_url": "https://api.github.com/users/vczh/subscriptions",
  "organizations_url": "https://api.github.com/users/vczh/orgs",
  "repos_url": "https://api.github.com/users/vczh/repos",
  "events_url": "https://api.github.com/users/vczh/events{/privacy}",
  "received_events_url": "https://api.github.com/users/vczh/received_events",
  "type": "User",
  "site_admin": false,
  "name": "Zihan Chen",
  "company": null,
  "blog": "http://www.gaclib.net",
  "location": "Seattle, WA, USA",
  "email": null,
  "hireable": null,
  "bio": "Main contributor of @vczh-libraries  .\r\n\r\nMicrosoft github account: https://github.com/ZihanChen-MSFT",
  "public_repos": 8,
  "public_gists": 9,
  "followers": 15147,
  "following": 9,
  "created_at": "2011-05-07T08:30:48Z",
  "updated_at": "2019-11-30T14:33:21Z"
}
```


这样我们就使用一个公开的 API 接口完成了一个简单的查询 Github 用户信息的命令行的工具。如果需要将整个命令行丰富起来，一方面，我们需要知道更多的 API 接口。比如你在公司或者学习中，最好能已知API, 构建命令行工具的任务就转变为调用 API, 再封装成输出即可。另一方面，如果没有已知的API, 那么需要我们自己构建 API。

下面的章节的两个例子，一个使用已知的 Github API 构建一个较完整的命令行工具 (gitcli)；另一个自己构建API，再在API 的基础之上构建一个较完整的命令行工具 (stackoverflowcli)。

构建较完整的命令行工具，在内置库的基础上，其实需要很多的开发量，为精简开发流程，使用较为成熟的第三方库构建命令行工具：cobra 和 cli。


### 3.3 第三方库 cobra 实现 gitcli



Github 是一个面向开源及私有软件项目的托管平台，面向开发者开放很多官方 API，通过这些API，开发者可以很容易的实现对 Github服务器上的资源的增删改查操作。同时 Github API 也是优秀的API 设计参考规范。

本节就是使用这些官方的 API，实现对用户信息、仓库信息、following、follower 等信息。当然对不同资源的操作，需要相应的权限。


#### 3.3.1 需求分析

Github 是开源软件项目的托管平台，既然是一个软件项目托管平台，那么核心资源有哪些？

- 用户(账户)信息: 主页、邮箱、公司、仓库数据等信息
- 仓库信息: star、follow、编程语言等
- 组织信息：Github 允许用户创建组织，组织内创建软件项目
- 搜索：使用API 根据匹配度返回仓库信息
- Trending: 热门项目趋势，当前时间段火热的开源项目
...


1. API 列表

```
var API = map[string]string{
	"current_user_url":                     "https://api.github.com/user",
	"current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}",
	"authorizations_url":                   "https://api.github.com/authorizations",
	"code_search_url":                      "https://api.github.com/search/code?q={query}{&page,per_page,sort,order}",
	"commit_search_url":                    "https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}",
	"emails_url":                           "https://api.github.com/user/emails",
	"emojis_url":                           "https://api.github.com/emojis",
	"events_url":                           "https://api.github.com/events",
	"feeds_url":                            "https://api.github.com/feeds",
	"followers_url":                        "https://api.github.com/user/followers",
	"following_url":                        "https://api.github.com/user/following{/target}",
	"gists_url":                            "https://api.github.com/gists{/gist_id}",
	"hub_url":                              "https://api.github.com/hub",
	"issue_search_url":                     "https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}",
	"issues_url":                           "https://api.github.com/issues",
	"keys_url":                             "https://api.github.com/user/keys",
	"notifications_url":                    "https://api.github.com/notifications",
	"organization_repositories_url":        "https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}",
	"public_gists_url":                     "https://api.github.com/gists/public",
	"rate_limit_url":                       "https://api.github.com/rate_limit",
	"repository_url":                       "https://api.github.com/repos/{owner}/{repo}",
	"current_user_repositories_url":        "https://api.github.com/user/repos{?type,page,per_page,sort}",
	"starred_url":                          "https://api.github.com/user/starred{/owner}{/repo}",
	"starred_gists_url":                    "https://api.github.com/gists/starred",
	"team_url":                             "https://api.github.com/teams",
	"user_organizations_url":               "https://api.github.com/user/orgs",
	"user_repositories_url":                "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}",
	"user_search_url":                      "https://api.github.com/search/users?q={query}{&page,per_page,sort,order}",

```


可以看出API 核心操作的资源是用户和仓库的信息。那么构建的命令行工具就是使用这些API 完成我们的需求，即查询用户信息、查询代码仓库信息、查询组织仓库信息、搜索指定仓库信息。



2. 组织命令行样式

组织命令行样式，表示的是最后的效果，我们希望出现哪些命令，为表示清晰，使用思维导图进行组织。

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvkvrbt96qj20ya0fpgne.jpg)

命令主要分这么几类：

- status  检测网络状态，若没有联网，无法从服务器上获取资源
- version 客户端(命令行的版本)
- user 指定账户的基本信息
- repos 指定账户的仓库的基本信息
- follower 指定账户的followers的账户信息
- search 搜索指定匹配名字的仓库的基本信息
- organization 指定组织的仓库的信息
- trend 获取近期热门的仓库的基本信息


3. 调用Github 提供的API 看是否满足我们的需求

可以在终端的使用 curl 调用相关的相关的API， 为实现我们自己的定义的需求(即上文的命令分类)，发现下面的API 即满足需求。


|command|API|Args|Example
|---|---|---|---|
|user|https://api.github.com/users/%s| 用户名称|./gitcli user wuxiaoxiaoshen|
|repos|https://api.github.com/repos/%s/%s| 用户名称，仓库名称|./gitcli repos wuxiaoxiaoshen DB|
|follower|https://api.github.com/users/%s/followers| 用户名称| ./gitcli follower wuxiaoxiaoshen|
|search|https://api.github.com/search/repositories?q=%s&page=%d&per_page=%d| 仓库名称、分页、每页数目|./gitcli search db|
|organization|https://api.github.com/orgs/%s/repos| 组织名称| ./gitcli organization GopherCoder|
|trend| 官方没有提供API|编程语言名称 |./gitcli trend python|


```
>> curl https://api.github.com/users/wuxiaoxiaoshen

{
  "login": "wuxiaoxiaoshen",
  "id": 11518873,
  "node_id": "MDQ6VXNlcjExNTE4ODcz",
  "avatar_url": "https://avatars2.githubusercontent.com/u/11518873?v=4",
  "gravatar_id": "",
  "url": "https://api.github.com/users/wuxiaoxiaoshen",
  "html_url": "https://github.com/wuxiaoxiaoshen",
  "followers_url": "https://api.github.com/users/wuxiaoxiaoshen/followers",
  "following_url": "https://api.github.com/users/wuxiaoxiaoshen/following{/other_user}",
  "gists_url": "https://api.github.com/users/wuxiaoxiaoshen/gists{/gist_id}",
  "starred_url": "https://api.github.com/users/wuxiaoxiaoshen/starred{/owner}{/repo}",
  "subscriptions_url": "https://api.github.com/users/wuxiaoxiaoshen/subscriptions",
  "organizations_url": "https://api.github.com/users/wuxiaoxiaoshen/orgs",
  "repos_url": "https://api.github.com/users/wuxiaoxiaoshen/repos",
  "events_url": "https://api.github.com/users/wuxiaoxiaoshen/events{/privacy}",
  "received_events_url": "https://api.github.com/users/wuxiaoxiaoshen/received_events",
  "type": "User",
  "site_admin": false,
  "name": "XieWei",
  "company": "SHU",
  "blog": "",
  "location": "Shanghai",
  "email": null,
  "hireable": true,
  "bio": null,
  "public_repos": 21,
  "public_gists": 0,
  "followers": 34,
  "following": 43,
  "created_at": "2015-03-17T10:16:33Z",
  "updated_at": "2018-09-10T23:26:43Z"
}
```


通过上文的分析和探索，做到心中有数，知道自己的实现整个任务的侧重点在哪？

- 组织命令
- 请求API，解析响应，得到我们需要的内容
- 动手构建 Trend 命令的API
- 结构化显示：json 或者 表格显示
- ...




#### 3.3.2 项目组织

一个结构清晰的项目组织结构，能够让整个的编码流程更为通畅，所以建议，一般维护一个稳定的项目结构(参考优秀的项目组织方式，比如 DDD 领域驱动设计)，在实现过程中不断的微调。

这边我们按照领域驱动设计的模式来，将整个的项目划分为：领域层（domain）、基础设施层（infrastructure）、用户界面层、应用层（application）。层与层之间的相互调用关系确定，逻辑清晰，避免循环调用。


```
├── application
│   ├── cmd_cobra
│   │   └── root_cmd_cobra.go
├── configs
│   └── token.go
├── domain
│   ├── followers_cmd.go
│   ├── organization_cmd.go
│   ├── repository_cmd.go
│   ├── serach_cmd.go
│   ├── trending_cmd.go
│   └── user_cmd.go
├── infrastructure
│   ├── api.go
│   ├── app.go
│   ├── errors
│   │   └── error.go
│   ├── help.go
│   ├── requests.go
├── main.go
└── vendor

```

- application 所有命令的集合
- domain 命令的具体实现
- infrastructure 基础设施层，提供上层服务，比如 api、request 请求、错误处理信息等
- vendor 第三方库
- main.go 函数入口


#### 3.3.3 编码实现

1. 安装第三方库


```
go get -u github.com/spf13/cobra/cobra

```

2. 基本使用

```
var rootCmd = &cobra.Command{
  Use:   "hugo",
  Short: "Hugo is a very fast static site generator",
  Long: `A Fast and Flexible Static Site Generator built with
                love by spf13 and friends in Go.
                Complete documentation is available at http://hugo.spf13.com`,
  Run: func(cmd *cobra.Command, args []string) {
    // Do Stuff Here
  },
}

func Execute() {
  if err := rootCmd.Execute(); err != nil {
    fmt.Println(err)
    os.Exit(1)
  }
}

func main() {
  Execute()
}

```

- 使用这个第三方库的核心是实现 cobra.Command 这个结构体，这个结构体存在一系列的处理参数、设置等方法。真正的实现是结构体的 Run 方法。

- 各命令的组织方式如何实现：使用 AddCommand 方法，比如 rootCmd.AddCommand(versionCmd)，则 versionCmd 是 rootCmd 的子命令

3. 编码实现

基本动作相似，这边以 user 和 trend 两个命令为例，讲述代码的编写方法。

**user 命令逻辑编码实现**

- 基础设施：请求 API

```
// 本质是一个发起网络请求的过程
// infrastructure/requests.go
// GetResponseNetHttp ...
func GetResponseNetHttp(url string) ([]byte, error) {
	request, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, &errors.ErrorCmdRequest
	}
	request.Header.Add("Authorization", "Basic "+configs.PassWord)
	client := http.DefaultClient
	response, err := client.Do(request)
	if err != nil {
		return nil, &errors.ErrorCmdResponse

	}

	defer response.Body.Close()

	return ioutil.ReadAll(response.Body)
}

```
鉴于 Github API 对没认证用户存在限制调用的次数的问题，可以使用认证模式，即 configs.PassWord，具体的值由下列函数获取得到。

```
func BasicAuthTokenEncode(username string, password string) string {
	data := []byte(fmt.Sprintf("%s:%s", username, password))
	return base64.StdEncoding.EncodeToString(data)
}

```

- API 配置

```
// infrastructure/api.go

var API = map[string]string{
	// userCommand
	"user_url": "https://api.github.com/users/%s",

	// repoCommand
	"repo_url":        "https://api.github.com/users/%s/repos",
	"repo_single_url": "https://api.github.com/repos/%s/%s",

	// followerCommand
	"user_follower_url": "https://api.github.com/users/%s/followers",

	// searchCommand
	"repository_search_url": "https://api.github.com/search/repositories?q=%s&page=%d&per_page=%d",

	// organizationCommand
	"organization_url":      "https://api.github.com/orgs/%s",
	"organization_repo_url": "https://api.github.com/orgs/%s/repos",

	// trendingCommand
	"trending_url": "https://github.com/trending/%s?since=%s",
}

```

- user 命令处理逻辑编写

```
// domain/user_cmd.go


package domain

import (
	"encoding/json"
	"fmt"
	"gitcli/infrastructure"

	"github.com/alexeyco/simpletable"

	"github.com/tidwall/gjson"

	"github.com/spf13/cobra"
)

type Info struct {
	Field  string `json:"field"`
	Result string `json:"result"`
}

// UserCmd ...
var UserCmd = &cobra.Command{
	Use:     "user",
	Aliases: []string{"u"},
	Short:   "show user information",
	Long: `information contains username、url、
			html_url、name、company、location、
			public_repos、followers、following、created_at、updated_at`,
	Args: cobra.MinimumNArgs(1),
	Run:  UserCommand,
}

// UserCommand ...
func UserCommand(cmd *cobra.Command, args []string) {

	if len(args) <= 1 {
		fmt.Println(fmt.Sprintf("try %s --help", cmd.Use))
		return
	}

    // 查询字段
	if args[0] == "fields" {
		var fields = []string{"url", "login", "location", "created_at", "updated_at", "followers", "following", "public_repos",
			"bio", "email", "company"}
		jsonByte, _ := json.MarshalIndent(fields, " ", " ")
		fmt.Println(string(jsonByte))
		return
	}

	url := fmt.Sprintf(infrastructure.API["user_url"], args[0])
    
    // 获取用户响应信息
	response, _ := infrastructure.GetResponseNetHttp(url)
	responseResult := gjson.ParseBytes(response)

	if args[1] == "all" {
		jsonByte, _ := json.MarshalIndent(responseResult.Raw, " ", " ")
		fmt.Println(string(jsonByte))
		return
	}
	//fmt.Println(args)
	if len(args) <= 2 {
		fmt.Println("Should add one more argument")
		return
	}

	if args[1] != "all" && args[2] == "json" {

		infoField := showUserField(args[1], responseResult.Get(args[1]))
		if infoField.Result == "" {
			infoField.Result = "None"
		}
		showUserInfoJson(infoField)
		return
	}
	if args[1] != "all" && args[2] == "table" {
		infoField := showUserField(args[1], responseResult.Get(args[1]))
		showUserInfoTable(infoField)
		return
	}

}

// showUserInfoJson ...
func showUserInfoJson(info *Info) {
	jsonByte, _ := json.MarshalIndent(info, " ", " ")
	fmt.Println(string(jsonByte))

}

// showUserInfoTable ...
func showUserInfoTable(info *Info) {
	table := simpletable.New()
	table.Header = &simpletable.Header{
		Cells: []*simpletable.Cell{
			{Align: simpletable.AlignCenter, Text: "FIELD"},
			{Align: simpletable.AlignCenter, Text: "VALUE"},
		},
	}
	r := []*simpletable.Cell{
		{Align: simpletable.AlignLeft, Text: fmt.Sprintf("%s", info.Field)},
		{Align: simpletable.AlignLeft, Text: info.Result},
	}
	table.Body.Cells = append(table.Body.Cells, r)
	table.SetStyle(simpletable.StyleCompactLite)
	fmt.Println(table.String())

}

// showUserField ...
func showUserField(field string, result gjson.Result) *Info {
	return &Info{
		Field:  field,
		Result: result.Raw,
	}

}


```

- Info 结构体：包含字段名称和结果（整体返回用户信息，字段过多，这边根据字段名称返回用户的该字段的值）
- UserCmd：子命令的入口，Use: 表示命令名称，Short、Long 可以写些命令的介绍，Run：是函数的主体处理逻辑
- UserCommand: 根据请求的参数args []string，返回所有用户支持的字段、以 json 或者 表格形式返回结果
- showUserInfoJson：将结果以 json 格式返回
- showUserInfoTable：将结果以 table 格式返回
- showUserField： API 返回的结果是 json 格式，通过这个函数可以获取json 内指定字段的值


```
>> curl https://api.github.com/users/wuxiaoxiaoshen

{
  "login": "wuxiaoxiaoshen",
  "id": 11518873,
  "node_id": "MDQ6VXNlcjExNTE4ODcz",
  "avatar_url": "https://avatars2.githubusercontent.com/u/11518873?v=4",
  "gravatar_id": "",
  "url": "https://api.github.com/users/wuxiaoxiaoshen",
  "html_url": "https://github.com/wuxiaoxiaoshen",
  "followers_url": "https://api.github.com/users/wuxiaoxiaoshen/followers",
  "following_url": "https://api.github.com/users/wuxiaoxiaoshen/following{/other_user}",
  "gists_url": "https://api.github.com/users/wuxiaoxiaoshen/gists{/gist_id}",
  "starred_url": "https://api.github.com/users/wuxiaoxiaoshen/starred{/owner}{/repo}",
  "subscriptions_url": "https://api.github.com/users/wuxiaoxiaoshen/subscriptions",
  "organizations_url": "https://api.github.com/users/wuxiaoxiaoshen/orgs",
  "repos_url": "https://api.github.com/users/wuxiaoxiaoshen/repos",
  "events_url": "https://api.github.com/users/wuxiaoxiaoshen/events{/privacy}",
  "received_events_url": "https://api.github.com/users/wuxiaoxiaoshen/received_events",
  "type": "User",
  "site_admin": false,
  "name": "XieWei",
  "company": "SHU",
  "blog": "",
  "location": "Shanghai",
  "email": null,
  "hireable": true,
  "bio": null,
  "public_repos": 21,
  "public_gists": 0,
  "followers": 34,
  "following": 43,
  "created_at": "2015-03-17T10:16:33Z",
  "updated_at": "2018-09-10T23:26:43Z"
}

```

这个 json 格式的响应，如果使用原生的 json 进行处理，需要定义一个字段和类型完成相对应的结构体。

```
type Info struct{
    Login string `json:"login"`
    ID int `json:"id"`
    ...
    SiteAdmin bool `json:"site_admin"`
    ...
    Followers int `json:"followers"`
    ...
}

```

所以借用了一个更优雅的解析json 的方案：gjson

比如需要获取API 响应的 following 字段的值，可以如下操作，整体实现更为优雅。

```
	responseResult := gjson.ParseBytes(response)
	responseResult.Get("following").Raw

```

- 主命令逻辑编写

```
// application/cmd_cobra/root_cmd_cobra.go
package cmdCobra

import (
	"fmt"
	"github.com/wuxiaoxiaoshen/gitcli/domain"
	"github.com/wuxiaoxiaoshen/gitcli/infrastructure"
	"os"

	"github.com/spf13/cobra"
)

var (
	version = infrastructure.Version
	cliName = infrastructure.ApplicationCmdName
)

// RootCmd ...
var RootCmd = &cobra.Command{
	Use:  cliName,
	Args: cobra.ExactArgs(0),
	Run:  printCliName,
}

// printCliName
func printCliName(cmd *cobra.Command, args []string) {
	if len(args) > 0 {
		fmt.Println(fmt.Sprintf("try %s --help", cmd.Use))
		return
	}
	fmt.Println(fmt.Sprintf("%s is an application for operation github.\n", cliName))
}

// Execute ...
func Execute() {

	// user command
	RootCmd.AddCommand(domain.UserCmd)

	if err := RootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
```


- main.go 函数入口

```

package main

import (
	"flag"
	"github.com/wuxiaoxiaoshen/gitcli/application/cmd_cobra"
)

func CobraHelper() {
	cmdCobra.Execute()
}

func main() {

	CobraHelper()
}
```


效果展示：

- 获取所有字段

```
>> ./gitcli user fields
[
  "url",
  "login",
  "location",
  "created_at",
  "updated_at",
  "followers",
  "following",
  "public_repos",
  "bio",
  "email",
  "company"
 ]

```

- 获取用户 url 字段的具体值

```
>> ./gitcli user wuxiaoxiaoshen url json
{
  "field": "url",
  "result": "\"https://api.github.com/users/wuxiaoxiaoshen\""
 }

>> ./gitcli user wuxiaoxiaoshen url table
 FIELD                       VALUE
------- -----------------------------------------------
 url     "https://api.github.com/users/wuxiaoxiaoshen"
```





**trend 命令逻辑编码实现**

Github API (https://developer.github.com/) 官网的API 集合中，并没有提供这个接口，只能通过 https://github.com/trending 网址访问。所以这个命令和之前命令不同的点在于需要构建 API 才能获取到服务器上的资源。这里选择的方法是：爬虫

- 定义内容结构体

```
// domain/trending_cmd.go

type trendingRepo struct {
	Name        string `json:"name"`
	TotalStar   string `json:"total_star"`
	SinceStar   string `json:"since_star"`
	Fork        string `json:"fork"`
	Description string `json:"description"`
	Language    string `json:"language"`
	Url         string `json:"url"`
}
```

- 使用 CSS 选择器获取相应字段内容

```
// domain/trending_cmd.go
// url: https://github.com/trending/go?since=daily

func getTrendingRepos(url string) []trendingRepo {

	var languagePattern string
	languagePattern = `trending/(.*?)\?`
	languageRegexp := regexp.MustCompile(languagePattern)
	allMatch := languageRegexp.FindAllStringSubmatch(url, -1)
	var trendingRepos []trendingRepo

	response, _ := infrastructure.GetResponseNetHttp(url)
	responseByte := bytes.NewReader(response)
	doc, _ := goquery.NewDocumentFromReader(responseByte)
	doc.Find("article.Box-row").Each(func(i int, selection *goquery.Selection) {
		name := strings.TrimSpace(selection.Find("h1 a").Text())
		newReplacer := strings.NewReplacer(" ", "", "\n", "", "\t", "")
		newName := newReplacer.Replace(name)

		description := strings.TrimSpace(selection.Find("p").Text())

		number := selection.Find("div").Eq(1)

		totalStar := strings.TrimSpace(number.Find("a").Eq(0).Text())

		fork := strings.TrimSpace(number.Find("a").Eq(1).Text())

		sinceStar := strings.TrimSpace(number.Find("span").Last().Text())

		pattern := "(.*?)stars"
		regexpPattern := regexp.MustCompile(pattern)
		all := regexpPattern.FindAllStringSubmatch(sinceStar, -1)
		var sinceNumber string
		for _, one := range all {
			sinceNumber = strings.TrimSpace(one[1])
		}

		var oneTrendingRepo trendingRepo
		oneTrendingRepo = trendingRepo{
			Name:        newName,
			Description: description,
			TotalStar:   totalStar,
			Fork:        fork,
			SinceStar:   sinceNumber,
			Language:    allMatch[0][1],
			Url:         "https://github.com/" + newName,
		}
		trendingRepos = append(trendingRepos, oneTrendingRepo)
	})
	return trendingRepos
}

```

![githubtrending.png](http://ww1.sinaimg.cn/large/741fdb86gy1g9qls4quj5j213y0ltzuj.jpg)

- 完善 trend 命令和结果展示

```
// domain/trending_cmd.go

var TrendingCmd = &cobra.Command{
	Use:   "trend",
	Short: "show github trending by language",
	Long:  "show github trending by language , period , and date, get more detail information",
	Run:   trendingCommand,
}

func trendingCommand(cmd *cobra.Command, args []string) {

	var url string
	url = makeTrendingUrl(args)
	if url == "None" {
		return
	}
	var trendingRepoInfo []trendingRepo
	trendingRepoInfo = getTrendingRepos(url)

	if args[len(args)-1] == "json" {
		showTrendingRepoByJson(trendingRepoInfo)
	}

	if args[len(args)-1] == "table" {
		showTrendingRepoByTable(trendingRepoInfo)
	}

}

func showTrendingRepoByJson(trendingRepos []trendingRepo) {
	jsonByte, _ := json.MarshalIndent(trendingRepos, " ", " ")
	fmt.Println(string(jsonByte))
}

func showTrendingRepoByTable(trendingRepos []trendingRepo) {
	table := simpletable.New()
	headers := []string{"name", "star", "now_star", "fork", "language", "url"}
	var cells []*simpletable.Cell

	for _, header := range headers {
		cell := &simpletable.Cell{
			Align: simpletable.AlignLeft, Text: strings.ToUpper(header),
		}
		cells = append(cells, cell)
	}
	table.Header = &simpletable.Header{
		Cells: cells,
	}
	for _, item := range trendingRepos {
		r := []*simpletable.Cell{
			{Align: simpletable.AlignLeft, Text: item.Name},
			{Align: simpletable.AlignLeft, Text: item.TotalStar},
			{Align: simpletable.AlignLeft, Text: item.SinceStar},
			{Align: simpletable.AlignLeft, Text: item.Fork},
			{Align: simpletable.AlignLeft, Text: item.Language},
			{Align: simpletable.AlignLeft, Text: item.Url},
		}
		table.Body.Cells = append(table.Body.Cells, r)
	}
	table.SetStyle(simpletable.StyleCompactLite)
	fmt.Println(table.String())
}

func makeTrendingUrl(args []string) string {
	var url string
	if len(args) < 1 {
		fmt.Println("you should at least add one argument")
		url = "None"
	} else if len(args) == 1 {
		url = fmt.Sprintf(infrastructure.API["trending_url"], strings.ToLower(args[0]), "daily")
	} else {
		url = fmt.Sprintf(infrastructure.API["trending_url"], strings.ToLower(args[0]), args[1])
	}
	return url
}

```

- 添加到主命令下

```
// application/cmd_cobra/root_cmd_cobra.go

func Execute() {


	// user command
	RootCmd.AddCommand(domain.UserCmd)

	// trending command
	RootCmd.AddCommand(domain.TrendingCmd)

	if err := RootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

```

效果展示：

- 获取 go 语言的热门项目

```
>> ./gitcli trend go json
[
  {
   "name": "rclone/rclone",
   "total_star": "17,206",
   "since_star": "12",
   "fork": "1,363",
   "description": "\"rsync for cloud storage\" - Google Drive, Amazon Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Cloudfiles, Google Cloud Storage, Yandex Files",
   "language": "go",
   "url": "https://github.com/rclone/rclone"
  },
  {
   "name": "getlantern/lantern",
   "total_star": "172",
   "since_star": "19",
   "fork": "10,044",
   "description": "Lantern官方版本 *** lantern censorship-circumvention censorship gfw vpn accelerator",
   "language": "go",
   "url": "https://github.com/getlantern/lantern"
  }
  ...//省略
]


>> ./gitcli trend go table

 NAME                                   STAR     NOW_STAR   FORK     LANGUAGE   URL
-------------------------------------- -------- ---------- -------- ---------- ---------------------------------------------------------
 rclone/rclone                          17,206   12         1,363    go         https://github.com/rclone/rclone
 getlantern/lantern                     172      19         10,044   go         https://github.com/getlantern/lantern
 v2ray/v2ray-core                       25,300   37         5,717    go         https://github.com/v2ray/v2ray-core
 lightningnetwork/lnd                   4,269    10         1,195    go         https://github.com/lightningnetwork/lnd
 gohugoio/hugo                          39,973   19         4,509    go         https://github.com/gohugoio/hugo
 go-gitea/gitea                         17,378   30         1,979    go         https://github.com/go-gitea/gitea
 txthinking/brook                       10,666   7          2,027    go         https://github.com/txthinking/brook
 adonovan/gopl.io                       3,746    4          1,471    go         https://github.com/adonovan/gopl.io
 dgrijalva/jwt-go                       6,665    8          626      go         https://github.com/dgrijalva/jwt-go
 GoesToEleven/golang-web-dev            1,907    3          915      go         https://github.com/GoesToEleven/golang-web-dev
 iikira/BaiduPCS-Go                     18,668   45         2,837    go         https://github.com/iikira/BaiduPCS-Go
 michenriksen/gitrob                    4,199    5          590      go         https://github.com/michenriksen/gitrob
 Dreamacro/clash                        4,878    38         656      go         https://github.com/Dreamacro/clash
 tinygo-org/tinygo                      5,013    18         217      go         https://github.com/tinygo-org/tinygo
 xtaci/kcptun                           11,254   10         2,191    go         https://github.com/xtaci/kcptun
 go-telegram-bot-api/telegram-bot-api   1,806    2          308      go         https://github.com/go-telegram-bot-api/telegram-bot-api
 ipfs/go-ipfs                           9,041    43         1,639    go         https://github.com/ipfs/go-ipfs
 cockroachdb/cockroach                  17,457   5          2,012    go         https://github.com/cockroachdb/cockroach
 fyne-io/fyne                           7,042    10         290      go         https://github.com/fyne-io/fyne
 pkg/errors                             5,320    3          379      go         https://github.com/pkg/errors
 bxcodec/go-clean-arch                  1,950    9          339      go         https://github.com/bxcodec/go-clean-arch
 projectdiscovery/subfinder             1,944    100        239      go         https://github.com/projectdiscovery/subfinder
 open-telemetry/opentelemetry-go        357      3          82       go         https://github.com/open-telemetry/opentelemetry-go
 miekg/dns                              4,148    6          684      go         https://github.com/miekg/dns
 haccer/subjack                         745      11         123      go         https://github.com/haccer/subjack
```

> 注：热门项目实时排行，数据有可能不一致，再者 API 或者 网页改版都可能引起上文代码执行失效。读者需要把握整体思想，而不是具体代码

其他的命令可以根据上文的组织方式一一实现，具体的流程如下：

- 构建内容的结构体，比如用户信息，仓库信息等
- 实现API 调用获取到定义的结构体内容
- 组织命令显示方式：json 或者 表格
- 组织到主命令下



#### 3.3.4 显示

经过上文的讲解，加上提供的源代码(https://github.com/GopherCoder/gitcli)，相信大家能够完善这样一款操作 GitHub 资源的命令行工具。

最终效果如下：

```
>> ./gitcli --help
Usage:
  gitcli [flags]
  gitcli [command]

Available Commands:
  follower     show user follower info
  help         Help about any command
  organization show organization info
  repos        show user repository
  search       search repository from github
  status       show network status
  trend        show github trending by language
  user         show user information
  version      show application version

Flags:
  -h, --help   help for gitcli

Use "gitcli [command] --help" for more information about a command.

```

支持命令和子命令，命令的组织和显示方式根据参数的不同，显示不同，提供帮助命令。


示例代码：https://github.com/GopherCoder/gitcli


### 3.4 第三方库 cli 实现 stackoverflowCli

命令行工具 gitcli 的实现主要是使用现成的 Github 官方的 API，如果对方服务器没有提供 API，就像我们之前说的，需要自己构建 API，得到服务器上特定的资源，通常的方法是：爬取。获取到对方服务器资源，再进行相应的命令的组织、展示的组织等。当然构建自己应用的命令行工具，最好提供一套对应的获取服务器资源的 API。

本环节在没有服务器 API 的情况下使用另一个优秀的第三方命令行工具构建符合自己要求的命令行工具。

- 下载安装

```
go get -u -v github.com/urfave/cli
```


#### 3.4.1 需求分析

Stack Overflow 是一个和技术相关的技术问题网站，相信作为程序员，很多的问题的答案都可以在上面找到，上面有一些很优秀的回答，相信对程序员很有启发，所以萌发了制作一款命令行工具。主要是搜索问题，返回相关的问题的搜索答案，同时该网站还提供一些统计数据，比如某些关键词的标签次数，还提供了一些岗位的信息，这些都可以用来完善我们整个的命令行工具。

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvl0xv6tqej213w0isncz.jpg)


所以我们定义该命令行工具这些命令：

- user 用户的信息
- job 岗位的相关信息
- tag 标签的相关信息
- question 搜索问题匹配到的相关问题和答案


定义该款命令行工具名称为：stackoverflowcli

各资源的相关的网址：

|Command|SubCommand|URL|
|---|---|---|
|user|reputation|https://stackoverflow.com/users?tab=reputation|
|user|newUser|https://stackoverflow.com/users?tab=newusers|
|user|voters|https://stackoverflow.com/users?tab=voters|
|user|editors|https://stackoverflow.com/users?tab=editors|
|user|moderators|https://stackoverflow.com/users?tab=moderators|
|tag| |https://stackoverflow.com/tags|
|job| |https://stackoverflow.com/jobs?med=site-ui&ref=jobs-tab|
|search| | https://stackoverflow.com/search?q=%s|



#### 3.4.2 项目组织

参照之前的思路，项目需要一个逻辑清晰的项目工程目录。按照领域驱动设计的思路，将整个项目划分为领域层domain、基础设施层infrastructure、用户界面层userinterface、应用层 application

参考：

```
│   ├── domain
│   │   ├── model
│   │   │   ├── job.go
│   │   │   ├── question.go
│   │   │   ├── tag.go
│   │   │   └── user.go
│   │   └── repository
│   │       └── repository.go
│   ├── infrastructure
│   │   ├── api.go
│   │   ├── downloader.go
│   │   ├── errors
│   │   │   └── error.go
│   │   └── marshal.go
│   └── userInterface
│       ├── editors.go
│       ├── job.go
│       ├── job.html
│       ├── moderators.go
│       ├── question.go
│       ├── reputation.go
│       ├── tags.go
│       ├── userNew.go
│       ├── voters.go
├── cmd
│   └── stackOverFlowCli
│       ├── main.go
└── vendor
```

和之前的稍有差异，这边进行解释下：

- domain 层：领域层，model 定义领域内的信息，就本章而言，就是那些 user、job、tag、question等；repository 定义接口即一系列方法的集合；
- infrastructure 层：基础设施层，api 即 url 集合；downloader 即获取网页源代码；error 即错误处理
- userInterface 层：用户界面，即领域内信息的具体体现
- cmd 主函数入口
- vendor 第三方库集合



#### 3.4.3 编码实现

在明确了具体的需求：获取 stackoverflow 上的指定资源的信息，形成 API，使用命令行的形式获取网站上的信息。

这里以 job 和 question 的资源的编码实现为例，其他的命令可以参照着实现。

1. 定义 job model: 即需要的 job 实体字段是什么，字段的定义都是参考网页上的字段。



```
// app/domain/model/job.go

package model

type Job struct {
	Title   string `json:"title"`
	Company string `json:"company"`
	Tags    string `json:"tags"`
	Salary  string `json:"salary"`
	Date    string `json:"date"`
}

```

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvohyjv5rgj213v0k2jwk.jpg)


其他定义，比如定义 JobResult 表示 Job 的集合。

```
type JobResults []Job

func NewJob(
	title string,
	company string,
	tags string,
	salary string,
	date string) *Job {
	return &Job{
		Title:   title,
		Company: company,
		Tags:    tags,
		Salary:  salary,
		Date:    date,
	}
}

func (j *Job) JobField(tag string) interface{} {
	value := reflect.ValueOf(&j)
	return value.FieldByName(tag)
}
```

2. 定义接口：方法的集合，所有的资源都存在 FindAll 和 Single 方法，分别返回多个或者一个结果。

```
// app/domain/repository/repository.go

package repository

type StackOverFlowRepository interface {
	FindAll(url string) (interface{}, error)
	Single(url string, number int) (interface{}, error)
}


```

3. 基础设施层，获取网页源代码

```
// app/infrastructure/downloader.go
package infrastructure

import (
	"io/ioutil"

	"github.com/parnurzeal/gorequest"
)

// 发起网络请求获取响应
func ResponseStorager(url string) ([]byte, error) {
	request := gorequest.New()
	response, _, _ := request.Get(url).End()
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

```

4. 用户界面层，负责具体 job 的实现，具体实现之前接口层定义的 FindAll 和 Single 方法，使用 CSS 选择器获取网页源代码上的资源

```
package userInterface

import (
	"bytes"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/domain/model"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/infrastructure"
	"strings"

	"github.com/PuerkitoBio/goquery"
)

type Job struct {
	model.Job
}

type JobResult []Job

func (j *Job) FindAll(url string) (interface{}, error) {
	response, _ := infrastructure.ResponseStorager(url)

	//fmt.Println(string([]byte(response)))

	var jobResult JobResult
	doc, _ := goquery.NewDocumentFromReader(bytes.NewReader(response))

	doc.Find("div.listResults div div.-job-summary").Each(func(i int, selection *goquery.Selection) {
		jobTitle := selection.Find("div h2  a").Text()
		jobDate := selection.Find("div.-title span").Last().Text()
		var jobDescription string
		selection.Find("div").Eq(1).Find("span").Each(func(i int, selection1 *goquery.Selection) {
			temp := strings.TrimSpace(selection1.Text())
			newTemp := strings.Replace(temp, "\n", "", -1)
			jobDescription += " " + newTemp

		})

		var jobSalary string
		selection.Find("div").Eq(2).Find("span").Each(func(i int, selection2 *goquery.Selection) {

			temp := strings.TrimSpace(selection2.Text())
			newTemp := strings.Replace(temp, "\n", "", -1)
			jobSalary += " " + newTemp

		})

		var jobTags string
		selection.Find("div").Last().Find("a").Each(func(i int, selection3 *goquery.Selection) {
			jobTags += " " + strings.TrimSpace(selection3.Text())

		})
		//fmt.Println("title", jobTitle, "date", jobDate, "description", jobDescription, "salary", jobSalary, "tags", jobTags)
		if i < 10 || len(jobResult) >= 10 {
			oneJob := Job{
				*model.NewJob(jobTitle,
					jobDate,
					jobTags,
					jobSalary,
					jobDescription),
			}
			jobResult = append(jobResult, oneJob)

		}

	})
	infrastructure.Marshal(jobResult)
	return nil, nil
}

func (j *Job) Single(url string, number int) (interface{}, error) {
	return nil, nil
}


```

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvoja8tolij213u0k0jzr.jpg)

5. 命令的组织，在这一阶段，即将之前实现的逻辑进行进一步的使用框架进行组织

```
// cmd/stackoverflowcli/main.go

package main

import (
	"fmt"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/domain/repository"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/infrastructure"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/userInterface"
	"log"
	"os"

	"github.com/urfave/cli"
)

func main() {
	app := cli.NewApp()
	app.Name = "stackoverflowcli"
	app.Usage = "An application for stackoverflow web site"
	app.Action = func(c *cli.Context) error {
		fmt.Println("boom! I say!")
		return nil
	}
	app.CommandNotFound = func(context *cli.Context, s string) {
		fmt.Println("command not found")
	}
	app.Commands = commandStorager()

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}

func commandStorager() []cli.Command {
	return []cli.Command{

		{
			Name:        "job",
			Usage:       "Job Commands",
			Subcommands: jobSubCommand(),
		},

	}
}

func userSubCommand() []cli.Command {
	return []cli.Command{}

}
func jobSubCommand() []cli.Command {
	return []cli.Command{
		{
			Name:    "get",
			Aliases: []string{"g"},
			Usage:   "Show stackoverflow jobs",
			Action: func(c *cli.Context) {
				var repo repository.StackOverFlowRepository
				var job uerInterface.Job
				repo = &job
				repo.FindAll(infrastructure.API["jobs"])
			},
		},
	}

}
func tagSubCommand() []cli.Command {
	return []cli.Command{}

}
func questionSubCommand() []cli.Command {
	return []cli.Command{}

}


```

即是在实现cli.Command 结构体，该结构体 Name、Aliases、Action 等字段或方法，具体的是将之前的业务实现的逻辑函数调用放置在 Action 内。

比如 Job 结构体的FindAll 方法，放置在 Action 内。

```
var repo repository.StackOverFlowRepository //  声明接口类型
var job uerInterface.Job // 声明结构体类型
repo = &job // 将结构体类型赋值给接口类型
repo.FindAll(infrastructure.API["jobs"]) //  调用接口类型的方法

```

上文实现的命令job，子命令为 get

6. 编译 `go build -o stackoverflowcli main.go`
7. 执行命令：`./stackoverflowcli job get`

```
[
  {
   "title": "Frontend Engineer",
   "company": "1h ago",
   "tags": " python reactjs javascript",
   "salary": "",
   "date": " Tessian - London, UK"
  },
  {
   "title": "FULLSTACK DEVELOPER - REACT",
   "company": "\u003c 1h ago",
   "tags": "",
   "salary": "",
   "date": " ALTEN TIC - Barcelona, Spain"
  },
  {
   "title": "JAVA　or　JAVASCRIPT　or　Web系　画面系(SE,PG)　10名募集",
   "company": "6h ago",
   "tags": " java javascript java-ee",
   "salary": "",
   "date": " カルク - Shinagawa City, Japan"
  },
    ... // 省略
  {
   "title": "システム維持管理/構築運用案件",
   "company": "6h ago",
   "tags": " reactjs ruby ruby-on-rails",
   "salary": "",
   "date": " レバテック株式会社 - Chiyoda City, Japan"
  }
 ]

```


上文即实现了 job 命令，那如何实现 question 命令呢？question 命令和 job 有哪些不同呢？

本质上是一样的，具体实现起来存在这些不同。

- 定义 model/question.go 不同，毕竟网页上资源不同
- FindAll  方法不同，即获取网页上资源的 CSS 选择器不同


下文实现 question 命令。

1. 定义 question model: 即想要获取网页端 question 的哪些资源

```
// app/domain/model/question.go

package model

import "reflect"

type Question struct {
	Votes       int    `json:"votes"`
	Type        string `json:"type"`
	Title       string `json:"title"`
	URL         string `json:"url"`
	Description string `json:"description"`
	Information string `json:"information"`
}

type QuestionResults []Question

func NewQuestion(
	votes int,
	typeInfo string,
	title string,
	url string,
	description string,
	information string) *Question {
	return &Question{
		Votes:       votes,
		Type:        typeInfo,
		Title:       title,
		URL:         url,
		Description: description,
		Information: information,
	}
}

func (q *Question) QuestionField(tag string) interface{} {
	value := reflect.ValueOf(&q)
	return value.FieldByName(tag)
}


```

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvojmxw47oj213v0k012a.jpg)


因为实现逻辑基本一致，所以最好保持代码风格一致，比如结构体的命名、函数的命名、变量命名、代码的组织方式，减少理解负担。


2. 定义 repository 接口：方法集合：FindAll 和 Single
3. 基础设施层实现：downloader.go 
4. 用户界面层实现：question.go, 核心是获取 Question model 内的每个字段的Css 选择器

```
// app/userInterface/question.go
package userInterface

import (
	"bytes"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/domain/model"
	"github.com/wuxiaoxiaoshen/stackoverflowCli/app/infrastructure"
	"strconv"
	"strings"

	"github.com/PuerkitoBio/goquery"
)


type Question struct {
	model.Question
}

type QuestionResult []Question

func (q *Question) FindAll(url string) (interface{}, error) {
	response, _ := infrastructure.ResponseStorager(url)
	//fmt.Println(string([]byte(response)))

	var questionResult QuestionResult
	doc, _ := goquery.NewDocumentFromReader(bytes.NewReader(response))
	doc.Find("div.flush-left.js-search-results div.question-summary.search-result").Each(func(i int, selection *goquery.Selection) {
		votes := strings.TrimSpace(selection.Find(".statscontainer .stats").Find("div.vote").Text())
		newVotes := strings.Replace(strings.Replace(votes, "\n", "", -1), " ", "", -1)
		summary := selection.Find(".summary")
		title, _ := summary.Find(".result-link h3 a").Attr("title")
		url, _ := summary.Find(".result-link h3 a").Attr("href")
		fullUrl := "https://stackoverflow.com" + url
		description := strings.Replace(strings.TrimSpace(summary.Find(".excerpt").Text()), "\n", "", -1)
		information := strings.TrimSpace(summary.Find(".started.fr").Text())
		var questionType string
		if strings.Contains(information, "answered") {
			questionType = "answer"
		} else {
			questionType = "ask"
		}
		fmt.Println(newVotes, title, description, information, questionType, fullUrl)
		newVotesInt, _ := strconv.Atoi(newVotes)
		if i <= 10 && len(questionResult) <= 10 {
			oneQuestion := Question{
				*model.NewQuestion(newVotesInt, questionType, title, fullUrl, description, information),
			}
			questionResult = append(questionResult, oneQuestion)
		}

	})
	infrastructure.Marshal(questionResult)
	return nil, nil
}

func (q *Question) Single(url string, number int) (interface{}, error) {
	return nil, nil
}



```

5. 命令组织

```
// cmd/stackoverflowcli/main.go

func commandStorager() []cli.Command {
	return []cli.Command{
		{
			Name:        "job",
			Usage:       "Job Commands",
			Subcommands: jobSubCommand(),
		},
		{
			Name:        "question",
			Usage:       "Question Commands",
			Subcommands: questionSubCommand(),
		},
	}
}
func questionSubCommand() []cli.Command {
	return []cli.Command{
		{
			Name:    "search",
			Aliases: []string{"q"},
			Usage:   "Show stackoverflow question",
			Action: func(c *cli.Context) {
				var repo repository.StackOverFlowRepository
				var question uerInterface.Question
				repo = &question
				repo.FindAll(fmt.Sprintf(infrastructure.API["search"], c.Args().Get(0)))
			},
		},
	}

}


```

即实现的命令是 questison， 子命令是 search，接收一个参数(c.Args.Get(0))：即问题

6. 编译 `go build -o stackoverflowcli main.go`
7. 执行 `./stackoverflowcli question search "How can i learn golang"`

```
[
  {
   "votes": 0,
   "type": "ask",
   "title": "Impossible to modify struct inside array?",
   "url": "https://stackoverflow.com/questions/41706212/impossible-to-modify-struct-inside-array",
   "description": "I'm just starting to learn golang and I have the following code:https://play.golang.org/p/OBsf9MRLD8package mainimport (    \"encoding/json\"    \"os\")type ResourceUsage struct {    Type … \":[{\"Type:\"test\"}]}]But instead I get:[{\"Resources\":null},{\"Resources\":null}]How can I accomplish the expected output? …",
   "information": "asked Jan 17 '17 by lucaswxp"
  },
  {
   "votes": 0,
   "type": "ask",
   "title": "golang, use structs as argument into a function",
   "url": "https://stackoverflow.com/questions/41988041/golang-use-structs-as-argument-into-a-function",
   "description": "could you please advise on the question.I just started to learn golang and have already choked with this situation.For example:package mainimport (    \"fmt\")type X struct{    x string … (typeof(value) == \"[]Y\"){        fmt.Println(\"this is Y\")    }}expected output: this is X                 this is Yvalue interface{} is wrong type. How can I put different structures into one function and then dynamically define its type. Is something like this possible? Thanks. …",
   "information": "asked Feb 1 '17 by touchman"
  }
  ...
]


```

![](http://ww1.sinaimg.cn/large/741fdb86gy1fvok27xd4bj213x0k0qd0.jpg)


其他命令，可以参照源代码，参考实现，主要是梳理整体的流程。

#### 3.4.4 显示


至此，关于 stackoverflow 网站的命令行工具已经开发完毕，产品实用不实用暂不是我们考虑的范围，作为程序员，我们侧重的是实现，等到实现的多了，产品不断的迭代了，思考了才要更多。

这个问答网站的客户端的效果如下：

```
>> ./stackoverflowcli --help
stackoverflowcli - An application for stackoverflow web site

USAGE:
   stackoverflowcli [global options] command [command options] [arguments...]

VERSION:
   0.0.0

COMMANDS:
     user      User Commands
     job       Job Commands
     tag       Tag Commands
     question  Question Commands
     help, h   Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help
   --version, -v  print the version

```

- 支持 user、job、tag、question等命令
- 友好的显示: json
- 友好的帮助提示
...




## 4. 总结



本章介绍了四种实现命令行的方式，两个使用内置库，另外两者使用优秀的第三方库，四个例子各不相同，从四个不同的例子中比较用法，以及整体实现的逻辑是什么样的。

总结两点：

1. 使用逻辑清晰的项目结构，比如领域驱动设计，逻辑具有相似性的，体现在编码层面，也应该相似，比如命名风格，代码组织风格等
2. 明确需求，整体分析过，从宏观层面把握项目，这样具体实现起来事半功倍，章节的安排整体也是按照这个思路进行



通过本章的学习，希望你能创造出更多，更优秀的命令行工具。



### 4.1 参考

- cobra (https://github.com/spf13/cobra)
- cli (https://github.com/urfave/cli)
- gitcli (https://github.com/GopherCoder/gitcli)
- stackoverflowcli (https://github.com/GopherCoder/stackoverflowCli)
