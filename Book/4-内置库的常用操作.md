学习了 Go的基本使用方法之后，如果想要完成开发任务，包括两个方面：1. 使用丰富的内置库 2. 使用优秀的第三方库。

内置库是最重要的、使用最频繁的，无数的优秀的第三方库都是根据内置库的不断的扩充，优化开发者的使用的难度，更利于开发者使用、性能更好的第三方库，整个开源项目的社区就更为活跃。

所以说，整个内置库是最为重要。不管是为了完成你日常的开发任务，还是基于内置库进行开源项目的开发，内置库都必不可少。

本章结合作者的项目经验，将常用的内置库的基本使用方法介绍下，将整体的知识梳理下，这样等到真实的开发，能快速的明白应该如何使用，以及怎么用。


各内置库的介绍主要流程如下：

- 思维导图，将常见 API 图形化
- 给出示例，将用法示例化
- 总结，重新梳理



## Strings


字符串是日常开发过程中使用最为频繁的数据类型。关于字符串存在哪些常见的操作呢？


- 包含关系：某个字符串是否包含另一个字符串
- 索引：获取某个子串的第一个字符的位置
- 清洗：去除前后的空格，或者特定的字符
- 替换操作：替换字符串中原有字符
- 分割：将字符串按特定的特定字符分割成字符串数组
- 统计：统计某字符出现的次数
- 大小写：将字符串大小写转换
- 前后缀：判断某字符串是否是以另一个字符串开头或者结尾



![](http://ww1.sinaimg.cn/large/741fdb86gy1g1st34m2m1j213v0eamye.jpg)


既然包括上文常用的操作，那么内置库也应该包括这些常用的操作，提供相应的API。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1stjln6b5j213x0d40ua.jpg)



单单看这些 API 我们可能不太够切实的感受到如何操作，下面我们以 Golang 官网对 Go 编程语言的介绍的字符串来进行操作。

```
Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
```


```
const Values = "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software."

```


**1. 判断是否包含子字符串**

```
func StringsContains(subStrings string) bool {
	return strings.Contains(Values, subStrings)
}

fmt.Println(StringsContains("Go"))

>> true

fmt.Println(StringsContains("Java"))

>> false
```

这个函数的作用通常就是用来判断是否包含关系，有时候，开发过程中需要进行判断字符串是否包含某些特定的特征，这个时候这个函数就发挥作用了。具体的实现是根据判断"索引"关系。

```
// 源码

// Contains reports whether substr is within s.
func Contains(s, substr string) bool {
	return Index(s, substr) >= 0
}

```

**2.字符串比较**

```
func StringsCompare(values string, subString string) int {
	return strings.Compare(values, subString)
}

fmt.Println(StringsCompare("Java", "Go"))

>> 1

fmt.Println(StringsCompare("Go", "Java"))


>> -1

fmt.Println(StringsCompare("A", "B"), rune('A'), rune('B'))

>> -1 65 66
```


这个函数的作用是用来比较两个字符串的关系，相等为0，前者大于后者范为1，否则为-1。 字符串的比较关系是根据单个字符的ASCII 编码来比较的，比如 "A"的编码为65，"B"的编码为66，所以返回 -1。

关于比较关系的用法，通过正值用来表示大于关系，负值用来表示小于关系，零值用来表示相关关系。

**3.大小写转换**

```
func StringsToUpper(subStrings string) string {
	return strings.ToUpper(subStrings)
}

func StringsToLower(subStrings string) string {
	return strings.ToLower(subStrings)
}

func StringsToTitle(subStrings string) string {
	return strings.ToTitle(subStrings)
}

fmt.Println(StringsToUpper("goLang, hello world"))

>> GOLANG, HELLO WORLD

fmt.Println(StringsToLower("GoLang"))

>> golang

fmt.Println(StringsToTitle("goLang, hello world"))

>> GOLANG, HELLO WORLD
```

大小写的转换也是比较常用的操作，让你自己实现你会怎么操作？字符包含26个字母，将26个大小写字符组成2个散列表，遍历字符串，搜索散列表，将字符转换，最后组成完整的字符串，返回值。

```

var UpperCase = map[string]string{
	"a": "A",
	"b": "B",
	...
}

var LowerCase = map[string]string{
	"A": "a",
	"B": "b",
	...
}

```

这边的想法不够严谨，比如如果不是字符串怎么操作，比如已经是相应的大小写怎么操作。

可以看下源码：

```
func ToUpper(s string) string {
	isASCII, hasLower := true, false
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= utf8.RuneSelf {
			isASCII = false
			break
		}
		hasLower = hasLower || (c >= 'a' && c <= 'z')
	}

	if isASCII { // optimize for ASCII-only strings.
		if !hasLower {
			return s
		}
		b := make([]byte, len(s))
		for i := 0; i < len(s); i++ {
			c := s[i]
			if c >= 'a' && c <= 'z' {
				c -= 'a' - 'A'
			}
			b[i] = c
		}
		return string(b)
	}
	return Map(unicode.ToUpper, s)
}
```

**4.统计子串出现的次数**

```
func StringsCount(subStrings string) int {
	return strings.Count(Values, subStrings)
}

fmt.Println(StringsCount("Go"))

>> 1

fmt.Println(StringsCount("s"))

>> 6

```

**5.字符串的前后缀**

```

func StringsHasPrefix(subStrings string) bool {
	return strings.HasPrefix(Values, subStrings)
}

func StringsHasSuffix(subStrings string) bool {
	return strings.HasSuffix(Values, subStrings)
}

fmt.Println(StringsHasSuffix("software"))

>> false

fmt.Println(StringsHasSuffix("software."))

>> true

fmt.Println(StringsHasPrefix("Java"))

>> false

fmt.Println(StringsHasPrefix("Go"))

>> true
```

前后缀的逻辑判断源码给的特别简单，判断字符串截取之后的子字符串是否相等。

```

// HasPrefix tests whether the string s begins with prefix.
func HasPrefix(s, prefix string) bool {
	return len(s) >= len(prefix) && s[0:len(prefix)] == prefix
}

// HasSuffix tests whether the string s ends with suffix.
func HasSuffix(s, suffix string) bool {
	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
```

**6.分割和连接**

```
func StringsSplit(split string) []string {
	return strings.Split(Values, split)
}

func StringsJoin(subStrings []string) string {
	return strings.Join(subStrings, " ")
}


fmt.Println(StringsSplit(","))

>> [Go is an open source programming language that makes it easy to build simple  reliable  and efficient software.] 3

fmt.Println(StringsJoin([]string{"Go", "Java", "Python"}))

>>Go Java Python
```

这两个操作是一对相互对立的用法，一个是按照指定的字符分割成字符数组，一个是按照指定的字符数组连接成字符串。


**7. 索引**

```
func StringsIndex(subStrings string) int {
	return strings.Index(Values, subStrings)
}

fmt.Println(StringsIndex("o"))

>> 1
```

这个操作获取首次字符出现的位置。对于一些获取指定位置的字符是否是指定字符很有用处。


**8.清洗**

```
func StringsTrim(values string) string {
	return strings.TrimSpace(values)
}

fmt.Println(StringsTrim("   hello world   "))

>>hello world
```

清洗动作可以将字符串的两端的一些字符删除掉。当然最常用的是去除两端的空格，所以内置库也提供来专门的API。


**9. 替换操作**

```
func StringsReplacer(values string) string {
	newReplacer := strings.NewReplacer("\n", "", "\t", "", " ", "")
	return newReplacer.Replace(values)
}

fmt.Println(StringsReplacer(" hello world ,\n golang"))

>>helloworld,golang
```

清洗动作只能完成首尾的空格或者指定字符的替换，那么完成更为复杂的操作，需要使用到 `NewReplacer`, 可以完成多种样式的替换操作。这些替换函数在应对更为复杂的字符串清洗过程中应用更为广泛。比如爬虫，获取到的数据经常包含些用户并不需要的字符，使用字符串替换操作，可以完成数据物理层面的清洗，方便后续的更为复杂的操作。





**总结**

上文列举了关于字符串的常用操作。从中可以学到：

- 语义化：即函数的命名一般按照功能命名，这样能够达到见闻知意的效果
- 提供丰富的对外接口

关于语义化命名，这边可以学到：表示转换动作可以使用`To` 开头，表示是否等布尔型的可以使用 `Has`、 `Is` 或者 `Can` 等开头。





## bytes

内置库 bytes 提供了和 strings 库的几乎一致的常用操作，只不过两者数据类型不一致，一个是字节数组，一个是字符串，同时给使用者一个启发：两者可以相互转换。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1szcme3k3j213z0ctq4i.jpg)



基于此，两个内置库的常用用法只需要记住一套即可，如果你想只使用一套用法，可以将两者转换。


```
func ToString(value []byte) string {
	return string(value)
}

func ToBytes(value string) []byte {
	return []byte(value)
}


var A []byte
A = []byte("a b")

var B string
B = "a b"

fmt.Println(fmt.Sprintf("%T,%T", A, B))

>> []uint8,string

fmt.Println(fmt.Sprintf("%T,%T", ToString(A), ToBytes(B)))

>> string,[]uint8

```

根据强制类型转换，之后使用自己属性的数据类型进行后续操作。


除此之外，`bytes` 还存在两个重要的类型：`Buffer` 和 `Reader`。

在网络请求过程中经常会使用到 `Http.NewRequest` 构造请求，请求的签名如下：

```
func NewRequest(method, url string, body io.Reader) (*Request, error) 

```

函数签名中定义了请求体 `body` 类型为 `io.Reader`，`io.Reader`函数签名如下：

```
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

可以看出是个接口类型，主要对应的结构体实现了`Read` 方法，便实现了 `Reader` 接口。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g1t2ssicywj213y09gdge.jpg)


基于此，我们经常在网络请求中构造 `body` 时如下操作：

- bytes.NewBuffer(p []bytes)
- bytes.NewReader(p []bytes)
- strings.NewReader(s string)

```
func HttpByBytes() {
	url := "http://httpbin.org/anything?name=xix"

	var body map[string]string
	body = make(map[string]string)
	body["age"] = "20"
	body["school"] = "ShangHai"

	by, _ := json.Marshal(body)

	request, _ := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(by))
	client := http.DefaultClient
	response, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))

}

func HttpByByteNewReader() {
	url := "http://httpbin.org/anything?name=xix"

	var body map[string]string
	body = make(map[string]string)
	body["age"] = "20"
	body["school"] = "ShangHai"

	by, _ := json.Marshal(body)

	request, _ := http.NewRequest(http.MethodPost, url, bytes.NewReader(by))
	client := http.DefaultClient
	response, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))
}

func HttpByStrings() {
	url := "http://httpbin.org/anything?name=xix"

	request, _ := http.NewRequest(http.MethodPost, url, strings.NewReader(`{"name":"XieWei", "school":"ShangHai"}`))
	client := http.DefaultClient
	response, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))
}
```


## encoding/json

`json` 是一种非常常见的数据交换格式，也是后端编写 Restful 风格API的一种常见形式。通常包含两个操作：序列化(对象转换成json数据类型)、反序列化(json数据类型转换成对象)，是两个互为相反的动作。



![](http://ww1.sinaimg.cn/large/741fdb86gy1g1t3p3tlwkj213q06eq3e.jpg)



最常见的用法如上图所示。示例如下：

```


type JsonExample struct {
	Name   string `json:"name, omitempty"` // 序列化之后显示 name, 如果为空值，不显示该字段
	Age    int    `json:"age"` // 序列化之后显示为 age
	School string `json:"university"` // 序列化之后显示为 university
}

func JsonMarshal() {
	var jex JsonExample
	jex = JsonExample{
		Name:   "Go",
		Age:    10,
		School: "Google",
	}
	by, _ := json.Marshal(jex)
	fmt.Println(string(by))

}

func JsonUnmarshal() {

	var v JsonExample

	by := []byte(`{"name":"Go","age":10, "university":"google"}`)

	json.Unmarshal(by, &v)
	fmt.Println(v)

	var vother JsonExample
	byOther := []byte(`{"name":"","age":10, "school":"google"}`)
	json.Unmarshal(byOther, &vother)
	fmt.Println(vother)
}

JsonMarshal()

>>{"name":"Go","age":10,"university":"Google"}

JsonUnmarshal()

>>{Go 10 google}
>>{ 10 }

```


使用过程中需注意下面几点：

- 如果知道反序列化之后的具体结构，应该优先定义一个符合反序列之后的结构体
- 不知道反序列化之后的具体结构，应该使用 `Interface` 表示任意类型
- 结构体定义时的标签，指定序列化之后的显示，比如上文的 `json:"name, omitempty"`，序列化之后该字段显示 `name`，如果为空值，则不显示(`omitempty`)






## io/ioutil/bufio

### 1

`io` 库提供了非常常见的 `I/O` 的接口，`ioutil` 则提供了常见的文件操作的具体实现形式。



`io` 库最基本的两个接口为: `Reader` 和 `Writer`

```
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}

```

- 接口是方法的集合
- 接口的命名建议是 `X_er` 这种形式
- 接口的具体实现依赖于其他结构体


内置的其他很多库，就实现了这两个接口，具体的梳理如下：

![](http://ww1.sinaimg.cn/large/741fdb86gy1g1tb4f29vaj213v0ap0tt.jpg)


怎么知道是这样的呢？

查看具体的结构体是否实现了相应的方法即可。

以 `Strings` 的 `Reader` 为例：

```

type Reader struct {
    // contains filtered or unexported fields
}
func NewReader(s string) *Reader
func (r *Reader) Len() int
func (r *Reader) Read(b []byte) (n int, err error)
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
func (r *Reader) ReadByte() (byte, error)
func (r *Reader) ReadRune() (ch rune, size int, err error)
func (r *Reader) Reset(s string)
func (r *Reader) Seek(offset int64, whence int) (int64, error)
func (r *Reader) Size() int64
func (r *Reader) UnreadByte() error
func (r *Reader) UnreadRune() error
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
```

`Reader` 存在 `Read` 方法，和 `io` 库中的 `Reader` 的 `Read` 方法带有相同的参数和返回值，所以 `Strings` 库的 `Reader` 实现了 `io` 库的 `Reader` 接口。


示例：网络请求

```
func IoUsage() {
	url := "http://httpbin.org/anything?name=xix"
	request, _ := http.NewRequest(http.MethodPost, url, strings.NewReader(`{"name":"XieXie"}`))
	client := http.DefaultClient
	response, _ := client.Do(request)
	defer response.Body.Close()
	by, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(by))
}

IoUsage()

>>
{
  "args": {
    "name": "xix"
  }, 
  "data": "{\"name\":\"XieXie\"}", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept-Encoding": "gzip", 
    "Content-Length": "17", 
    "Host": "httpbin.org", 
    "User-Agent": "Go-http-client/1.1"
  }, 
  "json": {
    "name": "XieXie"
  }, 
  "method": "POST", 
  "origin": "128.14.137.131, 128.14.137.131", 
  "url": "https://httpbin.org/anything?name=xix"
}

```

- http.NewRequest 函数签名为：`func NewRequest(method, url string, body io.Reader) (*Request, error) `

其中 `Strings`的 `Reader` 实现了 `io.Reader` 接口，所以可以这么使用。

- ioutil.ReadAll 函数签名为：`func ReadAll(r io.Reader) ([]byte, error)`

其中 `response.Body` 的类型为 `io.ReadCloser` 包含 `Reader` 接口，所以可以这么使用。


通过上面的示例，希望更深一步的理解接口的含义。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1tbjmtnnmj213z0kbq51.jpg)


### 2

`bufio` 实现了缓存`io`。其中常见的使用是按行读取文件。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g1u71vahd2j213x0dswfn.jpg)



示例：

```

func ReadFile() {
	f, err := os.Open("io_test.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	rd := bufio.NewReader(f)
	for {
		line, err := rd.ReadString('\n')
		if err != nil || io.EOF == err {
			break
		}
		fmt.Println(line)
	}
}

```

## fmt


### 1

`fmt` 实现了格式化输出，提供相应的占位符。支持的占位符比较多，分门别类的梳理下，思路更为清晰点。

- 数值型：整型、浮点型
- 字符串
- 指针
- 布尔型
- 其他


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1tu7fmk9mj213z0bl753.jpg)



**1.数值型**

- `%b` 二进制
- `%o` 八进制
- `%x` 十六进制
- `%X` 十六进制
- `%d` 十进制
- `%f` 浮点型
- `%e` 科学计数法
- `%E` 科学计数法


```
func FmtUsage() {
	var number = 100.203
	var numberInt = 100
	fmt.Printf("%d\n", numberInt)
	fmt.Printf("%o\n", numberInt)
	fmt.Printf("%x\n", numberInt)
	fmt.Printf("%b\n", numberInt)
	fmt.Printf("%f\n", number)
	fmt.Printf("%e\n", number)
	fmt.Printf("%E\n", number)
}

FmtUsage()
>>100
>>144
>>64
>>1100100
>>100.203000
>>1.002030e+02
>>1.002030E+02

```

**2.字符串型**

- `%s` 字符串型
- `%q` 带双引号

```
func FmtStringUsage() {
	var values = "golang"
	fmt.Printf("%s\n", values)
	fmt.Printf("%q\n", values)
}

FmtStringUsage()

>>golang
>>"golang"

```

**3.布尔类型**

- `%t` 布尔类型

```
func FmtBoolUsage() {
	var ok = true
	fmt.Printf("%t\n", ok)
}

FmtBoolUsage()

>>true

```

**4.其他**

- `%T` 判断类型
- `%p` 指针类型
- `%v` 默认格式
- `%#v`带语法的格式

```
func FmtOtherUsage() {
	var a = 1
	var b = 2.0
	var ok = true
	number := &a
	var s = struct {
		Name string `json:"name"`
	}{
		Name: "Go",
	}
	fmt.Printf("%T\n", a)
	fmt.Printf("%T\n", b)
	fmt.Printf("%T\n", ok)
	fmt.Printf("%p\n%d\n", &a, number)
	fmt.Printf("%v\n", s)
	fmt.Printf("%#v\n", s)
}

FmtOtherUsage()
>>int
>>float64
>>bool
>>0xc000090638
>>824634312248
>>{Go}
>>struct { Name string "json:\"name\"" }{Name:"Go"}

```



全部的占位符分门别类的总结如下：


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1tuvr7njrj213w0aggni.jpg)


### 2

`fmt` 提供了非常类似的API:

- `Fprint/Fprintf/Fprintln`
- `Print/Printf/Println` 标准输出
- `Sprint/Sprintf/Sprintln` 格式化内容为 `string`



其中 `Fprint/Print/Sprint` 表示使用默认的格式输出或格式化内容，`Fprintf/Printf/Sprintf` 表示指定的格式输出或格式化内容，`Fprintln/Println/Sprintln` 表示使用默认的格式输出或格式化内容，同时会在最后加上换行符(`\n`)。


```
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}

```

`Print/Printf/Println` 是将内容标准输出，底层是调用的`Fprint/Fprintf/Fprintln`, 将第一个参数设置为`os.Stdout`。

```
func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
```



方法这么多，常用的其实就是：标准输出`Print/Printf/Println`, 格式化字符串`Sprint/Sprintf/Sprintln`。


### 3

创建一个错误类型有两种方式：

- `errors.New()`
- `fmt.Errorf`


其实`fmt.Errorf` 底层就是调用 `errors.New` 集合格式化字符串。

```
func Errorf(format string, a ...interface{}) error {
	return errors.New(Sprintf(format, a...))
}

```



### 4

`fmt` 还提供了几个接口，有些结构体实现了接口内定义的方法就能定制化格式化输出。

```
type Stringer interface {
	String() string
}

type GoStringer interface {
	GoString() string
}

```

两者的区别在于：`Stringer` 提供原生的输出，`GoStringer` 只有在带格式的输出生效，即：`%#v`。


示例：

```
type Val struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func (v Val) String() string {
	return fmt.Sprintf("%s + %d", v.Name, v.Age)
}
func (v Val) GoString() string {
	return fmt.Sprintf("%s + %d", v.Name, v.Age)
}

var a = Val{
	Name: "go",
	Age:  20,
}
fmt.Println(a)

>>go + 20

fmt.Printf("%#v\n", a)

>>go + 20

```

可以看到结构体实现了`Stringer` 和 `GoStringer` 接口，具体的输出实现了定制化。


## strconv


`strconv` 提供了字符串和其他常用的数据类型直接的转换，常用的基本数据类型主要包括：数值型、布尔型。

日常开发过程中，关于数据类型的转换有很多方式，比如强制数据类型转换，内置库 `strconv` 的转换效率比其他方式一定程度上更高效，推荐大家尽量使用内置库。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1u7vlh49hj213w0dqq4h.jpg)

### 1

字符串和布尔类型直接的转换。

```
func ToBool() {
	var a bool
	a = true
	b := strconv.FormatBool(a)
	fmt.Println(b)
	c, _ := strconv.ParseBool("false")
	fmt.Println(c)

}

ToBool()

>>true
>>false
```

能够将字符串转换为布尔类型的字符串包括这些：

```
1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 
```

可以看出，需要有点规范，不是随意的字符串都能转换为布尔类型，将字符串转换为布尔类型存在错误处理。


### 2

字符串和数值型直接的转换。数值是很常用的数据类型，数值又区分整型和浮点型，对应不同的处理函数。


```
func ToNumber() {
	var (
		a int
		b uint64
		c float64
	)

	a = 1
	b = 2
	c = 3.14
	fmt.Println(strconv.Itoa(a))
	fmt.Println(strconv.FormatUint(b, 10))
	fmt.Println(strconv.FormatFloat(c, 'f', 1, 32))
	d := "4.178"
	floatD, _ := strconv.ParseFloat(d, 64)
	fmt.Println(floatD)
}

ToNumber()

>>1
>>2
>>3.1
>>4.178

```

可以看出: `Parse_X` 和`Format_X` 是两个互逆的过程。

```
func FormatFloat(f float64, fmt byte, prec, bitSize int) string {
	return string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))
}
```

- `fmt` 参数接受之前介绍的格式化占位符，比如 `f`, `b`
- `int` 型和字符串直接的转换直接给了两个导出函数：`Atoi` 和  `Itoa`



## time

时间类型也是非常常用的操作，日常开发过程中，比如设置数据库的字段为时间类型，经常需要操作时间，比如：当天、一天前、一年前等这些数据。


要用好`time` 模块，最重要的其实是理解这些基本的单位：年、月、日、时、分、秒等。



![](http://ww1.sinaimg.cn/large/741fdb86gy1g1u9yi569yj213x0i8mzq.jpg)


`time` 提供了两个比较常用的数据类型：`Time` 和 `Duration`，同时提供了非常多的方法。

时间的常用操作。


```
func TimeUsage() {
	now := time.Now()

	// 获取年
	fmt.Println(now.Year())
	// 获取月份
	fmt.Println(now.Month())
	// 获取日前
	fmt.Println(now.Date())
	// 获取天
	fmt.Println(now.Day())
	// 小时
	fmt.Println(now.Hour())
	// 分
	fmt.Println(now.Minute())
	// 秒
	fmt.Println(now.Second())
	// 毫秒
	fmt.Println(now.Unix())
	// 纳秒
	fmt.Println(now.UnixNano())
}

TimeUsage()

>>2019
>>April
>>2019 April 7
>>7
>>18
>>44
>>20
>>1554633860
>>1554633860056071000
```

上文获取时间的基本属性。


```
func TimeOperate() {
	start := time.Now()
	time.Sleep(1 * time.Second)
	// 两个时间差
	fmt.Println(time.Now().Sub(start))

	// 格式化
	fmt.Println(start.Format("2006-01-02 15:04:06"))

	// 截取
	fmt.Println(start.Round(time.Second))
	fmt.Println(start.Truncate(time.Second))
	
	stringTime := "1991-12-25 19:00:00"
	birthday, _ := time.ParseInLocation("2006-01-02 15:04:05", stringTime, time.Local)
	fmt.Println(birthday.String())
}

TimeOperate()

>>1.004847901s
>>2019-04-07 19:02:19
>>2019-04-07 19:02:49 +0800 CST
>>2019-04-07 19:02:49 +0800 CST
>>1991-12-25 19:00:00 +0800 CST
```


几天前后的操作，使用两个方法：`Add` 和 `AddDate`, `Add` 是用来完成：小时、分、秒等操作，`AddDate` 是用来完成：年、月、日等操作。正数表示之后的时间，负数表示之前的时间。

```
func TimeAdd() {
	now := time.Now()

	// 一天前
	oneDayBefore := now.AddDate(0, 0, -1)

	fmt.Println(now.String(), oneDayBefore.String())

	// 一小时前
	oneHourBefore := now.Add(-1 * time.Hour)
	fmt.Println(oneHourBefore)
}

TimeAdd()

>>2019-04-07 19:23:25.696645 +0800 CST m=+1.006443777 2019-04-06 19:23:25.696645 +0800 CST
>>2019-04-07 18:23:25.696645 +0800 CST m=-3598.993556223
```


定时器：

```
func main() {

    ticker := time.NewTicker(time.Second)
	defer ticker.Stop()
	done := make(chan bool)
	go func() {
		time.Sleep(10 * time.Second)
		done <- true
	}()
	for {
		select {
		case <-done:
			fmt.Println("Done!")
			return
		case t := <-ticker.C:
			fmt.Println("Current time: ", t)
		}
	}
    
}

```

每隔一秒运行一次，持续时间 10秒。


总结：关于时间的操作，1. 获取时间的属性，比如基本单位 2. 时间的操作，比如两个时间的间隔，以及前几天，后几天之类的 3. 定时器操作

另外注意下，关于时间的一个基本的格式是：`2006-01-02 15:04:05` ，基本的记忆方法是：`12345`。


## regexp 

关于字符串的操作，除了 `strings` 提供的基本操作，还包括一个重要的方向，即搜索。对字符串按指定规则搜索，可以使用正则表达式。



### 1

基本正则表达式的主要规则如下：

|规则|说明|
|:---|:---|
|`^`|匹配字符串开始位置|
|$|匹配字符结束位置|
|`*`|零次或多次|
|`+`|一次或多次|
|`?`|零次或一次|
|`{n}`|匹配 n 次，n 非负|
|`{n,}`| 至少 n次|
|`{n,m}`|匹配n~m次，n<=m|
|`?`|匹配模式非贪婪|
|`.`|匹配除“\r”“\n”之外的任何单个字符|
|`x|y`|匹配x 或者 y|
|`[xyz]`|匹配字符集合|
|`[^xyz]`|匹配除字符集合之外的值|
|`[a-z]`|匹配字符范围|
|`\b`|单词边界|
|`\B`|非单词边界|
|`\d`|数字|
|`\D`|非数字|
|`\w`|匹配包括下划线的任何单词字符|
|`\W`|匹配任何非单词字符|


这些规则组合成一串字符串，形成匹配规则。使用正则表达式，匹配指定规则的内容。


### 2

`go` 中如何使用正则表达式？

使用正则表达式有两方面内容，1: 需要匹配的内容 2: 匹配的规则 ，解析器根据匹配规则，在指定的匹配的内容内进行匹配。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1vgabyou0j213z0b3jsi.jpg)


判断字符串是否和正则表达式匹配，可以使用`Match_X` 函数，所有的匹配规则需要经过 `Compile` 函数编译之后才能使用，匹配函数只负责是否匹配，返回值是布尔类型。

```
func SimpleUsage() {
	Slogan := "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software."

	reg, _ := regexp.Compile("open source programming language")
	if reg.Match([]byte(Slogan)) {
		fmt.Println("byte: Match")
	}

	if reg.MatchString(Slogan) {
		fmt.Println("string: Match")
	}

}

SimpleUsage()

>>byte: Match
>>string: Match

```

- `Match` 函数接收参数 `[]byte`
- `MatchString` 函数接收参数 `string`
- 返回值是布尔类型
- `[]byte` 和 `string` 在多种场景下使用一致，可以互换


`Compile` 函数是 `regexp` 的核心，规则一定需要经过`Compile` 函数编译之后才能使用，另外一个函数是`MustCompile`，两种用法一致，后者需要确保匹配规则的表达式完全正确，不合法的匹配规则是导致程序报错。

`Match_X` 函数完成的任务：是否匹配，除此之外，正则表达式另外一个常用的功能是搜索，即根据匹配规则，得出相匹配的子集。

```
func SearchUsage() {
	Slogan := "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software."

	reg, _ := regexp.Compile("open source programming language")
	v := reg.Find([]byte(Slogan))
	fmt.Println(string(v))

	v2 := reg.FindString(Slogan)
	fmt.Println(v2)
}

SearchUsage()

>>open source programming language
>>open source programming language

```

就搜索功能，`regexp` 提供了更为丰富的函数。

```
func (re *Regexp) Find(b []byte) []byte
func (re *Regexp) FindAll(b []byte, n int) [][]byte
func (re *Regexp) FindAllIndex(b []byte, n int) [][]int
func (re *Regexp) FindAllString(s string, n int) []string
func (re *Regexp) FindAllStringIndex(s string, n int) [][]int
func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string
func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int
func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte
func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int
func (re *Regexp) FindIndex(b []byte) (loc []int)
func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)
func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int
func (re *Regexp) FindString(s string) string
func (re *Regexp) FindStringIndex(s string) (loc []int)
func (re *Regexp) FindStringSubmatch(s string) []string
func (re *Regexp) FindStringSubmatchIndex(s string) []int
func (re *Regexp) FindSubmatch(b []byte) [][]byte
func (re *Regexp) FindSubmatchIndex(b []byte) []int

```


另外可以根据指定的匹配规则，使用正则表达式进行替换操作。`strings` 库的`NewReplacer` 已经能完成绝大部分替换功能。正则表达式的替换功能，能适用于更为复杂的场景。


```
func ReplaceUsage() {
	Slogan := "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software."

	reg, _ := regexp.Compile(`^Go`)
	result := reg.ReplaceAllString(Slogan, "Python")

	fmt.Println(result)
}

ReplaceUsage()

>>Python is an open source programming language that makes it easy to build simple, reliable, and efficient software.

```


另外一个功能是分割，同样 `strings` 库也支持按指定字符分割。

```
func SplitUsage() {
	Slogan := "Go is an open source programming language that makes it easy to build simple, reliable, and efficient software."

	reg, _ := regexp.Compile(`\s|\,|\.`) // 按" "、","、"." 分割

	result := reg.Split(Slogan, -1)
	fmt.Println(result)
}

SplitUsage()

>>[Go is an open source programming language that makes it easy to build simple  reliable  and efficient software ]

```


### 3





总结：`regexp` 库完成匹配`Match_X`、搜索`Find_X`、替换`Replace_X`和分割`Split` 等功能，完成这些任务的关键有两点：1. 使用 `Compile` 函数编译 2. 写符合场景的匹配规则。匹配规则又依赖于使用者对常见正则表达式规则的含义。




## log


日常开发过程中，如何有效的处理日志信息，不管对于有效的排错或者自己本身的Debug 都是非常重要的，当系统不够复杂的时候，在终端上打印有效的处理信息，只能够完成简单的查看等功能，如果系统报错，终端打印的信息并不能将信息存储下来，这样就把一些有效的日志信息给错过了，不利于排错。

日志的处理在日常开发过程中非常重要，一定程度上是为了将一些关键的处理信息进行保存等，一旦发生问题，日志是开发人员的首先需要查看的内容，根据报错的信息，进一步修复系统的问题。

那么关于日志需要关注哪些内容呢？

- 日志的级别：`Print_X` 系列、`Fatal_X` 系列、`Panic_X` 系列
- 日志的格式：比如文件的名称，具体的报错位置，时间等，方便开发人员排错
- 日志的输出：比如将日志存储在磁盘上


![](http://ww1.sinaimg.cn/large/741fdb86gy1g1ywrhpzjpj213q0d976g.jpg)

有些基于内置库而衍生出来的第三方日志出来库，无非是在日志级别、日志格式、日志输出等层面进行了优化，比如将日志级别划分为：`Debug`、`Info`、`Warn`、`Panic`、`Error`和`Fatal`，在合适的应用场景下使用合适的日志级别。

那么基于原生的内置日志库如何使用呢？分为两种，一种是默认的输出格式，另外一种是支持定制的输出格式。


### 1

默认的格式：

```
func DefaultUsageForLog() {

	log.Print("Hello World, Golang")
	log.Println("Hello World, Golang")
	log.Printf("Hello World, %s", "Golang")

	fmt.Println("log Prefix", log.Prefix())
	fmt.Println("log Flags", log.Flags())
}

DefaultUsageForLog()

>>2019/04/11 23:50:35 Hello World, Golang
>>2019/04/11 23:50:35 Hello World, Golang
>>2019/04/11 23:50:35 Hello World, Golang
>>log Prefix 
>>log Flags 3

```

内置的日志库区分三种日志级别：`Print_X`、`Fatal_X` 和 `Panic_X`。每个级别又划分为三种导出函数：

- `Print`、`Printf`和`Println`
- `Fatal`、`Fatalf`和`Fataln`
- `Panic`、`Panicf`和`Panicln`

分别表示不带格式化的日志、带格式化的日志、不带格式化但带换行的日志，这些导出函数和我们在`fmt` 库中遇到的处理方式几乎一致，这也带给我们启发：相同的代码风格，在项目开发中非常重要。


我们可以查看下源码，默认的日志是如何实现的？


- 定义结构体

```
type Logger struct {
	mu     sync.Mutex // ensures atomic writes; protects the following fields
	prefix string     // prefix to write at beginning of each line
	flag   int        // properties
	out    io.Writer  // destination for output
	buf    []byte     // for accumulating text to write
}

```

- 给定初始化函数

```
func New(out io.Writer, prefix string, flag int) *Logger {
	return &Logger{out: out, prefix: prefix, flag: flag}
}

```

接收参数: `io.Writer`、`string` 和 `flag`。看到`io.Writer` 是内置库 `io` 的 `Writer` 接口，所以具体的实现方式有很多，只要对于的结构体实现了`Writer` 接口提供的方法即可。


接着查看下：`log.Print` 是如何实现的。

- `log.Print` 的实现

```

func Print(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
}

var std = New(os.Stderr, "", LstdFlags)

```

原来是内置的了一个初始化`Logger` 结构体。



### 2


上文大概查阅了下默认格式的日志如何处理的，那么实现定制化的怎么处理呢？核心使用初始化`Logger` 结构体的 `New` 方法，实例化结构体`Logger`，再调用结构体`Logger` 的方法即可。


具体示例，定制化日志格式：


```

func SpecialUsageLog() {

	// 实例化 log.Logger 结构体
	logger := log.New(os.Stdout, "Golang ", log.Lshortfile)
	//
	logger.Println("Hello World, Golang")
}

SpecialUsageLog()

>>Golang log.go:23: Hello World, Golang
```

输出前缀了字符串`Golang `，采用了`log.Lshortfile` 格式的输出。


之前说过`func New(out io.Writer, prefix string, flag int) *Logger` 接收的第一个参数是 `io.Writer` 接口。而`os.Stdout` 实质是：`Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")` 即 `os.File` ，实现了`io.Writer` 接口的方法。

基于相同的道理，经常在日常开发中还可以看到这样使用日志的定制模式：

```

func SpecialUsageWithBytes() {

	var buf bytes.Buffer
	logger := log.New(&buf, "Hi! ", log.Lshortfile)

	logger.Println("Hello World, Golang")

	fmt.Println(buf.String())
}

SpecialUsageWithBytes()

>>Hi! log.go:33: Hello World, Golang
```

`bytes.Buffer` 实现了 `io.Writer` 接口。


```
func SpecialUsageWithFile() {

	file, _ := os.Create("log.log")
	logger := log.New(file, "Hi!", log.Lshortfile)

	logger.Println("Hello World, Golang")
}

SpecialUsageWithFile()


```

同目录下生成一个`log.log` 文件，写入的内容是`Hi!log.go:43: Hello World, Golang`




### 3

总结：日志的有效使用，能够到遇到问题，快速的定位，否则，查找问题的效率将大打折扣。日志的使用需要注意三点：1. 正确使用日志的级别，什么时候使用输出级别，什么时候使用报错级别等 2. 默认的日志格式，实质是默认初始化了`log.Logger` 结构体  3. 定制化日志格式，需要实例化`log.Logger` 结构体，再使用相应的方法。


## reflect/unsafe

在计算机领域，反射指的是一类应用，能够描述自身的特性，这类应用通过某种机制能够实现对自己行为的描述，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。


在 Golang 中支持操作反射的内置库是 `reflect` , 在反射中包括两大核心：1：`Type` 类型 2: `Value` 值。



![](http://ww1.sinaimg.cn/large/741fdb86gy1g23somvc75j213z0lgn0l.jpg)


关于类型和值的操作，最简单操作的是调用 `TypeOf` 和 `ValueOf` 分别获取类型和值。

```

func main() {
    Age := 20
	fmt.Printf("%T\n", Age)
	typ := reflect.TypeOf(Age)
	fmt.Println(typ)
	fmt.Println(reflect.ValueOf(Age))
    
}

>>int
>>int
>>20

```

格式化输出 `%T` 支持获取类型，`reflect.TypeOf` 同样获取类型，支持更多的操作。`reflect.Valueof` 获取对象的值。


更为常见的关于反射的场景的是对结构体操作，通过之前的学习我们知道，结构体的基本结构体如下：

```
type Example struct {
    
    Field   int `json:"one"`
    Field2  string `json:"two"`
    
}

func (e Example) String() string {
    return fmt.Sprintf("%d: %s", e.Field, e.Field2)
}
```

关于结构体存在如下知识点：1. 字段（属性，区分是否可导出，字段大小写区分），上例中即 `Field` 和 `Field2` 2. 结构体标签， 上例中即 `one` 和 `two` 3. 方法， 上例中即 `String` 

反射对结构体的操作，能让我们很轻松的操作关于结构的字段，结构体标签，和方法，同样能够改变结构的值。

```
type ReflectUsage struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func (ref ReflectUsage) String() string {
	return fmt.Sprintf("Name: %s, Age: %d", ref.Name, ref.Age)
}

func (ref *ReflectUsage) AddAge(add int) int {
	ref.Age += add
	return ref.Age
}

func (ref ReflectUsage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("Name: %s", ref.Name))
	return buf.Bytes(), nil
}

```

为演示方便，我们定义一个结构体 `ReflectUsage`，该结构体包含两个字段 `Name` 和 `Age`， 同时知道相应的类型：`string` 和 `int`，赋予了该结构体三个方法：`String`、`AddAge`和 `MarshalJSON` ，其中`AddAge` 是引用传递，其他是值传递。

通过反射，我们来操作该结构体，使其能获取到结构的字段、方法、并进行相应的操作。


```

func Usage() {
	var example ReflectUsage
	example.Name = "XieWei"
	example.Age = 20

	// 获取类型的两种方法
	typ := reflect.TypeOf(example)
	fmt.Printf("%T\n", example)
	fmt.Println(typ)

	// 获取值的两种方法
	val := reflect.ValueOf(example)
	fmt.Printf("%#v\n", example)
	fmt.Printf("%v\n", example)
	fmt.Println(val)

	// 结构体包含：字段(标签、值）、方法
	fmt.Println(typ.NumField(), typ.NumMethod())
	fmt.Println(val.NumField(), val.NumMethod())

	// 通过 type 获取标签属性
	fmt.Println(typ.FieldByName("Name"))
	fmt.Println(typ.FieldByName("Age"))

	// 通过 value 获取标签值
	fmt.Println(val.FieldByName("Name"))
	fmt.Println(val.FieldByName("Age"))

	// 函数的个数是根据传值的才计数，函数的排序根据函数名称的字母，函数可以调用
	fmt.Println(typ.NumMethod(), typ.Method(0))
	fmt.Println(typ.NumMethod(), typ.Method(1))

	methodOne := val.Method(1)
	args := make([]reflect.Value, 0)
	result := methodOne.Call(args)
	fmt.Println(result)

	methodTwo := val.MethodByName("MarshalJSON")
	argsTwo := make([]reflect.Value, 0)
	resultTwo := methodTwo.Call(argsTwo)
	fmt.Println(string(resultTwo[0].Bytes()))

	// 可以重新对结构体赋值操作，前提是获得指针
	valCanSet := reflect.ValueOf(&example)
	ptr := valCanSet.Elem()
	ptr.FieldByName("Age").SetInt(100)
	fmt.Println(example)

}
```


从这些基本的使用，反射库提供的函数，基本都是在操作对象的属性、和方法。根据类型和值，所以开发人员可以灵活的操作对象，比如判断类型、获取值、改变值等。

如何才能比较快速的记忆反射提供的方法呢？

- 结构体包含字段、标签和方法
- 字段有类型、名称和索引
- 方法有名称、索引、参数和返回值
- 指针执行对象的地址，可以更改对象


相对应的，可以记忆反射提供的这些函数：`FieldByName/FieldByIndex/Filed`、`MethodByName/Method`

反射中统计对象（结构体）的方法的个数是根据是否是值传递，如果是引用传递，不统计该方法，比如 `AddAge` 方法，另外方法的排序是根据方法的名称的`ASCII` 码排序，虽然支持索引的方式获取字段和方法，建议使用`X_ByName`形式的函数，这样不容易出错。

要改变结构体的属性的值，需要获取到指针，再调用 `Set_X` 函数。

内置库 `unsafe` 提供了更为存粹的操作指针的库，从库的名称可以看出，官方并不推荐使用，它绕过了 Golang 的内存安全原则，是不安全的，除非你知道你在做什么。


该库只提供了三个可导出的函数和两个类型：

- 类型1: ArbitraryType
- 类型2：Pointer
- 函数：Sizeof 获取所占字节
- 函数：Offsetof 获取偏移量（比如：数组是连续分配的内存，索引index 即表示的是偏移量
- 函数：Alignof 对齐


```
func UnsafeUsage() {
	var example ReflectUsage
	example.Name = "XieWei"
	example.Age = 20

	typ := reflect.TypeOf(unsafe.Sizeof(example))
	fmt.Println(typ)

	fmt.Println(unsafe.Sizeof(example))

	ptr := unsafe.Pointer(&example) //  第一个字段地址
	fmt.Println(ptr)
	fmt.Println(*(*string)(ptr)) //  强制类型转换成第一个字段类型，获取值

	ptrOfSecondField := unsafe.Pointer(uintptr(ptr) + unsafe.Offsetof(example.Age))
	fmt.Println(ptrOfSecondField)
	fmt.Println(*(*int)(ptrOfSecondField))

	*(*int)(ptrOfSecondField) = 32
	fmt.Println(example)
}

UnsafeUsage()

>>uintptr
>>24
>>0xc00009c6a0
>>XieWei
>>0xc00009c6b0
>>20
>>Name: XieWei, Age: 32

```

- unsafe.Pointer 将对象转换为指针
- uintptr 可以实现指针的操作，即和偏移量相加等
- unsafe.Offsetof 获取偏移量


![](http://ww1.sinaimg.cn/large/741fdb86gy1g23tgtcemdj213z09ajs6.jpg)



结构体在内存分配上是连续的，如果知道结构体字段的属性，可以通过指针的操作，改变原来的值，同时根据偏移量，也能获取或者改变属性。结构体的内存地址表示的是第一个字段的内存地址。



## os/path/filepath


### 1

在日常开发过程中经常需要和操作系统本身打交道，比如执行`shell` 命令、获取环境变量、操作文件系统等操作。相应的内置库 `os` 提供了对应的操作方法。

常见的关于操作系统的操作的一个方面是：文件系统。比如读取目录、变量目录、创建文件、文件内容读取等操作。

绝大多数服务的操作系统都是类`Unix`，所以有必要组织下类`Unix` 的文件信息的内容。 `Linux` 是多用户的操作系统，所以关于文件有很多标识信息，比如所属组，属主，所属其他用户等。

整个文件信息可以使用下面的思维导图来呈现：


![](http://ww1.sinaimg.cn/large/741fdb86gy1g24o3h5wh6j213w0ajwfq.jpg)


为理解这些信息，可以随意在`Linux` 系统下查看文件属性：

```
>> ll say.log

-rw-r--r--  1 xiewei  staff   201B  4 15 19:00 say.log
```

![](http://ww1.sinaimg.cn/large/741fdb86gy1g24o80msixj20cj05k0tn.jpg)



- 前10位依次表示：文件、属主权限`rw-`、属组权限`r--`、其他用户权限`r--`
- 文件大小：201B
- 文件最后更改时间：4 15 19:00
- 文件名称：say.log

根据文件的属性，`Linux` 操作系统又提供了相应的更改属性操作。

- chgrp 更改文件属组
- chown 更改文件属主
- chmod 更改文件9个属性
- r 代表权限分数 4
- w 代表权限分数 2
- x 代表权限分数 1


基于此，经常会执行的操作是: 

```
chmod 644 say.log 
chmod 777 say.log

```

为什么要懂这些呢？编程语言要实现对操作系统内文件的操作，既然文件具备这些属性，那么必然的编程语言需要实现这些内容。


比如更改文件属性：

```
func Chdir(dir string) error
func Chmod(name string, mode FileMode) error
func Chown(name string, uid, gid int) error
func Chtimes(name string, atime time.Time, mtime time.Time) error
...

```

内置库关于文件属性：读、写、可执行

```
const (
	// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
	O_RDONLY int = syscall.O_RDONLY // open the file read-only.
	O_WRONLY int = syscall.O_WRONLY // open the file write-only.
	O_RDWR   int = syscall.O_RDWR   // open the file read-write.
	// The remaining values may be or'ed in to control behavior.
	O_APPEND int = syscall.O_APPEND // append data to the file when writing.
	O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
	O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
	O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
	O_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.
)
```


示例：文件操作

```
func OsUsage() {
	// 判断文件是否存在，获取文件信息
	fileMode, err := os.Stat("log.log")
	if os.IsNotExist(err) {
		return
	}
	fmt.Println(fileMode.Name(), fileMode.Mode(), fileMode.Size())
}

func OSUsageWith() {
    // 创建文件，并以追加的方式写入内容

	file, _ := os.OpenFile("os.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	fmt.Println(file.Name())
	file.WriteString("Hello")
	file.WriteString("HelloWorld")
}

OsUsage()
OSUsageWith()

>>log.log -rw-r--r-- 34
>>os.log

```

内置了打开和创建文件的快速操作：`os.Open` 和 `os.Create`，底层其实`os.OpenFile`


```
// 源码

// 即：可读文件
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}

// 即：创建文件，文件属性为rw-rw-rw-
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}


```

对文件的操作，最常用的还是文件的读写。

```
type File
    func Create(name string) (*File, error)
    func NewFile(fd uintptr, name string) *File
    func Open(name string) (*File, error)
    func OpenFile(name string, flag int, perm FileMode) (*File, error)
    func (f *File) Chdir() error
    func (f *File) Chmod(mode FileMode) error
    func (f *File) Chown(uid, gid int) error
    func (f *File) Close() error
    func (f *File) Fd() uintptr
    func (f *File) Name() string
    func (f *File) Read(b []byte) (n int, err error)
    func (f *File) ReadAt(b []byte, off int64) (n int, err error)
    func (f *File) Readdir(n int) ([]FileInfo, error)
    func (f *File) Readdirnames(n int) (names []string, err error)
    func (f *File) Seek(offset int64, whence int) (ret int64, err error)
    func (f *File) SetDeadline(t time.Time) error
    func (f *File) SetReadDeadline(t time.Time) error
    func (f *File) SetWriteDeadline(t time.Time) error
    func (f *File) Stat() (FileInfo, error)
    func (f *File) Sync() error
    func (f *File) SyscallConn() (syscall.RawConn, error)
    func (f *File) Truncate(size int64) error
    func (f *File) Write(b []byte) (n int, err error)
    func (f *File) WriteAt(b []byte, off int64) (n int, err error)
    func (f *File) WriteString(s string) (n int, err error)
```


可以看出，`File` 具备 `Write` 和 `Read` 方法。

```

// io
type Writer interface {
	Write(p []byte) (n int, err error)
}

type Reader interface {
	Read(p []byte) (n int, err error)
}
```

又因为接口 `Writer` 和 `Reader` 分别具有 `Write` 和 `Read` 方法。所以 `File` 实现了接口 `Writer` 和 `Reader`。

关于文件的读写，日常开发中，也常使用 `ioutil` 库的`ReadFile`和 `WriteFile` 函数。阅读源码发现，其实底层就是在调用 `os.File` 相关的操作。

```
// 源码：ioutil.ReadFile 和 ioutil.WriteFile

func ReadFile(filename string) ([]byte, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	// It's a good but not certain bet that FileInfo will tell us exactly how much to
	// read, so let's try it but be prepared for the answer to be wrong.
	var n int64 = bytes.MinRead

	if fi, err := f.Stat(); err == nil {
		// As initial capacity for readAll, use Size + a little extra in case Size
		// is zero, and to avoid another allocation after Read has filled the
		// buffer. The readAll call will read into its allocated internal buffer
		// cheaply. If the size was wrong, we'll either waste some space off the end
		// or reallocate as needed, but in the overwhelmingly common case we'll get
		// it just right.
		if size := fi.Size() + bytes.MinRead; size > n {
			n = size
		}
	}
	return readAll(f, n)
}



func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

```

对文件读写，内置好些库都支持：`bufio`、`ioutil` 和 `os`。



### 2

关于文件系统的另一个比较重要的是操作是目录，文件都是置放在某个目录下，开发过程中对文件的操作，都伴随着对文件所在的目录的操作，比如或者当前目录，或者文件的目录，获取绝对路径，获取相对路径等。

在类`Unix` 操作系统下，路径都是以`/` 分割的，比如：`/Users/xiewei/go/src/GopherBook`，那关于目录（路径）的操作包括哪些呢？

![](http://ww1.sinaimg.cn/large/741fdb86gy1g24vkdr9b0j213q07dt9k.jpg)


示例：

```
func OSPathUsage() {
	dir, _ := os.Getwd()
	fmt.Println(dir, path.Base(dir))
	fmt.Println(dir, path.Dir(dir))
	parentDir := path.Dir(dir)
	fmt.Println(dir, path.Join(parentDir, "Chapter3"))
}


OSPathUsage()

>>/Users/xiewei/go/src/GopherBook/chapter4 chapter4
>>/Users/xiewei/go/src/GopherBook/chapter4 /Users/xiewei/go/src/GopherBook
>>/Users/xiewei/go/src/GopherBook/chapter4 /Users/xiewei/go/src/GopherBook/Chapter3
```

- 获取路径最后一个元素：`Base`
- 获取文件路径： `Dir`
- 将路径分割和组合：`Split` 、`Join`
- 获取文件扩展名：`Ext`


本质上路径是一串带分隔符`/` 的字符串，所以这些 `Base`、`Dir` 、`Split` 和 `Join` 的参数，是对包含特定特征`/`的字符串的操作。查看源码验证，亦是如此。

```
// 源码

func Base(path string) string {
	if path == "" {
		return "."
	}
	// Strip trailing slashes.
	for len(path) > 0 && path[len(path)-1] == '/' {
		path = path[0 : len(path)-1]
	}
	// Find the last element
	if i := strings.LastIndex(path, "/"); i >= 0 {
		path = path[i+1:]
	}
	// If empty now, it had only slashes.
	if path == "" {
		return "/"
	}
	return path
}

```

可以看出其实是对字符串进行截取动作。

```

func Join(elem ...string) string {
	for i, e := range elem {
		if e != "" {
			return Clean(strings.Join(elem[i:], "/"))
		}
	}
	return ""
}
```

同样可以看出是对字符串进行拼接动作。


`Windows` 平台下的目录格式和`Linux` 下目录格式有很大的不同，`Path` 库只处理以 `/` 分割的路径操作，如果需要支持对兼容操作系统的路径的操作可以使用`filepath` 几乎提供了相似的功能，`filepath` 完全可以替代`path`。

`filepath` 提供了针对非`Linux` 平台的三个函数：

- VolumeName 获取磁盘名称，比如`Windows` `C` 盘
- ToSlash 将路径分隔符 `\\` 转换为 `/` 分割符
- FromSlash 将`/` 分割符的路径转换为带 `\\` 的分隔符


如何创建目录、删除目录、对目录进行遍历操作？


- `os.Mkdir/os.MkdirAll` 创建目录
- `os.Remove/os.RemoveAll` 删除目录
- `filepath.Walk` 遍历目录

示例：

```
// 遍历当前目录下的所有文件
func OSDirUsage() {
	path, _ := os.Getwd()
	filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		fmt.Println("file:", info.Name(), "in directory:", path)

		return nil
	})

}

```




### 3

如何执行操作系统命令？比如在 `Linux` 操作系统下，经常在终端下执行命令，如何使用编程语言实现在终端下执行命令的效果？

`os/exec` 提供这样的功能，基于此，可以在代码中执行命令，再进行后续操作，比如根据执行的命令进行其他结果操作等。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g25pnun6tbj213r09rq3w.jpg)


关于这个库，是用来执行命令的。通常来说有两种用法：1. 查找命令的目录 2. 执行命令


示例：

```
func OSExecUsage() {
	dockerPath, err := exec.LookPath("docker")
	if err != nil {
		return
	}
	fmt.Println(dockerPath)

	pwdPath, err := exec.LookPath("pwd")
	if err != nil {
		return
	}
	fmt.Println(pwdPath)

	// 1
	cmd := exec.Command("docker", "ps")
	stdout, _ := cmd.StdoutPipe()
	cmd.Start()
	opBytes, err := ioutil.ReadAll(stdout)
	fmt.Println(cmd.Dir, cmd.Path, string(opBytes))

	// 2
	pwd, _ := os.Getwd()
	cmd2 := exec.Command("ls", pwd)
	var buf bytes.Buffer
	cmd2.Stdout = &buf
	cmd2.Start()
	cmd2.Wait()
	fmt.Println(buf.String())

	// 3
	cmd3 := exec.Command("cat", "log.log")
	out, _ := cmd3.Output()
	//out2, _ := cmd3.CombinedOutput()
	fmt.Println(string(out))

	// 4
	cmd4 := exec.Command("sh", "os.sh")
	out4, _ := cmd4.CombinedOutput()
	fmt.Println(string(out4))

}

```

- `LookPath` 搜索命令的路径，报错，表示命令不存在
- `exec.Command` 实例化结构体`exec.Cmd`，一般的实例化都是以`New_X` 开头

```
// 源码
func Command(name string, arg ...string) *Cmd {
	cmd := &Cmd{
		Path: name,
		Args: append([]string{name}, arg...),
	}
	if filepath.Base(name) == name {
		if lp, err := LookPath(name); err != nil {
			cmd.lookPathErr = err
		} else {
			cmd.Path = lp
		}
	}
	return cmd
}
```

- `Cmd.Run` 和 `Cmd.Start` 方法进行执行命令，区别是：`Run` 会等待命令执行完毕
- `Cmd.CombinedOutput()` 和 `Cmd.Output()` 可以直接得出支持命令的结果


同样，执行命令的结果支持指定输出，即`Cmd.Stdout` 赋值操作。比如：

```

// 1
	pwd, _ := os.Getwd()
	cmd2 := exec.Command("ls", pwd)
	var buf bytes.Buffer
	cmd2.Stdout = &buf

// 2

	cmd5 := exec.Command("ls", pwd)
	stdout5, _ := cmd5.StdoutPipe()
	if err := cmd5.Start(); err != nil {
		fmt.Println(err)
	}

	bytes, err := ioutil.ReadAll(stdout5)

	err = ioutil.WriteFile("file.log", bytes, 0644)
	if err != nil {
		panic(err)
	}

```

支持外部命令的操作大概就是这些，开发者可以根据自己的需求选择合适的方法。



## unicode

`unicode` 称为统一码，是为来解决世界上存在的各种语言，统一码对世界上绝大多数的文字系统进行了整理编码、编码，使得计算机可以用更为简单的方式来呈现和处理文字。统一码定义了一个字符和编码之间的映射，每个字符的编码唯一。统一码可以认为是一种标准和规范，具体的实现方式又各不相同，`UTF-8` 和`UTF-16` 是两种不同的实现这种映射关系的实现。


![](http://ww1.sinaimg.cn/large/741fdb86gy1g25smomwvcj213z0awgms.jpg)


下面通过示例来演示关于统一码的应用场景：

### 1

判断字符是否包含字母、数字等

```

func UnicodeUsage() {

	var string = "你好 Golang 123"

	for _, i := range string {
		if unicode.IsLetter(i) {
			fmt.Printf("Yes:%c ", i)
		} else {
			fmt.Printf("No:%c ", i)
		}

	}
}

UnicodeUsage()

>>Yes:你 Yes:好 No:  Yes:G Yes:o Yes:l Yes:a Yes:n Yes:g No:  No:1 No:2 No:3

```


根据单个字符进行判断是否符合条件是一个应用场景，除`IsLetter` 之外还支持以下这些判断：

```
func Is(rangeTab *RangeTable, r rune) bool
func IsControl(r rune) bool
func IsDigit(r rune) bool
func IsGraphic(r rune) bool
func IsLetter(r rune) bool
func IsLower(r rune) bool
func IsMark(r rune) bool
func IsNumber(r rune) bool
func IsOneOf(ranges []*RangeTable, r rune) bool
func IsPrint(r rune) bool
func IsPunct(r rune) bool
func IsSpace(r rune) bool
func IsSymbol(r rune) bool
func IsTitle(r rune) bool
func IsUpper(r rune) bool

```

结合`strings`和 `unicode` 库可以使一些任务更为轻松的完成，比如清除字符串首尾某种条件的字符、比如替换字符串中某种条件的字符。

```
fmt.Print(strings.TrimFunc("¡¡¡Hello, Gophers!!!", func(r rune) bool {
    return !unicode.IsLetter(r) && !unicode.IsNumber(r)
}))

>>Hello, Gophers

```

```
f := func(c rune) bool {
    return !unicode.IsLetter(c) && !unicode.IsNumber(c)
}
fmt.Printf("Fields are: %q", strings.FieldsFunc("  foo1;bar2,baz3...", f))

>>Fields are: ["foo1" "bar2" "baz3"]
```

### 2

将字符进行转换，比如大小写转换。

```
func UnicodeUsage() {

	var string = "你好 Golang 123"



	for _, i := range string {
		fmt.Printf("%c", unicode.ToUpper(i))
	}

}

>>你好 GOLANG 123
```

除`ToUpper` 转换函数之外，还存在`ToLower、ToTitle` 函数。在内置库`strings、bytes`中也提供了类型的函数，对开发者而言，可选择的方式更多了，字符、字符串、字节之间可以相互的转换，所以提供了类型的函数也不足为奇。




### 3

在功能开发中经常有时候会限定语言，比如注册用户名只能是中文、韩文等，这些跟国家有关的语言，统一码就是为了解决这些多种多样的文字系统，使用`unicode` 可以轻松的解决这个问题。

```
func RegisterUserName(name string, table *unicode.RangeTable) error {
	for _, i := range name {
		if !unicode.Is(table, i) {
			return errors.New("scripts is not correct")
		}
	}
	return nil
}

fmt.Println(RegisterUserName("注册名Hello", unicode.Scripts["Han"]))
fmt.Println(RegisterUserName("등록이름", unicode.Scripts["Hangul"]))
>>scripts is not correct
>><nil>

```

上文中第一个函数参数包含英文字符，报错；第二个函数参数只包含韩文，通过。


### 4

总结：本小节主要内容是`unicode` 统一码的使用，主要包括三个方面：1. 判断，判断字符是否符合指定要求 2. 转换，将字符转换大小写等操作 3. 字符集，包括各国语言的字符范围



## flag

日常开发过程中经常会使用到客户端终端命令，特别是你使用`Linux` 作为开发环境，使用到命令行的形式的机会更多，几乎是所有的服务器都是`Linux`，没有界面的形式。再者，经常使用到的服务都是`C/S`(客户端/服务端)的架构，如何和服务端进行交互，一种方式是服务端提供`Restful API` 的形式，供使用者操作服务端的资源，另外一种形式是客户端封装对服务端的操作，提供出命令行的形式交互服务端。比如经常使用的容器服务：`Docker` ，用户之所以可以操作镜像和容器，是因为 `Docker` 是采用的是 `C/S` 架构，启动`Docker` 本地即启动`Docker` 服务，终端中使用`docker` 命令即可操作资源。

在 Go 中支持对命令参数的解析，提供这种操作的库是 `flag`，你可以采用内置的基本数据类型参数的解析，比如整型、浮点型、布尔型、字符串类型、时间类型等，提供两种不同的方式操作这几种基本类型，一种是先声明变量的形式，另一种是直接使用指针的形式。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g2sy1d2fzbj213w0ao0tt.jpg)



下面看下基本的使用方式：


```
func FlagUsage() {
	var number int
	flag.IntVar(&number, "n", 10, "number")

	name := flag.String("name", "Go", "name of language")

	now := flag.Duration("time", time.Second, "time")
	flag.Parse()

	flag.PrintDefaults()
	fmt.Println(number, *name, *now)
}

```

- `flag.IntVar/flag.Float64Var/flag.Int64Var/flag.Uint64Var/flag.UintVar/flag.BoolVar/flag.StringVar/flag.DurationVar` 适用于针对指定变量名称
- `flag.Int/flag.Float/flag.Int64/flag.Uint64/flag.Uint/flag.Bool/flag.String/flag.Duration` 适用于将值赋给指针的形式
- 区分两种的方式可以直接从方法的名称入手，带`Var` 关键字，需要赋给指定的变量
- 两种方式可以指定接受命令的短参数、默认值、以及帮助提示
- 必须使用 `flag.Parse` 才能正确的解析到命令行参数

上文在终端中使用方式如下：

```
go run main.go -n 100 -name Python -time 1h10m

>>
  -n int
    	number (default 10)
  -name string
    	name of language (default "Go")
  -time duration
    	time (default 1s)
100 Python 1h10m0s

// 也可以等号的形式
go run main.go -n=1000 -name=Golang -time=1h20m30s

>>
  -n int
    	number (default 10)
  -name string
    	name of language (default "Go")
  -time duration
    	time (default 1s)
1000 Golang 1h20m30s

// 不赋值，则显示默认值
go run main.go

>>

  -n int
    	number (default 10)
  -name string
    	name of language (default "Go")
  -time duration
    	time (default 1s)
10 Go 1s
```


默认的是对整型、浮点型、字符串型、布尔型、时间类型的操作，即将命令行终端中获取到的值转变为整型、浮点型、字符串型、布尔型和时间类型，如何想对命令行终端中获取到的值转变为自定义类型，比如将传入的字符串转变为切片、数组、自定义类型等那怎么操作？

答案实现：`Value` 接口

接口是一系列方法的集合，阅读源码，查看下`Value` 接口的定义。

```
type Value interface {
	String() string
	Set(string) error
}

```

可以看出要实现自定义的类型解析，需要实现 `String` 方法和 `Set`方法，`Set` 方法的作用是将接受的值转换成自定义类型，所以需要使用指针，`String` 方法是为了实现格式化输出。

示例：自定义类型：

```

type Numbers struct {
	Num []int
}

func (n *Numbers) Set(value string) error {
	sList := strings.Split(value, "|")
	var num []int
	for _, i := range sList {
		in, _ := strconv.Atoi(i)
		num = append(num, in)
	}
	n.Num = num
	return nil
}

func (n *Numbers) String() string {
	return fmt.Sprintf("%#v", n.Num)
}

func FlagSpecial() {
	var n Numbers
	flag.Var(&n, "n", "number to parse")
	flag.Parse()
	fmt.Println(n.Num)
}
```

- 自定义类型 `Numbers`
- 实现`Set` 和`String` 方法
- 具体是将`|` 分隔符分割的字符串转化为`Numbers` 的属性


```
go run main.go -n='1|2|3'

>>
[1 2 3]

go run main.go -n '12|2|2'

>>
[12 2 2]
```

可以看出将命令行接受的字符串参数转化自定义的类型，并赋值。基于此，可以借用该接口实现更为复杂的转化为自定义类型，只需要实现`Set` 和 `String` 方法即可。

回过口看下，之前使用`flag.IntVar/flag.Int` 源码中是如何实现的呢？

**1. `flag.IntVar`**

```
func IntVar(p *int, name string, value int, usage string) {
	CommandLine.Var(newIntValue(value, p), name, usage)
}
```

**2. CommandLine.Var**

```
var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet

func (f *FlagSet) Var(value Value, name string, usage string)
```

**3. FlagSet**

```
type FlagSet struct {
	// Usage is the function called when an error occurs while parsing flags.
	// The field is a function (not a method) that may be changed to point to
	// a custom error handler. What happens after Usage is called depends
	// on the ErrorHandling setting; for the command line, this defaults
	// to ExitOnError, which exits the program after calling Usage.
	Usage func()

	name          string
	parsed        bool
	actual        map[string]*Flag
	formal        map[string]*Flag
	args          []string // arguments after flags
	errorHandling ErrorHandling
	output        io.Writer // nil means stderr; use out() accessor
}

// A Flag represents the state of a flag.
type Flag struct {
	Name     string // name as it appears on command line
	Usage    string // help message
	Value    Value  // value as set
	DefValue string // default value (as text); for usage message
}

func (f *FlagSet) Set(name, value string) error 


```

通过组合的方式，`FlagSet` 结构体的`formal` 字段拥有`Flag`，而`Flag` 又包含 `Value` 字段。所以，内置的这些方法其实都实现了`Value` 接口。


**总结**

终端中输入命令行的方式可以使用到内置库`Flag`, `Flag` 提供了整型、浮点型、字符串、时间类型等类型的接收参数，可以自动的解析变量转化为指定的类型，进行后续的处理。另外可以自定义解析任意类型的变量，只需要实现`Value` 接口即可。

后续，在开发过程中，也会接触到一些优秀的第三方开源库，比如： https://github.com/urfave/cli 或者 https://github.com/spf13/cobra，本质上这些开源库是封装了内置库`Flag` 提供了更为简便的处理方式而已。




## net/url

网络请求在`web`开发过程中是非常常见的操作，比如如何进行网络请求，如何构建服务端进行网络资源的访问。这些都可以使用内置库`net/url` 和 `net/http`，本节先学习一个非常小的点路由。进行`web`开发过程中，其实包含三个步骤：1. 设置访问方法：`GET、POST、PATCH、DELETE` 2. 设置访问路径，即路由的设计 3. 设置资源的响应形式，`RestfulAPI` 风格的响应一般选择`json` 的形式。

本节学习下路由包含哪些知识点：

路由学名：URL(统一资源定位符)，唯一定位服务器上的资源，通过示例的形式学习下，URL 一般包好哪些部分？

示例：

```
https://golang.org/pkg/net/url?name=xie&age=20
```

- scheme: 表示的是使用了何种协议：比如 https 
- 服务器地址：golang.org，当然也可以使用 ip 地址的形式，定位到服务器，为了方便记忆，使用到了`DNS`, 即域名管理系统，将网址和ip 地址唯一映射。
- 资源路径：资源在服务器上的具体地址


URL具体的语法组成有哪些？

- scheme: 使用何种协议
- 用户
- 密码
- 主机地址：服务器地址，ip 或者对应的域名
- 端口
- 路径：资源的路径，使用`/`分割
- 参数：键值对的形式，使用`&`连接多个键值对
- 查询：标识符 `?`
- 片段: 标识符 `#`


分解下来：`https://golang.org/pkg/net/url?name=xie&age=20`

- 协议：超文本传输安全协议 `https`
- 服务器域名：`golang.org`
- 资源地址：`pkg/net/url`
- 请求参数：`name` 和 `age` 对应的值为 `xie`和 `20`


具体可以看下源码中关于URL 的结构体定义：

```

type URL struct {
	Scheme     string
	Opaque     string    // encoded opaque data
	User       *Userinfo // username and password information
	Host       string    // host or host:port
	Path       string    // path (relative paths may omit leading slash)
	RawPath    string    // encoded path hint (see EscapedPath method)
	ForceQuery bool      // append a query ('?') even if RawQuery is empty
	RawQuery   string    // encoded query values, without '?'
	Fragment   string    // fragment for references, without '#'
}

```

可以看出和对应上文所学的知识点是一致的。那么关于URL 有哪些操作？对路由的操作，最常见的是：1. 获取请求参数 2. 改变请求参数，这是因为对服务器上资源的操作，其实就是访问不同的URL, 定位到不同的资源嘛。

在源码层面呢，本质上URL就是一串包含特定规律的字符串而已，源码层面可以随处看到关于字符串的操作。


在请求参数方面，源码键值对的参数形式，处理成 `map` 的形式，可以很容易的实现获取、增加、改变、删除等操作：

```
type Values map[string][]string


func (v Values) Get(key string) string
func (v Values) Add(key, value string) 
func (v Values) Set(key, value string)
func (v Values) Del(key string)

```



示例：

```
// 将字符串转化为URL类型

func UrlUsage() {
	var urlString = "https://golang.org/pkg/net/url?name=xie&age=20"
	urlPath, _ := url.Parse(urlString)
	fmt.Println(fmt.Sprintf("%#v", urlPath))
}

UrlUsage()
>> 
&url.URL{Scheme:"https", Opaque:"", User:(*url.Userinfo)(nil), Host:"golang.org", Path:"/pkg/net/url", RawPath:"", ForceQuery:false, RawQuery:"name=xie&age=20", Fragment:""}


// 获取请求参数，并改变

func UrlUsageParams() {
	rawUrl := "https://golang.org/pkg/net/url?name=xie&age=20"
	urlParsed, _ := url.Parse(rawUrl)
	fmt.Println(urlParsed.Query())
	v := urlParsed.Query()
	v.Del("name")
	v.Add("school", "shanghai")
	urlParsed.RawQuery = v.Encode()
	fmt.Println(urlParsed)
}

UrlUsageParams()
>>
map[name:[xie] age:[20]]
https://golang.org/pkg/net/url?age=20&school=shanghai

```

当然也可以单独对这种键值对的参数的形式进行转化为`Value` 类型，即 `map`

```
func UrlValues() {
	values := "name=xie&age=20"
	v, _ := url.ParseQuery(values)
	fmt.Println(v)
	v.Add("school", "shanghai")
	fmt.Println(v)
}

UrlValues()
>>
map[name:[xie] age:[20]]
map[name:[xie] age:[20] school:[shanghai]]
```

关于URL 的操作，最核心的就是这些：1. 将字符串转化为 URL 类型 2. 对请求参数的操作

后续在 `net/http` 库中经常能看到URL 操作的影子。

**总结**

URL 唯一定位服务器上的资源，我们经常在网上冲浪，实质是使用浏览器访问各种服务器上不同的资源。浏览器渲染出服务器上能够让用户看到的资源。不同的请求参数，访问到的资源不同，URL 通过服务器地址、路径、请求参数等，构造出不同的访问服务器资源的形式。


## net/http

`net/http` 是内置库中一个非常重要的核心库，其他的编程语言，要实现`web` 服务，或者发起网络请求，往往需要编写很多的代码，而 `Go` 中，只需要简短的几句便可实现 `web`服务或者发起网络请求，这得益于内置库的简便性。

关于网络请求，往往包含两个方向：1. 客户端，即向某服务端发起网络请求，访问该服务端的资源 2. 服务端，即提供给其他客户端的资源，供其他客户端的访问

下面分别从客户端和服务端两个方面进行讲解内置库 `net/http` 的使用。



### 1

客户端是向服务端发起网络请求，根据服务端提供的不同请求方法或者路由的不同，访问到的资源各不相同。

为访问方便，使用到了可以用来测试网络请求的一个开源的网站`http://httpbin.org`, 是`Python` 领域一个非常有名的开源库作者的 `kennethreitz` 的作品，当然，如果你熟悉 `Docker`, 也可以以容器的形式启动：`docker run -p 80:80 kennethreitz/httpbin` 这样本地也可以启动服务，便于访问测试。

**获取资源：Get**

```
func getHandle(rawString string) {
	response, err := http.Get(rawString)
	if err != nil {
		return
	}
	defer response.Body.Close()
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))

}

func ClientUsageGet() {
    
    // get: 分别获取头部信息、ip 地址、user-gent 
	getHandle("http://localhost:80/headers")
	getHandle("http://localhost:80/ip")
	getHandle("http://localhost:80/user-agent")

}
>>
{
  "headers": {
    "Accept-Encoding": "gzip", 
    "Host": "localhost:80", 
    "User-Agent": "Go-http-client/1.1"
  }
}

{
  "origin": "172.17.0.1"
}

{
  "user-agent": "Go-http-client/1.1"
}
```


客户端的获取资源方式非常简便：`http.Get` 即可。查看源码可以看到，其实是调用了内置默认的`http.Client` 结构体的 `Get` 方法。

```
type Client struct {
    
    Transport RoundTripper
    CheckRedirect func(req *Request, via []*Request) error
    Jar CookieJar
    Timeout time.Duration
}


func Get(url string) (resp *Response, err error) {
	return DefaultClient.Get(url)
}

var DefaultClient = &Client{}
```


开发者可以借鉴到什么呢？

1. 如果需要定制，即示例化 `Client` 结构体，给结构体参数赋相应的属性的值即可
2. 如果只使用默认的，源码中先示例化一个默认的 `Client` 即可


这种方式，在源码中经常可以看到，当然默认的初始化不一定以 `Default`开头。比如之前的 `flag` 章节其实也有默认的 `FlagSet` 命名为 `CommandLine`


**创建资源：Post、PostForm**

```
func postHandle(rawString string, body io.Reader) {
	response, err := http.Post(rawString, "application/json", body)
	if err != nil {
		return
	}
	defer response.Body.Close()
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))
}

func ClientUsage() {
    
    // post
	var buf bytes.Buffer
	buf.WriteString("hello golang")
	postHandle("http://localhost:80/anything", &buf)

	val := strings.NewReader("hello python")
	postHandle("http://localhost:80/anything", val)

	bytesNew := struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}{
		Name: "Golang",
		Age:  10,
	}
	byt, _ := json.Marshal(bytesNew)
	postHandle("http://localhost:80/anything", bytes.NewReader(byt))
	
	// PostForm
	response, err := http.PostForm("http://localhost:80/anything", url.Values{
		"name": []string{"Golang"},
		"age":  []string{"10"},
	})
	if err != nil {
		return
	}
	defer response.Body.Close()
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))
}

ClientUsage()
>>

{
  "args": {}, 
  "data": "hello golang", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept-Encoding": "gzip", 
    "Content-Length": "12", 
    "Content-Type": "application/json", 
    "Host": "localhost:80", 
    "User-Agent": "Go-http-client/1.1"
  }, 
  "json": null, 
  "method": "POST", 
  "origin": "172.17.0.1", 
  "url": "http://localhost:80/anything"
}

{
  "args": {}, 
  "data": "hello python", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept-Encoding": "gzip", 
    "Content-Length": "12", 
    "Content-Type": "application/json", 
    "Host": "localhost:80", 
    "User-Agent": "Go-http-client/1.1"
  }, 
  "json": null, 
  "method": "POST", 
  "origin": "172.17.0.1", 
  "url": "http://localhost:80/anything"
}

{
  "args": {}, 
  "data": "{\"name\":\"Golang\",\"age\":10}", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Accept-Encoding": "gzip", 
    "Content-Length": "26", 
    "Content-Type": "application/json", 
    "Host": "localhost:80", 
    "User-Agent": "Go-http-client/1.1"
  }, 
  "json": {
    "age": 10, 
    "name": "Golang"
  }, 
  "method": "POST", 
  "origin": "172.17.0.1", 
  "url": "http://localhost:80/anything"
}

{
  "args": {}, 
  "data": "", 
  "files": {}, 
  "form": {
    "age": "10", 
    "name": "Golang"
  }, 
  "headers": {
    "Accept-Encoding": "gzip", 
    "Content-Length": "18", 
    "Content-Type": "application/x-www-form-urlencoded", 
    "Host": "localhost:80", 
    "User-Agent": "Go-http-client/1.1"
  }, 
  "json": null, 
  "method": "POST", 
  "origin": "172.17.0.1", 
  "url": "http://localhost:80/anything"
}
```

与获取资源不同的是，`Post` 或者 `PostForm` 需要传递参数给服务端，服务端再进行进一步的处理操作。

上文的示例都是使用的默认的客户端进行访问服务端的资源的操作，这种情况下，能够满足大部分的需求，如果想要定制，需要示例化相应的结构体，调用相应的方法。


```
func redirectPolicyFunc(req *http.Request, via []*http.Request) error {
	if strings.Contains(req.URL.Path, "header") {
		return errors.New("header")
	}
	return nil

}
func UserClientUsage() {
	request, _ := http.NewRequest(http.MethodGet, "http://localhost:80/ip", nil)
	client := &http.Client{
		CheckRedirect: redirectPolicyFunc,
	}
	response, _ := client.Do(request)
	defer response.Body.Close()
	content, _ := ioutil.ReadAll(response.Body)
	fmt.Println(string(content))
}

```

- 示例化 `http.Client`, 调用 `http.Client` 的 `Do` 方法


客户端充当的是获取资源的角色，那么如何操作提供服务的的服务端呢？



### 2

服务端主要的角色是提供资源访问的服务，在 `Golang` 中可以快速的启动 `web` 服务，经常启动 `web` 服务的方式有下面几种。


**1. 默认的形式**

```
func main() {
	http.HandleFunc("/hello_golang", func(writer http.ResponseWriter, request *http.Request) {
	writer.Write([]byte("Hello Golang"))
})
    log.Fatal(http.ListenAndServe(":8080", nil))
    
}

```

最常用的方式是直接使用默认的方式，像上文的那样。实际上默认的使用方式不过是使用了一个内置的默认的实例化的`ServeMux`

```
// 源码

func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}

func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

```

上文的服务端资源的获取可以这样调用：

```
curl http://localhost:8080/hello_golang 

>>
Hello Golang
```


**2. 实现Handler接口**

```
type SelfHandler struct {
}

func (SelfHandler) ServeHTTP(writer http.ResponseWriter, req *http.Request) {
	writer.Write([]byte("Hello Python"))
}
func main(){
    
    var self SelfHandler
	http.Handle("/hello_python", self)
	log.Fatal(http.ListenAndServe(":8080", nil))
    
}

```

其实最重要的其实是 `Handler` 接口，自定义结构体，实现`ServeHTTP` 方法即可。

```
// 源码

type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}

```

上文的服务端的资源的获取，可以这样调用：

```
curl http://localhost:8080/hello_python

>>
Hello Python
```

**3. 自定义HTTP服务器配置**

```
type Self struct {
}

func (Self) ServeHTTP(writer http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(writer, "Hello Self Sever 1")
}

func (Self) Say(writer http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(writer, "Hello Self Sever 1")
}

func main(){
    
    var selfServer http.Server
    
	var selfHandler Self
	
	var selfMux *http.ServeMux
	
	selfMux = &http.ServeMux{}
	
	selfHandler = Self{}
	
	selfMux.Handle("/say", selfHandler)
	
	selfServer = http.Server{
		Handler: selfHandler,
		Addr:    "localhost:9099",
	}
	
	log.Fatal(selfServer.ListenAndServe())
}

```

方法三，自定义服务器配置，代替了默认的服务器配置，自定义了 `Handler` 和服务器端口和地址。


当然，还可以配置读写超时时间，配置请求头最大字节数等。

上文的服务端的资源的调用，可以这样使用：

```
curl http://localhost:9099/say

>>
Hello Self Sever 1
```



这是几种常见的启动`web`服务的方式。可以看出`web` 服务最核心的是下面几点：

- 设置路由：即访问的地址（链接）
- 设置路由对应的控制器：即决定访问路由后触发的动作，比如为什么上文访问对应的路由会返回不同的内容
- 启动相应的服务：确定端口等，即访问的主机的地址和端口



为什么会产生上面的三种方式呢，通过下面的思维导图能够知道：

![](http://ww1.sinaimg.cn/large/741fdb86gy1g2t4irma9cj213z0gg0ut.jpg)


**总结**

在 `Go` 中能够非常简便的进行客户端或者服务端的行为，仅仅使用内置库，就能很方便的实现诸如网络请求、启动网络服务。

`net/http` 库核心包括两个方面：`Client` 和 `Server` 即客户端和服务端，做后端开发的同学应该很熟悉这两个概念，尤其是做`web` 开发的。客户端角色是发起网络请求，服务端的角色是提供资源访问，稍微扩充下，就可以使用内置的`net/http` 打造性能较好的 `web` 服务。当然，原生的再路由层面的设计并不完美，所以衍生了很多的第三方的基于 `net/http` 的`web` 框架，诸如 `gin、beego、echo、iris`等，第三方库提高了开发人员的开发效率，在企业中经常使用来业务开发，但所有的本质都是对`net/http` 的封装或者优化。






## sort

排序算法是非常常见的算法，内置库实现了插入排序、归并排序、堆排序和快速排序，但几种排序算法方法不可访问，用于内置的包来访问。使用过程中也无需关心使用了哪种排序算法。内置库提供了对常见数据类型的排序。

排序包含哪些动作呢？

- 升序、降序
- 是否排序
- 对任意数据类型排序


对数值型数组进行排序，很好理解，如何对结构体排序呢？结构体包含多个属性或者说是字段，对结构体排序，应该按照某一个属性或者字段进行排序，否则无法比较。

内置库也提供了相应的接口，实现对任意数据类型的排序。

![](http://ww1.sinaimg.cn/large/741fdb86gy1g2t5dfqwpyj213z0a4gnc.jpg)

**整型排序**

```
func SortIntsUsage() {
	list := []int{10, 9, 2, 8, 3}
	sort.Ints(list)
	fmt.Println(list)
	sort.Sort(sort.Reverse(sort.IntSlice(list)))
	fmt.Println(list)
}

SortIntsUsage()
>>
[2 3 8 9 10]
[10 9 8 3 2]
```

**浮点型排序**

```
func SortFloatsUsage() {
	list := []float64{10, 9, 1.2, 3.4, 12.1}
	sort.Float64s(list)
	fmt.Println(list)
	sort.Sort(sort.Reverse(sort.Float64Slice(list)))
	fmt.Println(list)
}
SortFloatsUsage()

>>
[1.2 3.4 9 10 12.1]
[12.1 10 9 3.4 1.2]

```

**字符串型排序**

```
func SortStringsUsage() {
	list := []string{"a", "A", "c", "C", "B", "b"}
	sort.Strings(list)
	fmt.Println(list)
	sort.Sort(sort.Reverse(sort.StringSlice(list)))
	fmt.Println(list)
}
SortStringsUsage()
>>
[A B C a b c]
[c b a C B A]

```

字符串按照首字母的`ASCII`码进行排序。

可以看到可以很方便的实现对内置基本类型的排序，那如何对任意类型，比如复杂的结构体排序呢？

答案：实现`Interface` 接口

```
// 源码

type Interface interface {
	// Len is the number of elements in the collection.
	Len() int
	// Less reports whether the element with
	// index i should sort before the element with index j.
	Less(i, j int) bool
	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}

```

实现 `Interface` 接口，需要实现三个方法：`Len、Less、Swap`


示例：

```
type Language struct {
	Year    int    `json:"year"`
	Name    string `json:"name"`
	Account string `json:"account"`
}

type Languages []Language

func (ls Languages) Len() int {
	return len(ls)
}
func (ls Languages) Less(i, j int) bool {
	return ls[i].Year < ls[j].Year
}
func (ls Languages) Swap(i, j int) {
	ls[i], ls[j] = ls[j], ls[i]
}

func SortStruct() {
	list := Languages{
		{
			10, "Golang", "Google",
		}, {
			28, "Python", "Google",
		}, {
			30, "Java", "***",
		}, {
			1, "Lua", "23",
		},
	}
	fmt.Println("Ori", list)
	sort.Sort(list)
	fmt.Println("sort", list)
}

func main(){
   SortStruct() 
}

>>
Ori [{10 Golang Google} {28 Python Google} {30 Java ***} {1 Lua 23}]
sort [{1 Lua 23} {10 Golang Google} {28 Python Google} {30 Java ***}]
```

自定义的结构体`Languages` 按照字段`Year` 从小到大排序。即使用者实现`Interface` 接口即可。

再回过头来看看内置的提供的基本数据类型的排序是如何做到的？

```
// 源码

type IntSlice []int

func (p IntSlice) Len() int           { return len(p) }
func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

func Ints(a []int) { Sort(IntSlice(a)) }

```


可以看出，内置的是已经实现了 `Interface` 接口。


同样的浮点型、字符型的都是实现了 `Interface` 接口。

**总结**

内置的排序库，可以很方便的让开发者实现对基本数据类型的排序，或者对自定义结构体按照某一个字段排序，只需要实现`Interface` 接口即可。使用者无需关心内置到底使用了哪种排序算法。




## error


`Go` 语言不像其他编程语言一样，可以对错误或者异常经常捕获操作，所以代码中经常会充斥着对错误信息的处理逻辑。

项目中如何实现错误类型，大型项目中又如何对错误信息进行处理呢？


示例：

```
func ErrorUsage() {

	err := errors.New("err: found 1")
	if err != nil {
		fmt.Println(err.Error())
	}
	err2 := fmt.Errorf("err: %s", "found 2")
	if err2 != nil {
		fmt.Println(err2.Error())
	}
}

ErrorUsage()
>>
err: found 1
err: found 2
```

实现错误类型，可以有两种方式：`errors.New` 或者 `fmt.Errorf`， 这两种方式的实质是一样的，一种带格式，一种不带格式，底层其实是一样的。

```
// 源码

// fmt
func Errorf(format string, a ...interface{}) error {
	return errors.New(Sprintf(format, a...))
}

// errors
func New(text string) error {
	return &errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}

```

实质上`errors.New` 实例化的 `errorString` 是实现了内置的`error` 接口。

```
type error interface {
	Error() string
}
```


如果你想自定义自己项目类型的错误类型，最常用的方法是实现`error` 接口。


示例：

```
type SelfError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

func (self SelfError) Error() string {
	return fmt.Sprintf("Code: %d, Message: %s", self.Code, self.Message)
}

func UsageError(value string) error {
	var self SelfError
	if value == "" {
		self.Code = 400
		self.Message = "fail"
		return self
	}
	return nil
}

func UserErrorUsage() {

	err3 := UsageError("")
	if err3 != nil {
		fmt.Println(err3.Error())
	}

}

UserErrorUsage()
>>

Code: 400, Message: fail
```

如果你会频繁的阅读源码的话，应该能从中发现，一般的包内是如何进行错误信息的处理？

包的作用是解决某一个单独的问题，比如字符串处理、排序啊等，所以整体的和企业级的错误处理的方式还不太一样，一般作者的思路是在包的起始未知定义一些频繁使用的错误类型。

真实的企业项目，一般是自定义一个结构体，定义好字段，单独成为项目的 `error` 包，该结构体实现了内置`error` 接口。单独成为一个包的好处是在项目中多处复用。




## 总结


日常开发过程中，最常用的内容，一定是内置库的使用，对内置库的熟练程度，一定程度上反应开发人员对编程语言的熟悉程度，内置库内包含了语言设计者的诸多编程思想，指得反复研读。

查看文档有两种方式：1. 查看在线的文档：https://godoc.org/ 2. 如果访问有困难，本地安装好 `go` ，设置好相关的环境变量之后，本地启动文档服务：`godoc -http=:port` 本地访问：`http://localhost:port` 即可


|名称|作用|文档地址|
|:---|:---|:---|
|os|1|2|




另外长期对内置库源代码的梳理发现这些值的学习的地方：

- 注释
- 命名、以及函数的长度
- 可导出的函数一般都内容都很短，使用其他辅助函数替换
- 通常使用内置一个`Default_X` 变量，可以直接使用结构体的方法
- 也可以实例化一个结构体变量，再使用结构的方法


